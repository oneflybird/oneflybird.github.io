<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>修改博客图片的方法</title>
      <link href="2021/05/10/%E4%BF%AE%E6%94%B9%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>2021/05/10/%E4%BF%AE%E6%94%B9%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1><span id="修改博客图片的方法">修改博客图片的方法</span></h1><p>博客上的图片分为两种：</p><ol><li>banner图片</li><li>文章预览上面的图片</li></ol><h2><span id="banner图片">banner图片</span></h2><ol><li>将图片存储到/themes/hexo-theme-matery/source/medias/banner下面</li><li>在/themes/hexo-theme-matery/layout/_partial/bg-cover.ejs 文件中的最后一行修改数字为最后一个照片编号+1【因为是向下舍入的】即可</li></ol><h2><span id="文章预览上面的图片">文章预览上面的图片</span></h2><ol><li>将图片存储到/themes/hexo-theme-matery/source/medias/featureimages下面</li><li>在themes/hexo-theme-matery/_config.yml文件中添加新的图片名即可</li></ol>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git关于分支的易混淆点</title>
      <link href="2021/05/10/git%E5%85%B3%E4%BA%8E%E5%88%86%E6%94%AF%E7%9A%84%E5%87%A0%E4%B8%AA%E6%98%93%E6%B7%B7%E6%B7%86%E7%82%B9/"/>
      <url>2021/05/10/git%E5%85%B3%E4%BA%8E%E5%88%86%E6%94%AF%E7%9A%84%E5%87%A0%E4%B8%AA%E6%98%93%E6%B7%B7%E6%B7%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h3><span id="git-切换分支时会把未add或未commit的内容带过去">git 切换分支时会把未add或未commit的内容带过去</span></h3><blockquote><p>每一次修改都会放入工作区，工作区是未add的修改（未被git跟踪），暂存区是未commit的修改。</p></blockquote><p>对于所有分支而言， 工作区和暂存区是公共的。</p><p>想要将工作区和暂存区在不同的分支下也进行隔离， 怎么办呢？</p><p> <code>git stash</code></p><p>要注意，在当前分支git stash的内容， 在其他分支也可以<code>git stash pop</code>出来。</p><p>因为工作区和暂存区是公共的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区块链与比特币</title>
      <link href="2021/05/10/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%8E%E6%AF%94%E7%89%B9%E5%B8%81/"/>
      <url>2021/05/10/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%8E%E6%AF%94%E7%89%B9%E5%B8%81/</url>
      
        <content type="html"><![CDATA[<h1><span id="区块链与比特币">区块链与比特币</span></h1><h2><span id="区块链">区块链</span></h2><p>视频来源：<a href="https://www.imooc.com/learn/988" target="_blank" rel="noopener">区块链技术核心概念与原理讲解</a></p><h3><span id="前世">前世</span></h3><ol><li>Hashcash,使用了POW（工作量证明）</li><li>时间戳方法（保证数字文件的安全协议）</li><li>B-money（强调点对点交易和不可更改记录）</li><li>加密现金</li><li>比特币：一个点对点（去中心化）的电子现金系统</li></ol><blockquote><p>区块链远不仅仅是比特币，是一系列技术的集合</p></blockquote><h3><span id="为什么叫区块链">为什么叫区块链</span></h3><p>比特币系统里的数据是以一个个区块的形式存储，并通过哈希的方式把一个个区块连接起来，其中每个区块的区块头是序号，时间戳和Hash值，下面的内容是交易记录。</p><h3><span id="应用场景">应用场景</span></h3><p>资产：数字资产发行，交易</p><p>记账：股权交易，商业积分</p><p>不可篡改：医疗证明，存在性证明</p><p>点对点：共享经济，物联网（去除第三方降低成本）</p><p>隐私：匿名交易</p><hr><h2><span id="比特币">比特币</span></h2><blockquote><p>比特币是数字货币和去中心化记账系统</p></blockquote><h3><span id="为什么他能成为数字货币相较于现金的优点">为什么他能成为数字货币（相较于现金的优点）</span></h3><blockquote><ul><li>财产只受自己控制（没有如银行的第三方）</li><li>无通胀（总额是固定的）</li><li>没有假钞</li><li>流通性好（可以全球点对点直接流通）</li></ul></blockquote><h3><span id="去中心化记账系统">去中心化记账系统</span></h3><p><strong>中心化记账系统</strong>有个中央服务器（数据库），而比特币的数据不储存于中央服务器中，而存在于<strong>比特币网络中的每一个节点（电脑）</strong> 。</p><h3><span id="比特币原理主要问题的处理方式">比特币原理（主要问题的处理方式）</span></h3><ol><li>账本如何验证？（哪一个账本是有效的）</li><li>所有权问题？（如何证明谁拥有货币）</li><li>既然记账会消耗资源，为什么记账？（挖矿-工作量证明）</li><li>以谁的账本为准？（共识机制）</li></ol><h4><span id="账本如何验证">账本如何验证</span></h4><blockquote><p>在中心化记账系统中，如果服务器的数据被篡改，由于只有一方有数据，基本没办法验证，所以去中心化记账系统安全性更高。</p></blockquote><hr><h5><span id="hash">Hash</span></h5><blockquote><p>哈希函数：Hash（原始信息）=摘要信息</p></blockquote><h5><span id="特点">特点：</span></h5><ol><li>同样的原始信息总能得到相同的摘要信息</li><li>原始信息任何微小的变化都会哈希出面目全非的摘要信息</li><li>从摘要信息无法逆向推算出原始信息</li></ol><hr><h5><span id="验证原理">验证原理</span></h5><p>对账本进行哈希后得到摘要信息，然后将摘要信息和其他人的摘要信息进行核对，对比摘要比对比原始信息高效很多。账本增加新记录(第二个账本)之后，将之前账本的Hash值和当前账本作为原始信息进行Hash运算，如果此Hash值正确，说明所有之前账本的信息都是正确的。同时，第二个账本也会生成一个区块，所有区块串联的结构被称为区块链，每个节点在核对数据时只需要最后一个区块的摘要信息。</p><h4><span id="账户所有权问题">账户所有权问题</span></h4><blockquote><p>在现实生活中若发生盗刷等情况，可以通过银行核对个人信息来取消交易记录。而比特币系统是点对点交易无第三方，可以更好地保护个人隐私和安全。</p></blockquote><h5><span id="前提">前提</span></h5><p>比特币账户是用地址(进制)来表示的，比特币是从一个地址转移到另一个地址，账本上不保存任何个人信息。一个地址有一个对应的私钥（类似密码）（注：私钥不可更改，不可通过地址推出私钥，但<strong>可通过私钥推出地址</strong>(两次哈希一次fun)）因此所有权问题是在不泄露私钥的情况下来证明我们拥有某个私钥。</p><h5><span id="原理">原理</span></h5><h6><span id="非对称加密技术交易签名">非对称加密技术(交易签名)</span></h6><p>对交易进行hash得到摘要，然后用<em>私钥对摘要</em>进行签名(为避免私钥泄露这一步应尽量在安全的情况下)，在签名运算之后进行广播交易。</p><blockquote><ul><li>hash参数为付款地址，收款地址和金额</li><li>签名参数为交易摘要，私钥，返回签名信息</li></ul></blockquote><h6><span id="广播交易">广播交易</span></h6><p>广播内容包含交易的原始信息和交易的签名信息，广播到周围节点，当验证通过之后，会将交易信息写入到账本中，之后会继续广播到附近已知的节点。</p><blockquote><p>验证：验证<strong>签名信息是不是付款方对原始信息进行签名产生</strong>和余额是否足够。验证参数为<em>付款方地址和签名信息</em>，如果验证的运算结果是原始信息的摘要，则验证通过。实际上签名和验证是逆运算，签名是加密的过程，验证是解密的过程。签名由私钥发出被其他节点认证通过，所以<strong>账户的所有权是由私钥控制</strong>。</p></blockquote><h4><span id="为什么要记账">为什么要记账</span></h4><blockquote><p>记账是把交易记录，交易时间和序号等信息进行hash打包的过程，消耗计算机资源，在比特币里面，如果记账（挖矿）成功会有奖励（比特币），这个奖励就是比特币发行的过程。</p></blockquote><h5><span id="挖矿-工作量证明解决冲突">挖矿-工作量证明（解决冲突）</span></h5><ol><li>一段时间内（与密码学难度互相影响）只有一人可以记账成功</li><li>通过解决密码学难题（即工作量证明）竞争获得唯一记账权</li></ol><p>如果以Hash(上一个Hash值，交易记录值)，只要进行hash就可以记账成功，难度太低，因此为了提高难度，规定Hash(上一个Hash值，交易记录集，随机数)=000000adsxds，摘要信息要以n(n是提前规定好的)个0开头，由于hash值具有随机性，所以是否记账成功也有随机性，由于记账成功奖励很高，就把记账称为挖矿。</p><p>率先找到hash值的节点拥有唯一记账权，将交易记录集进行打包形成区块进入区块链中的节点获得奖励，其他节点只是复制账本。</p><h5><span id="交易记录集">交易记录集</span></h5><ol><li><p>收集广播中还没有被记录账本的交易</p></li><li><p>验证没有被记录账本交易的有效性</p></li><li>添加一笔给自己转账的交易（挖矿奖励）</li></ol><h4><span id="共识机制">共识机制</span></h4><p>如果两个节点同时完成工作量证明，使用谁的区块？</p><blockquote><ol><li>每个节点只认可累计工作量最大的<strong>区块链</strong>，每个节点的行为都是独立的，2. 他们会选择延长最长链</li></ol></blockquote><p>（机制1和机制2有冲突吗？)</p><h5><span id="为什么要遵守以上协议">为什么要遵守以上协议</span></h5><p>节点工作量只有在其他的节点认同才是有效的。</p><h5><span id="具体分析">具体分析</span></h5><blockquote><p>主链：区块最多的链</p></blockquote><p>由于广播需要时间，当两个节点A和B同时完成工作量证明时，当其他节点分别只收到a链和b链时(分别由链接a块或b快形成)，都会认为此链是主链，在这条链上进行挖矿。当有节点两个块都收到时，会对比两个块的工作量，选择工作量最多的链作为主链，另外一个作为备用链保存，因为备用链可能会因为之后产生更多的块而成为主链，这时候出现了两条链形成了<strong>分叉</strong></p><h6><span id="分叉解决">分叉解决</span></h6><p>总会有一方抢先继续产生了工作量证明，然后把其区块链延长，由于机制二，所有其他链都会舍弃当前的短链选择此长链，分叉解决</p><p>由于网络不确定性，有的节点会先收到后面的区块再收到前面的区块，此时就会把区块放到孤块池里，直到收到前面的区块把他串联起来。</p><blockquote><p>比特币把出块间隔设置为10分钟，其实是在更快的交易和在更低的分叉概率间做出了妥协。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 概念 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>什么是钩子</title>
      <link href="2021/05/10/%E4%BB%80%E4%B9%88%E6%98%AF%E9%92%A9%E5%AD%90/"/>
      <url>2021/05/10/%E4%BB%80%E4%B9%88%E6%98%AF%E9%92%A9%E5%AD%90/</url>
      
        <content type="html"><![CDATA[<h2><span id="什么是钩子">什么是钩子</span></h2><p>钩子源于hook，即在消息过去之前先把消息钩住，不让消息执行，自己先优先处理。</p><p>钩子实际上是一个处理消息的程序段，通过系统调用，把它挂入系统。每当特定的消息发出，在没有到达目的窗口前，钩子程序就先捕获该消息，亦即钩子函数先得到控制权。这时钩子函数即可以加工处理（改变）该消息，也可以不作处理而继续传递该消息，还可以强制结束消息的传递。</p><h3><span id="钩子列表">钩子列表</span></h3><p>一个Hook都有一个与之相关联的指针列表，称之为钩子链表，由系统来维护。这个列表的指针指向指定的，应用程序定义的，被Hook子程调用的回调函数，也就是该钩子的各个处理子程。当与指定的Hook类型关联的消息发生时，系统就把这个消息传递到Hook子程。一些Hook子程可以只监视消息，或者修改消息，或者停止消息的前进，避免这些消息传递到下一个Hook子程或者目的窗口。最近安装的钩子放在链的开始，而最早安装的钩子放在最后，也就是后加入的先获得控制权。 </p><h3><span id="hook的应用">hook的应用</span></h3><blockquote><p>有一些技术时利用hook的，比如一些程序经常会校验自身签名，不允许你改动程序安装包，这个时候如果Hook住校验的函数，假装处理为校验通过（其实根本没通过，因为你能优先处理并返回，所以执行不到原始的代码了），这种情况下酒欺骗了原始程序，从而达到目的。</p></blockquote><blockquote><p>程序挂载全局钩子从而被360拦截的例子（其实360也有钩子，不然怎么知道别人要挂载钩子呢？即360可以拦截“挂载钩子”的消息。这个弹窗就是在360的钩子函数中创建的）</p></blockquote><hr><h4><span id="相关翻译">相关翻译</span></h4><blockquote><p>DDL: 动态链接库</p><p>Hook Chain ： 钩子链表</p><p>hook procedures ： 钩子子程（即得到消息后进行处理的程序段） </p></blockquote><p>##</p>]]></content>
      
      
      <categories>
          
          <category> 概念 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>原码，反码，补码的用途</title>
      <link href="2021/05/10/%E5%8E%9F%E7%A0%81%EF%BC%8C%E5%8F%8D%E7%A0%81%EF%BC%8C%E8%A1%A5%E7%A0%81%E7%9A%84%E7%94%A8%E9%80%94/"/>
      <url>2021/05/10/%E5%8E%9F%E7%A0%81%EF%BC%8C%E5%8F%8D%E7%A0%81%EF%BC%8C%E8%A1%A5%E7%A0%81%E7%9A%84%E7%94%A8%E9%80%94/</url>
      
        <content type="html"><![CDATA[<h2><span id="问题-为什么计算机里要存在补码只有反码不可以吗">问题： 为什么计算机里要存在补码，只有反码不可以吗？</span></h2><p>我们想求 2 - 1，但我们不想在计算机内部用减法去完成这件事</p><p>所以，我们可以曲线救国，利用高位溢出，使用2 + 127-128去完成</p><blockquote><p> 什么叫高位溢出呢？</p><p> 1111 1111 + 0000 0001 结果是1 0000 0000 ，但新的最高位计算机保存不下，就抛弃了</p><p> 上述过程转换成十进制即：（目的）127 + 1  ==&gt; （实际）127 + 1 -128 ==&gt; 0</p></blockquote><p>如果不用补码直接用反码会发生什么呢？</p><p>先来看一下 怎么求出反码：</p><p>原码：0000 0001</p><p>反码：1111 1110</p><p>原码是1，反码就变成了 126。</p><p>发现规律了吗？ </p><p>反码是由 1111 1111 - 0000 0001 得到的，即<strong>127 - 1</strong>得到的</p><p>回到上面，如果 -1 在内部用反码存储，2 + （- 1） 就会变成 2 + 126 - 128 = 0，与目标数值1相比小了1</p><p>从二进制角度看一下上述过程</p><p>0000 0010 + 1111 1110 =  1 0000 0000</p><h3><span id="根本原因是什么"><strong>根本原因是什么？</strong></span></h3><p><strong>最高位不一致</strong>。我们的目的是让 -1 在内部保存为 127（即128-1），这样就可以通过高位溢出，最后减去128得到原来的值 -1。</p><p>但是128的二进制是1 0000 0000，位数超过了8位，计算机内部保存不了，所以没办法直接使用128-1得到127。</p><p>反码最大只能是127，二进制即1111 1111，这是计算机内部可以保存的最大数值，离 128 差了0000 0001。</p><p>因此，需要存在补码【反码 +1 =（127-x）+ 1 = 127+1 - x】，这样就可以得到 128 - x。</p><p>最后，我们就能够达到最终目的：利用高位溢出可以使加法变成减法。</p><p>分析完毕，上述只拿了8位的int举例，16位36位也是如此。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机原理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用GitHub Action进行hexo自动化部署</title>
      <link href="2021/04/15/hexo%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/"/>
      <url>2021/04/15/hexo%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>当自己使用github action完成hexo自动化构建时非常开心！！！相当有成就感！！虽然不是什么大佬的操作，但也算是自己用技术改变自己的生活了！然鹅开心之后发现自己并没有什么人可以分享= =所以就来写篇博客吧～</p></blockquote><p>参考文章：<a href="https://blog.si-yee.com/2020/05/26/Github-Action-%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2Hexo/" target="_blank" rel="noopener">https://blog.si-yee.com/2020/05/26/Github-Action-%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2Hexo/</a></p><p>GitHub Actions 是 GitHub 的<strong>持续集成服务</strong>。</p><p>事实上我不是第一次见到持续集成这个词，之前在公司例会分享tekton时也有讲到这个，但是那个时候自己没有接触过这个词，只感觉好高大上啊，感觉平时把公司代码传到github上就可以自动化构建镜像包好吊好方便啊，然后看例会pdf看完后其实没怎么看懂，所以也没有想过自己去使用这个工具啥的。</p><p>但是作为合格的摸鱼实习生没有啥活干，某天灵光一现，就突然想到能不能用类似于持续集成的工具来解决自己使用hexo部署博客时的痒点，说干就干，唉干完后也没啥人能分享，于是就有了这篇博客。</p><p>扯淡结束，正文开始。</p><hr><h2><span id="想要解决的问题">想要解决的问题</span></h2><p>自己使用hexo时的痒点：</p><p>平时在本地写完博客后可以使用hexo d把渲染后的静态文件<em>(在.deploy文件下)</em>推到github.io仓库进行部署，推送完之后别人即可通过网址 <a href="https://oneflybird.github.io/" target="_blank" rel="noopener">https://oneflybird.github.io/</a> 来进行访问，所以其实在日常使用中已经很方便了。</p><p>但是问题出现在了自己想换电脑写博客的时候：我打开typora刷刷刷写好了一篇文章，想更新一下博客，然后发现我需要本地有博客源文件，这样执行hexo d的时候才可以部署到github.io仓库上。但是由于之前一直在一台电脑上写，没有遇到这个问题，所以一直没有把自己的博客源文件也上传到github上做个备份。</p><p>意识到这个问题的我，翻出来自己以前的旧电脑，庆幸自己还好没把电脑进行格式化，美滋滋地把源文件也上传到github上做了个备份。</p><p>接下来，在另一台电脑使用<code>git clone</code>拉下博客源文件仓库即可解决我上面遇到的第一个问题，并且以后可以自由选择不同电脑来写博客啦，不用局限在一台电脑上了～</p><p>接下来就出现了一个让我感觉有点点麻烦的问题，也是此次我想使用持续集成服务解决的问题：</p><p>在我备份博客源文件之前，使用<code>hexo g</code> 和<code>hexo d</code>进行部署就完事了。但现在我还需要使用<code>git add</code>,<code>git commit</code>,<code>git push</code>这一系列操作进行备份，让我感觉有点点繁琐。</p><h3><span id="想要达到的效果">想要达到的效果</span></h3><ol><li>自己使用git操作把博客源文件push到远程仓库</li><li>接下来，不需要自己进行hexo g 和hexo d，有服务会自动帮我完成这一系列操作。</li><li>也就是说，我只要把博客源文件push到仓库上，我的博客就可以进行自动渲染和部署，自己只要打开博客网站 <a href="https://oneflybird.github.io/" target="_blank" rel="noopener">https://oneflybird.github.io/</a> 就能够看到自己最新的博客。</li></ol><h2><span id="解决方案">解决方案</span></h2><h3><span id="配置ssh-key">配置ssh key</span></h3><blockquote><p>目的：让博客源文件仓库<strong>有权限</strong>把.deploy文件夹推送到io仓库进行部署</p></blockquote><h4><span id="生成ssh-key">生成ssh key</span></h4><pre class=" language-bash"><code class="language-bash">ssh-keygen -t rsa -b 4096 -C <span class="token string">"your email"</span> -f ~/.ssh/github-actions-deploy<span class="token comment" spellcheck="true"># 查看key</span><span class="token function">cd</span> ~/.ssh<span class="token function">cat</span> github-actions-deploy<span class="token function">cat</span> github-actions-deploy.pub</code></pre><h4><span id="配置">配置</span></h4><ol><li>在博客<strong>源文件</strong>仓库 ：<strong>Settings -&gt; Secrets</strong> 里添加<strong>私钥</strong>，名称为 <code>ACTION_DEPLOY_KEY</code>。<br><em>注意，要和私钥文件一模一样，包括start和end也要复制粘贴进去。</em></li><li>在用于展示，存放.deploy文件的<strong>.io</strong>仓库：<strong>Settings -&gt; Deploy keys</strong> 添加刚刚生成的<strong>公钥</strong>，名称随意，但要勾选 <strong>Allow write access</strong>。</li></ol><h3><span id="添加github-action">添加github action</span></h3><blockquote><p>github检测到Action文件后便会根据Action文件的内容进行自动化操作（类似于脚本） </p></blockquote><p>在博客源文件仓库目录下，新建 <code>.github/workflows/*随便起名*.yml</code></p><p>脚本配置如下：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">name</span><span class="token punctuation">:</span> Deploy<span class="token key atrule">on</span><span class="token punctuation">:</span>  <span class="token key atrule">push</span><span class="token punctuation">:</span>    <span class="token key atrule">branches</span><span class="token punctuation">:</span>          <span class="token punctuation">-</span> master<span class="token key atrule">jobs</span><span class="token punctuation">:</span>  <span class="token key atrule">build</span><span class="token punctuation">:</span>    <span class="token key atrule">name</span><span class="token punctuation">:</span> Build    <span class="token key atrule">runs-on</span><span class="token punctuation">:</span> ubuntu<span class="token punctuation">-</span>latest    <span class="token key atrule">steps</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> Checkout        <span class="token key atrule">uses</span><span class="token punctuation">:</span> actions/checkout@v2      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> Setup Node         <span class="token key atrule">uses</span><span class="token punctuation">:</span> actions/setup<span class="token punctuation">-</span>node@v1        <span class="token key atrule">with</span><span class="token punctuation">:</span>          <span class="token key atrule">node-version</span><span class="token punctuation">:</span> <span class="token string">'10.x'</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> prepare build env        <span class="token key atrule">env</span><span class="token punctuation">:</span>          <span class="token key atrule">ACTION_DEPLOY_KEY</span><span class="token punctuation">:</span> $<span class="token punctuation">{</span><span class="token punctuation">{</span> secrets.ACTION_DEPLOY_KEY <span class="token punctuation">}</span><span class="token punctuation">}</span>        <span class="token key atrule">run</span><span class="token punctuation">:</span> <span class="token punctuation">|</span><span class="token scalar string">          # set up private key for deploy          mkdir -p ~/.ssh/          echo "$ACTION_DEPLOY_KEY" | tr -d '\r' > ~/.ssh/id_rsa          chmod 600 ~/.ssh/id_rsa          ssh-keyscan github.com >> ~/.ssh/known_hosts          # set git infomation          git config --global user.name 'oneflybird'          git config --global user.email '1361569005@qq.com'</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> NPM        <span class="token key atrule">run</span><span class="token punctuation">:</span> npm install      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> Clean        <span class="token key atrule">run</span><span class="token punctuation">:</span> ./node_modules/.bin/hexo clean      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> Generate        <span class="token key atrule">run</span><span class="token punctuation">:</span> ./node_modules/.bin/hexo generate      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> Deploy        <span class="token key atrule">run</span><span class="token punctuation">:</span> ./node_modules/.bin/hexo deploy</code></pre><p>把git配置改成自己的即可，具体含义也就不多说了，大家把这个文件推送到<strong>博客源文件仓库</strong>上，看看仓库action的执行过程应该就会懂了～</p><h2><span id="完结">完结</span></h2><p>最后，当我写完博客推送到源文件仓库是就可以自动触发构建了。<br>但是，我的脚本仅对自己的博客是有效的，每个人的博客文件可能是不同的，比如我的博客源仓库没有配置Submodule，但有的人配置了，脚本就需要做出改动。<br>因此这篇博客可以用于借鉴，但不能直接照抄喔～</p>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> 持续集成 </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>marshmallow库的简单介绍</title>
      <link href="2021/04/06/marshmallow/"/>
      <url>2021/04/06/marshmallow/</url>
      
        <content type="html"><![CDATA[<h1><span id="marshmallow库">marshmallow库</span></h1><p>marshmallow库是用来进行对象序列化(dump/dumps)和反序列化(load/loads)的处理的。</p><p>简单来说，就是将python里的object对象与list/dict，json字符串对象三者之间进行相互转换</p><ul><li>序列化: 把变量从内存中变成可存储或传输的过程</li></ul><h3><span id="作用">作用</span></h3><ul><li><strong>Validate</strong> input data.</li><li><strong>Deserialize</strong> input data to app-level objects.</li><li><strong>Serialize</strong> app-level objects to primitive Python types.</li></ul><h3><span id="使用">使用</span></h3><ul><li>安装 <code>pip install marshmallow</code></li></ul><h4><span id="最基本的使用例子">最基本的使用例子</span></h4><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> datetime <span class="token keyword">import</span> date<span class="token keyword">from</span> marshmallow <span class="token keyword">import</span> Schema<span class="token punctuation">,</span> fields<span class="token keyword">class</span> <span class="token class-name">User</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">,</span> email<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>name <span class="token operator">=</span> name        self<span class="token punctuation">.</span>email <span class="token operator">=</span> email        self<span class="token punctuation">.</span>created_at <span class="token operator">=</span> dt<span class="token punctuation">.</span>datetime<span class="token punctuation">.</span>now<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 继承Schema，声明自己的类</span><span class="token keyword">class</span> <span class="token class-name">UserSchema</span><span class="token punctuation">(</span>Schema<span class="token punctuation">)</span><span class="token punctuation">:</span>    name <span class="token operator">=</span> fields<span class="token punctuation">.</span>Str<span class="token punctuation">(</span><span class="token punctuation">)</span>    email <span class="token operator">=</span> fields<span class="token punctuation">.</span>Email<span class="token punctuation">(</span><span class="token punctuation">)</span>    created_at <span class="token operator">=</span> fields<span class="token punctuation">.</span>DateTime<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 用于在使用load时把他反序列化为User object</span>    @post_load    <span class="token keyword">def</span> <span class="token function">make_user</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> data<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> User<span class="token punctuation">(</span><span class="token operator">**</span>data<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 初始化schema类</span>schema <span class="token operator">=</span> UserSchema<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 初始化类</span>user <span class="token operator">=</span> User<span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">"Monty"</span><span class="token punctuation">,</span> email<span class="token operator">=</span><span class="token string">"monty@python.org"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 序列化。dumps可以转换为json字符串对象</span>result <span class="token operator">=</span> schema<span class="token punctuation">.</span>dump<span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># {"name": "Monty",</span><span class="token comment" spellcheck="true">#  "email": "monty@python.org",</span><span class="token comment" spellcheck="true">#  "created_at": "2014-08-17T14:54:16.049594+00:00"}</span><span class="token comment" spellcheck="true"># 反序列化。loads可以将json字符串对象转换为object或者字符串/列表</span>user_data <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token string">"created_at"</span><span class="token punctuation">:</span> <span class="token string">"2014-08-11T05:26:03.869245"</span><span class="token punctuation">,</span>    <span class="token string">"email"</span><span class="token punctuation">:</span> <span class="token string">"ken@yahoo.com"</span><span class="token punctuation">,</span>    <span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"Ken"</span><span class="token punctuation">,</span><span class="token punctuation">}</span>result <span class="token operator">=</span> schema<span class="token punctuation">.</span>load<span class="token punctuation">(</span>user_data<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># => &lt;User(name='Ken')></span></code></pre><h4><span id="捕获异常">捕获异常</span></h4><pre><code>try:    result = UserSchema().load({&quot;name&quot;: &quot;John&quot;, &quot;email&quot;: &quot;foo&quot;})except ValidationError as err:    print(err.messages)  # =&gt; {&quot;email&quot;: [&#39;&quot;foo&quot; is not a valid email address.&#39;]}    print(err.valid_data)  # =&gt; {&quot;name&quot;: &quot;John&quot;}</code></pre><h5><span id="可以验证的类型">可以验证的类型</span></h5><table><thead><tr><th><a href="https://marshmallow.readthedocs.io/en/stable/marshmallow.fields.html#marshmallow.fields.AwareDateTime" target="_blank" rel="noopener"><code>AwareDateTime</code></a>(format, *, default_timezone, …)</th><th>A formatted aware datetime string.</th></tr></thead><tbody><tr><td><a href="https://marshmallow.readthedocs.io/en/stable/marshmallow.fields.html#marshmallow.fields.Bool" target="_blank" rel="noopener"><code>Bool</code></a></td><td>alias of <a href="https://marshmallow.readthedocs.io/en/stable/marshmallow.fields.html#marshmallow.fields.Boolean" target="_blank" rel="noopener"><code>marshmallow.fields.Boolean</code></a></td></tr><tr><td><a href="https://marshmallow.readthedocs.io/en/stable/marshmallow.fields.html#marshmallow.fields.Boolean" target="_blank" rel="noopener"><code>Boolean</code></a>(*, truthy, falsy, **kwargs)</td><td>A boolean field.</td></tr><tr><td><a href="https://marshmallow.readthedocs.io/en/stable/marshmallow.fields.html#marshmallow.fields.Constant" target="_blank" rel="noopener"><code>Constant</code></a>(constant, **kwargs)</td><td>A field that (de)serializes to a preset constant.</td></tr><tr><td><a href="https://marshmallow.readthedocs.io/en/stable/marshmallow.fields.html#marshmallow.fields.Date" target="_blank" rel="noopener"><code>Date</code></a>(format, **kwargs)</td><td>ISO8601-formatted date string.</td></tr><tr><td><a href="https://marshmallow.readthedocs.io/en/stable/marshmallow.fields.html#marshmallow.fields.DateTime" target="_blank" rel="noopener"><code>DateTime</code></a>(format, **kwargs)</td><td>A formatted datetime string.</td></tr><tr><td><a href="https://marshmallow.readthedocs.io/en/stable/marshmallow.fields.html#marshmallow.fields.Decimal" target="_blank" rel="noopener"><code>Decimal</code></a>(places, rounding, *, allow_nan, …)</td><td>A field that (de)serializes to the Python <code>decimal.Decimal</code> type.</td></tr><tr><td><a href="https://marshmallow.readthedocs.io/en/stable/marshmallow.fields.html#marshmallow.fields.Dict" target="_blank" rel="noopener"><code>Dict</code></a>(keys, type]] = None, values, …)</td><td>A dict field.</td></tr><tr><td><a href="https://marshmallow.readthedocs.io/en/stable/marshmallow.fields.html#marshmallow.fields.Email" target="_blank" rel="noopener"><code>Email</code></a>(*args, **kwargs)</td><td>A validated email field.</td></tr><tr><td><a href="https://marshmallow.readthedocs.io/en/stable/marshmallow.fields.html#marshmallow.fields.Field" target="_blank" rel="noopener"><code>Field</code></a>(*, default, missing, data_key, …)</td><td>Basic field from which other fields should extend.</td></tr><tr><td><a href="https://marshmallow.readthedocs.io/en/stable/marshmallow.fields.html#marshmallow.fields.Float" target="_blank" rel="noopener"><code>Float</code></a>(*, allow_nan, as_string, **kwargs)</td><td>A double as an IEEE-754 double precision string.</td></tr><tr><td><a href="https://marshmallow.readthedocs.io/en/stable/marshmallow.fields.html#marshmallow.fields.Function" target="_blank" rel="noopener"><code>Function</code></a>(serialize, Any], Callable[[Any, …)</td><td>A field that takes the value returned by a function.</td></tr><tr><td><a href="https://marshmallow.readthedocs.io/en/stable/marshmallow.fields.html#marshmallow.fields.IP" target="_blank" rel="noopener"><code>IP</code></a>(*args[, exploded])</td><td>A IP address field.</td></tr><tr><td><a href="https://marshmallow.readthedocs.io/en/stable/marshmallow.fields.html#marshmallow.fields.IPInterface" target="_blank" rel="noopener"><code>IPInterface</code></a>(*args[, exploded])</td><td>A IPInterface field.</td></tr><tr><td><a href="https://marshmallow.readthedocs.io/en/stable/marshmallow.fields.html#marshmallow.fields.IPv4" target="_blank" rel="noopener"><code>IPv4</code></a>(*args[, exploded])</td><td>A IPv4 address field.</td></tr><tr><td><a href="https://marshmallow.readthedocs.io/en/stable/marshmallow.fields.html#marshmallow.fields.IPv4Interface" target="_blank" rel="noopener"><code>IPv4Interface</code></a>(*args[, exploded])</td><td>A IPv4 Network Interface field.</td></tr><tr><td><a href="https://marshmallow.readthedocs.io/en/stable/marshmallow.fields.html#marshmallow.fields.IPv6" target="_blank" rel="noopener"><code>IPv6</code></a>(*args[, exploded])</td><td>A IPv6 address field.</td></tr><tr><td><a href="https://marshmallow.readthedocs.io/en/stable/marshmallow.fields.html#marshmallow.fields.IPv6Interface" target="_blank" rel="noopener"><code>IPv6Interface</code></a>(*args[, exploded])</td><td>A IPv6 Network Interface field.</td></tr><tr><td><a href="https://marshmallow.readthedocs.io/en/stable/marshmallow.fields.html#marshmallow.fields.Int" target="_blank" rel="noopener"><code>Int</code></a></td><td>alias of <a href="https://marshmallow.readthedocs.io/en/stable/marshmallow.fields.html#marshmallow.fields.Integer" target="_blank" rel="noopener"><code>marshmallow.fields.Integer</code></a></td></tr><tr><td><a href="https://marshmallow.readthedocs.io/en/stable/marshmallow.fields.html#marshmallow.fields.Integer" target="_blank" rel="noopener"><code>Integer</code></a>(*, strict, **kwargs)</td><td>An integer field.</td></tr><tr><td><a href="https://marshmallow.readthedocs.io/en/stable/marshmallow.fields.html#marshmallow.fields.List" target="_blank" rel="noopener"><code>List</code></a>(cls_or_instance, type], **kwargs)</td><td>A list field, composed with another <a href="https://marshmallow.readthedocs.io/en/stable/marshmallow.fields.html#marshmallow.fields.Field" target="_blank" rel="noopener"><code>Field</code></a> class or instance.</td></tr><tr><td><a href="https://marshmallow.readthedocs.io/en/stable/marshmallow.fields.html#marshmallow.fields.Mapping" target="_blank" rel="noopener"><code>Mapping</code></a>(keys, type]] = None, values, …)</td><td>An abstract class for objects with key-value pairs.</td></tr><tr><td><a href="https://marshmallow.readthedocs.io/en/stable/marshmallow.fields.html#marshmallow.fields.Method" target="_blank" rel="noopener"><code>Method</code></a>(serialize, deserialize, **kwargs)</td><td>A field that takes the value returned by a <code>Schema</code> method.</td></tr><tr><td><a href="https://marshmallow.readthedocs.io/en/stable/marshmallow.fields.html#marshmallow.fields.NaiveDateTime" target="_blank" rel="noopener"><code>NaiveDateTime</code></a>(format, *, timezone, **kwargs)</td><td>A formatted naive datetime string.</td></tr><tr><td><a href="https://marshmallow.readthedocs.io/en/stable/marshmallow.fields.html#marshmallow.fields.Nested" target="_blank" rel="noopener"><code>Nested</code></a>(nested, type, str, Callable[[], …)</td><td>Allows you to nest a <a href="https://marshmallow.readthedocs.io/en/stable/api_reference.html#marshmallow.Schema" target="_blank" rel="noopener"><code>Schema</code></a> inside a field.</td></tr><tr><td><a href="https://marshmallow.readthedocs.io/en/stable/marshmallow.fields.html#marshmallow.fields.Number" target="_blank" rel="noopener"><code>Number</code></a>(*, as_string, **kwargs)</td><td>Base class for number fields.</td></tr><tr><td><a href="https://marshmallow.readthedocs.io/en/stable/marshmallow.fields.html#marshmallow.fields.Pluck" target="_blank" rel="noopener"><code>Pluck</code></a>(nested, type, str, Callable[[], …)</td><td>Allows you to replace nested data with one of the data’s fields.</td></tr><tr><td><a href="https://marshmallow.readthedocs.io/en/stable/marshmallow.fields.html#marshmallow.fields.Raw" target="_blank" rel="noopener"><code>Raw</code></a>(*, default, missing, data_key, …)</td><td>Field that applies no formatting.</td></tr><tr><td><a href="https://marshmallow.readthedocs.io/en/stable/marshmallow.fields.html#marshmallow.fields.Str" target="_blank" rel="noopener"><code>Str</code></a></td><td>alias of <a href="https://marshmallow.readthedocs.io/en/stable/marshmallow.fields.html#marshmallow.fields.String" target="_blank" rel="noopener"><code>marshmallow.fields.String</code></a></td></tr><tr><td><a href="https://marshmallow.readthedocs.io/en/stable/marshmallow.fields.html#marshmallow.fields.String" target="_blank" rel="noopener"><code>String</code></a>(*, default, missing, data_key, …)</td><td>A string field.</td></tr><tr><td><a href="https://marshmallow.readthedocs.io/en/stable/marshmallow.fields.html#marshmallow.fields.Time" target="_blank" rel="noopener"><code>Time</code></a>(format, **kwargs)</td><td>A formatted time string.</td></tr><tr><td><a href="https://marshmallow.readthedocs.io/en/stable/marshmallow.fields.html#marshmallow.fields.TimeDelta" target="_blank" rel="noopener"><code>TimeDelta</code></a>(precision, **kwargs)</td><td>A field that (de)serializes a <a href="https://python.readthedocs.io/en/latest/library/datetime.html#datetime.timedelta" target="_blank" rel="noopener"><code>datetime.timedelta</code></a> object to an integer and vice versa.</td></tr><tr><td><a href="https://marshmallow.readthedocs.io/en/stable/marshmallow.fields.html#marshmallow.fields.Tuple" target="_blank" rel="noopener"><code>Tuple</code></a>(tuple_fields, *args, **kwargs)</td><td>A tuple field, composed of a fixed number of other <a href="https://marshmallow.readthedocs.io/en/stable/marshmallow.fields.html#marshmallow.fields.Field" target="_blank" rel="noopener"><code>Field</code></a> classes or instances</td></tr><tr><td><a href="https://marshmallow.readthedocs.io/en/stable/marshmallow.fields.html#marshmallow.fields.URL" target="_blank" rel="noopener"><code>URL</code></a></td><td>alias of <a href="https://marshmallow.readthedocs.io/en/stable/marshmallow.fields.html#marshmallow.fields.Url" target="_blank" rel="noopener"><code>marshmallow.fields.Url</code></a></td></tr><tr><td><a href="https://marshmallow.readthedocs.io/en/stable/marshmallow.fields.html#marshmallow.fields.UUID" target="_blank" rel="noopener"><code>UUID</code></a>(*, default, missing, data_key, …)</td><td>A UUID field.</td></tr><tr><td><a href="https://marshmallow.readthedocs.io/en/stable/marshmallow.fields.html#marshmallow.fields.Url" target="_blank" rel="noopener"><code>Url</code></a>(*, relative, schemes, Set[str]]] = None, …)</td><td>A validated URL field.</td></tr></tbody></table><h4><span id="通过可选参数使用它的更多功能">通过可选参数使用它的更多功能</span></h4><p><code>only</code>: 返回过滤后的输出，只返回<code>only</code>指定的字段</p><pre><code>summary_schema = UserSchema(only=(&quot;name&quot;, &quot;email&quot;))summary_schema.dump(user)# {&quot;name&quot;: &quot;Monty&quot;, &quot;email&quot;: &quot;monty@python.org&quot;}</code></pre><p><code>many</code>: 处理可迭代对象</p><pre><code>user1 = User(name=&quot;Mick&quot;, email=&quot;mick@stones.com&quot;)user2 = User(name=&quot;Keith&quot;, email=&quot;keith@stones.com&quot;)users = [user1, user2]schema = UserSchema(many=True)result = schema.dump(users)  # OR UserSchema().dump(users, many=True)pprint(result)# [{&#39;name&#39;: u&#39;Mick&#39;,#   &#39;email&#39;: u&#39;mick@stones.com&#39;,#   &#39;created_at&#39;: &#39;2014-08-17T14:58:57.600623+00:00&#39;}#  {&#39;name&#39;: u&#39;Keith&#39;,#   &#39;email&#39;: u&#39;keith@stones.com&#39;,#   &#39;created_at&#39;: &#39;2014-08-17T14:58:57.600623+00:00&#39;}]</code></pre><p><code>required</code>: 必须字段</p><p><code>partial</code>: 忽视必须字段</p><pre><code>class UserSchema(Schema):    name = fields.String(required=True)    age = fields.Integer(required=True)result = UserSchema().load({&quot;age&quot;: 42}， partial=(&quot;name&quot;,))# partial=True：忽视全部必须字段print(result)  # =&gt; {&#39;age&#39;: 42}</code></pre><p><code>missing</code>: 指定默认反序列化缺失的值<br><code>default</code> : 指定默认序列化缺失的值</p><pre><code>class UserSchema(Schema):    id = fields.UUID(missing=uuid.uuid1)    birthdate = fields.DateTime(default=dt.datetime(2017, 9, 29))UserSchema().load({})# {&#39;id&#39;: UUID(&#39;337d946c-32cd-11e8-b475-0022192ed31b&#39;)}UserSchema().dump({})# {&#39;birthdate&#39;: &#39;2017-09-29T00:00:00+00:00&#39;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> package </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>flask获取前端数据的几个方法的区别</title>
      <link href="2021/03/12/flask%E8%8E%B7%E5%8F%96%E5%89%8D%E7%AB%AF%E6%95%B0%E6%8D%AE%E7%9A%84%E5%87%A0%E4%B8%AA%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>2021/03/12/flask%E8%8E%B7%E5%8F%96%E5%89%8D%E7%AB%AF%E6%95%B0%E6%8D%AE%E7%9A%84%E5%87%A0%E4%B8%AA%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2><span id="几种获取方法">几种获取方法</span></h2><table><thead><tr><th>获取方式</th><th>类型</th><th>举例</th></tr></thead><tbody><tr><td><code>request.json</code></td><td>Dict</td><td>存放json类型的数据</td></tr><tr><td><code>request.view_args</code></td><td>Dict</td><td>存放URL中定义的变量 比如/login/&lt;string: username&gt;，会存放{“username”: “xxx”}</td></tr><tr><td><code>request.args</code></td><td>ImmutableMultiDict</td><td>存放URL中<strong>?</strong>后面的变量</td></tr><tr><td><code>request.values</code></td><td>CombinedMultiDict</td><td>args和form的组合</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> flask </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>蜜汁json解析错误</title>
      <link href="2021/03/12/%E8%9C%9C%E6%B1%81json%E8%A7%A3%E6%9E%90%E9%94%99%E8%AF%AF/"/>
      <url>2021/03/12/%E8%9C%9C%E6%B1%81json%E8%A7%A3%E6%9E%90%E9%94%99%E8%AF%AF/</url>
      
        <content type="html"><![CDATA[<h3><span id="场景">场景</span></h3><p>同样的一套代码，在别人电脑上能跑，能用<code>JSONDecodeError</code>来catch，而在自己电脑上就无法捕捉导致代码跑不了。</p><blockquote><p>让人感到迷惑的地方是，这套代码以前在自己电脑上也能跑，突然就报出了这个错误orz，都不敢让人相信是环境问题，我至今也没搞懂为啥。。</p></blockquote><h3><span id="直接原因">直接原因：</span></h3><p>在自己电脑抛出的是<code>simplejson.error.JSONDecodeError</code> 异常，需要 <code>from simplejson import JSONDecodeError</code>，用<code>simplejson</code>的<code>JSONDecodeError</code>来捕捉。</p><p>而在别人电脑上抛出的是<code>json.error.JSONDecodeError</code> 异常，可以用<code>json</code>的<code>JSONDecodeError</code>来捕捉。</p><h3><span id="解决方法">解决方法</span></h3><ol><li>第一种：将<code>from json import JSONDecodeError</code>改为<code>from simplejson import JSONDecodeError</code>，个人不喜欢这种因为需要改动代码。</li><li>第二种：卸载simplejson，经亲身实践，卸载之后抛出的异常就会从<code>simplejson.error.JSONDecodeError</code> 异常变为<code>json.error.JSONDecodeError</code> 异常。</li></ol><p><strong>那么为啥当simplejson存在的时候抛出的异常会变成 <code>simplejson.error.JSONDecodeError</code> 捏！！！！</strong></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 踩坑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>post,put,patch之间的区别</title>
      <link href="2021/03/09/post-put-patch%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>2021/03/09/post-put-patch%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2><span id="总结">总结</span></h2><table><thead><tr><th>区别</th><th>Post</th><th>put</th><th>Patch</th></tr></thead><tbody><tr><td>等幂性</td><td>非等幂</td><td>等幂</td><td></td></tr><tr><td>用处</td><td>创建</td><td>更新资源，如果资源不存在就创建资源</td><td>只更新资源的一部分</td></tr></tbody></table><h2><span id="详细说明">详细说明</span></h2><ol><li><p><strong>POST</strong>是非等幂的,多次调用会产生不同的结果。比如：创建一个用户,由于网络原因或是其他原因多创建了几次，那么将会有多个用户被创建。</p><p><strong>PUT</strong> 多次调用还是会创建的结果是一样的，只会创建一个用户,所以PUT是等幂的。</p></li><li><p>假设我们有一个UserInfo，里面有userId， userName， userGender等10个字段。但我我们的编辑功能因为需求，在某个特别的页面里只能修改userName，这时候需要更新userName。</p><p>如果使用<strong>PATCH</strong>来局部更新资源，只会传一个userName到指定资源去，表示该请求是一个局部更新，后端仅更新接收到的字段，所以<strong>PATCH</strong>一般是用来局部更新资源的,</p><p>如果使用<strong>PUT</strong>来局部更新资源，则会把一个包含了修改后userName的<strong>完整userInfo对象</strong>传给后端，做完整更新。理论上说，如果使用了PUT，但却没有提供完整的UserInfo，那么缺了的那些字段应该被清空。</p></li><li><p><strong>PUT </strong>会有一个create操作，如果加入更新的id不存在，会进行创建。</p><p><strong>PATCH </strong>则不会创建。</p></li></ol><h3><span id="here-is-a-simple-description-of-all">here is a simple description of all</span></h3><ol><li>POST is always for creating a resource ( does not matter if it was duplicated )</li><li>PUT is for checking if resource is exists then update , else create new resource.</li><li>PATCH is always for update a resource.</li></ol>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> flask </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python直接赋值，浅拷贝,深拷贝解析</title>
      <link href="2021/03/03/python%E7%9B%B4%E6%8E%A5%E8%B5%8B%E5%80%BC%EF%BC%8C%E6%B5%85%E6%8B%B7%E8%B4%9D,%E6%B7%B1%E6%8B%B7%E8%B4%9D%E8%A7%A3%E6%9E%90/"/>
      <url>2021/03/03/python%E7%9B%B4%E6%8E%A5%E8%B5%8B%E5%80%BC%EF%BC%8C%E6%B5%85%E6%8B%B7%E8%B4%9D,%E6%B7%B1%E6%8B%B7%E8%B4%9D%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<blockquote><p>参考：<a href="https://www.runoob.com/w3cnote/python-understanding-dict-copy-shallow-or-deep.html" target="_blank" rel="noopener">https://www.runoob.com/w3cnote/python-understanding-dict-copy-shallow-or-deep.html</a></p></blockquote><ul><li><strong>直接赋值：</strong>其实就是对象的引用（别名）。</li></ul><p><img src="https://www.runoob.com/wp-content/uploads/2017/03/1489720931-7116-4AQC6.png" alt="img"></p><ul><li><strong>浅拷贝(copy)：</strong>拷贝父对象，不会拷贝对象的内部的子对象。</li></ul><p><img src="https://www.runoob.com/wp-content/uploads/2017/03/1489720930-6827-Vtk4m.png" alt="img"></p><ul><li><strong>深拷贝(deepcopy)：</strong> copy 模块的 deepcopy 方法，完全拷贝了父对象及其子对象，两者完全独立。</li></ul><p><img src="https://www.runoob.com/wp-content/uploads/2017/03/1489720930-5882-BO4qO.png" alt="img"></p><h3><span id="代码实例">代码实例</span></h3><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#!/usr/bin/python</span><span class="token comment" spellcheck="true"># -*-coding:utf-8 -*-</span><span class="token keyword">import</span> copya <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true">#原始对象</span>b <span class="token operator">=</span> a                       <span class="token comment" spellcheck="true">#赋值，传对象的引用</span>c <span class="token operator">=</span> copy<span class="token punctuation">.</span>copy<span class="token punctuation">(</span>a<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">#对象拷贝，浅拷贝</span>d <span class="token operator">=</span> copy<span class="token punctuation">.</span>deepcopy<span class="token punctuation">(</span>a<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">#对象拷贝，深拷贝</span>a<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>                 <span class="token comment" spellcheck="true">#修改对象a</span>a<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">'c'</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">#修改对象a中的['a', 'b']数组对象</span><span class="token keyword">print</span><span class="token punctuation">(</span> <span class="token string">'a = '</span><span class="token punctuation">,</span> a <span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># ('a = ', [1, 2, 3, 4, ['a', 'b', 'c'], 5])</span><span class="token keyword">print</span><span class="token punctuation">(</span> <span class="token string">'b = '</span><span class="token punctuation">,</span> b <span class="token punctuation">)</span><span class="token comment" spellcheck="true"># ('b = ', [1, 2, 3, 4, ['a', 'b', 'c'], 5])</span><span class="token keyword">print</span><span class="token punctuation">(</span> <span class="token string">'c = '</span><span class="token punctuation">,</span> c <span class="token punctuation">)</span><span class="token comment" spellcheck="true"># ('c = ', [1, 2, 3, 4, ['a', 'b', 'c']])</span><span class="token keyword">print</span><span class="token punctuation">(</span> <span class="token string">'d = '</span><span class="token punctuation">,</span> d <span class="token punctuation">)</span><span class="token comment" spellcheck="true"># ('d = ', [1, 2, 3, 4, ['a', 'b']])</span></code></pre><h3><span id="注意">注意</span></h3><p>切片是深拷贝</p><p><code>a = b[:]</code>，b改变之后a不会改变</p><h4><span id="补充">补充</span></h4><p>对于切片 [a :b :c ]：</p><p>a:起始位置，不填写默认为0</p><p>b:结束位置(<strong>不包括序列b</strong>)，不填写默认为到最后</p><p>c:每隔c位，默认为0</p><h5><span id="-1和-1的区别">[::-1]和[:-1]的区别</span></h5><pre class=" language-python"><code class="language-python">li <span class="token operator">=</span> <span class="token string">"abcde"</span>li<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>结果为：<span class="token string">"abcd"</span>li <span class="token operator">=</span> <span class="token string">"abcde"</span>li<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>结果为：<span class="token string">"edcba"</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> 指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s相关的知识</title>
      <link href="2021/03/03/k8s%E7%9B%B8%E5%85%B3%E7%9A%84%E7%9F%A5%E8%AF%86/"/>
      <url>2021/03/03/k8s%E7%9B%B8%E5%85%B3%E7%9A%84%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h2><span id="使用k8s运行一个应用的过程">使用k8s运行一个应用的过程</span></h2><ol><li><p>创建集群</p><p>一切都是在集群（机器）上运行的</p></li><li><p>创建deployment</p><ul><li><p>Deployment是管理 Pod 创建和扩展的推荐方法</p></li><li><p>检查Pod的健康状况，并且在 Pod 中的容器终止的情况下重新启动新的容器</p></li></ul></li><li><p>创建service</p><ul><li><p>创建service之前，Pod 只能通过 Kubernetes 集群中的内部 IP 地址访问。</p></li><li><p>要使得容器可以从 Kubernetes 虚拟网络的外部访问，必须将 Pod（deployment） 暴露为 Kubernetes <a href="https://kubernetes.io/zh/docs/concepts/services-networking/service/" target="_blank" rel="noopener"><em>Service</em></a>。</p></li><li><p><code>kubectl expose deployment hello-node --type=LoadBalancer --port=8080</code><br>这里的 <code>--type=LoadBalancer</code> 参数表明你希望将你的 Service 暴露到集群外部。<br>应用程序代码仅监听 TCP 8080 端口。</p></li></ul></li></ol><h2><span id="更新应用的过程">更新应用的过程</span></h2><ol><li><p>应用新的 YAML 文件</p><pre class=" language-shell"><code class="language-shell">kubectl apply -f https://k8s.io/examples/application/deployment-scale.yaml</code></pre></li><li><p>验证</p><pre class=" language-shell"><code class="language-shell">kubectl get pods -l app=nginx</code></pre></li></ol><p>包括更新镜像地址，更新副本个数等等</p><h2><span id="有状态负载statefulset和无状态负载deployment的区别">有状态负载（statefulset）和无状态负载（deployment）的区别</span></h2><ul><li>【面向服务不同】deployment面向无状态服务，statefulset管理有状态的服务，比如MySQL、MongoDB集群。</li><li>【实例数量】无状态服务可以有一个或多个实例，因此支持服务容量调节模式；有状态服务只能有一个实例，不允许创建多个实例，因此也不支持服务容量调节模式。</li><li>【存储卷】无状态服务可以有存储卷，也可以没有，即使有也无法备份存储卷里面的数据；有状态服务必须要有存储卷，并且在创建服务时，必须指定给该存储卷分配的磁盘空间大小。</li><li>【数据存储】无状态服务运行过程中的所有数据（除日志和监控数据）都存在容器实例里的文件系统中，如果实例停止或者删除，则这些数据都将丢失，无法找回；而对于有状态服务，凡是已经挂载了存储卷的目录下的文件内容都可以随时进行备份，备份的数据可以下载，也可以用于恢复新的服务。但对于没有挂载卷的目录下的数据，仍然是无法备份和保存的，如果实例停止或者删除，这些非挂载卷里的文件内容同样会丢失。</li></ul><h3><span id="无状态服务">无状态服务</span></h3><p>多个实例对于同一个请求响应的结果是完全一致的，服务运行的实例不会在本地存储需要持久化的数据。这类服务的实例因为一些原因停止或者重新创建（如扩容时）时，这些停止的实例里的所有信息（除日志和监控数据外）都将丢失(重启容器即会丢失)。</p><h3><span id="有状态服务">有状态服务</span></h3><p>该服务的实例可以将一部分数据随时进行备份，并且在创建一个新的有状态服务时，可以通过备份恢复这些数据，以达到数据持久化的目的。</p><h2><span id="为什么需要资源预留">为什么需要资源预留</span></h2><p>资源预留是给非 Pod 类进程预留的。</p><p>按照是否为 Pod，可以把计算节点的进程分为两类：</p><ul><li>Pod 类进程：容器内部的进程，这些容器由 K8S 创建</li><li>非 Pod 类进程：系统进程，如内核，systemd 等；K8S 管理进程，如 Docker, Kubelet 等</li></ul><p>如果没有资源预留，K8S 认为宿主机上所有的资源(RAM, CPU)都是可以分配给 Pod 类进程。但是由于非 Pod 类进程也需要占用一定的资源，当 Pod 创建很多时，就有可能出现资源不足的情况。</p><p>当 Pod 里面内存不足时，会触发 Cgroup 把 Pod 里面的进程杀死；</p><p>当系统内存不足时，就有可能触发系统 OOM，这时候根据 oom score 来确定优先杀死哪个进程，很大概率上OOM的优先级如下<code>best effort pod &gt; 其它进程 &gt; guarantee pod &gt; kubelet/docker等  &gt; sshd 等</code>，从优先级看来，如果节点没有 best effort 类型的 pod，那么其它进程就有可能被 OOM，包括系统进程。</p><p><strong>所以，预留一定的资源给系统和 K8S 管理服务，非常有必要。</strong></p><h2><span id="标签和注解分别有什么用">标签和注解分别有什么用</span></h2><h3><span id="标签">标签</span></h3><p>在微服务架构中，部署的微服务数量容器达到几十个，这些组件可能是副本（部署同一组件的多个副本）和多个不同的发布版本（stable、beta、canary等）同时运行。</p><p>标签可以组织pod和其他K8S对象，这是一种能够基于任意标准将<strong>上述pod组织成更小群体的方式。</strong></p><p>标签是一种简单却功能强大的K8S特性，可以附加到K8S资源的任意键值对。在资源内标签的key需唯一，一个资源可拥有多个标签。</p><p>K8S中的任意API对象都是通过Label进行标识、实质是一系列key/value键值对，其中key与value由用户自己指定。</p><h3><span id="注解">注解</span></h3><p>注解是键值对，类似于标签，主要作用是保存<strong>标识信息</strong>。</p><h3><span id="注解和标签的区别">注解和标签的区别</span></h3><ul><li>标签可以通过标签选择器进行过滤和分组，注解不可以用于对对象分组。</li><li>与标签相比而言，注解包含的数据更多一些。</li></ul><h2><span id="存活检查就绪检查启动检查">存活检查，就绪检查，启动检查</span></h2><blockquote><p>参考：<a href="https://kubernetes.io/zh/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/#define-startup-probes" target="_blank" rel="noopener">https://kubernetes.io/zh/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/#define-startup-probes</a></p></blockquote><h3><span id="三种检查方式">三种检查方式</span></h3><blockquote><p>三类检查的检查方式都相同，以下的yaml以存活探测为例，其他检查的yaml文件也都类似，只是字段不同：存活探测是<code>livenessProbe</code>，启动探测是<code>startupProbe</code>，就绪探测是<code>readinessProbe</code>。</p></blockquote><ul><li><p>执行命令</p><p> kubelet 在容器内执行命令 <code>cat /tmp/healthy</code> 来进行探测。 </p><p>如果命令执行成功并且返回值为 0，kubelet 就会认为这个容器是健康存活的。</p><p>如果这个命令返回非 0 值，kubelet 会杀死这个容器并重新启动它。</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">test</span><span class="token punctuation">:</span> liveness  <span class="token key atrule">name</span><span class="token punctuation">:</span> liveness<span class="token punctuation">-</span>exec<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">containers</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> liveness    <span class="token key atrule">image</span><span class="token punctuation">:</span> k8s.gcr.io/busybox    <span class="token key atrule">args</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> /bin/sh    <span class="token punctuation">-</span> <span class="token punctuation">-</span>c    <span class="token punctuation">-</span> touch /tmp/healthy; sleep 30; rm <span class="token punctuation">-</span>rf /tmp/healthy; sleep 600    <span class="token key atrule">livenessProbe</span><span class="token punctuation">:</span>      <span class="token key atrule">exec</span><span class="token punctuation">:</span>        <span class="token key atrule">command</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 执行命令 cat /tmp/healthy 来进行探测。</span>        <span class="token punctuation">-</span> cat        <span class="token punctuation">-</span> /tmp/healthy      <span class="token key atrule">initialDelaySeconds</span><span class="token punctuation">:</span> <span class="token number">5</span>      <span class="token key atrule">periodSeconds</span><span class="token punctuation">:</span> <span class="token number">5 </span><span class="token comment" spellcheck="true">#  kubelet 应该每 5 秒执行一次存活探测</span></code></pre></li></ul><ul><li><p>发送网络get请求</p><p>如果服务器上 <code>/healthz</code> 路径下的处理程序返回成功代码，则 kubelet 认为容器是健康存活的。</p><p>如果处理程序返回失败代码，则 kubelet 会杀死这个容器并且重新启动它。</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">test</span><span class="token punctuation">:</span> liveness  <span class="token key atrule">name</span><span class="token punctuation">:</span> liveness<span class="token punctuation">-</span>http<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">containers</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> liveness    <span class="token key atrule">image</span><span class="token punctuation">:</span> k8s.gcr.io/liveness    <span class="token key atrule">args</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> /server    <span class="token key atrule">livenessProbe</span><span class="token punctuation">:</span>      <span class="token key atrule">httpGet</span><span class="token punctuation">:</span>        <span class="token key atrule">path</span><span class="token punctuation">:</span> /healthz <span class="token comment" spellcheck="true"># 请求的服务</span>        <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8080</span>        <span class="token key atrule">httpHeaders</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> Custom<span class="token punctuation">-</span>Header          <span class="token key atrule">value</span><span class="token punctuation">:</span> Awesome      <span class="token key atrule">initialDelaySeconds</span><span class="token punctuation">:</span> <span class="token number">3 </span><span class="token comment" spellcheck="true"># kubelet在执行第一次探测前应该等待3秒</span>      <span class="token key atrule">periodSeconds</span><span class="token punctuation">:</span> <span class="token number">3 </span><span class="token comment" spellcheck="true"># kubelet每隔3秒执行一次存活探测</span></code></pre></li></ul><ul><li><p>测试TCP Socket连接</p><p>kubelet 会尝试在指定端口和容器建立套接字链接。 </p><p>如果能建立连接，这个容器就被看作是健康的</p><p>如果不能则这个容器就被看作是有问题的。</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> goproxy  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> goproxy<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">containers</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> goproxy    <span class="token key atrule">image</span><span class="token punctuation">:</span> k8s.gcr.io/goproxy<span class="token punctuation">:</span><span class="token number">0.1</span>    <span class="token key atrule">ports</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">8080</span>    <span class="token key atrule">readinessProbe</span><span class="token punctuation">:</span>      <span class="token key atrule">tcpSocket</span><span class="token punctuation">:</span>        <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8080</span>      <span class="token key atrule">initialDelaySeconds</span><span class="token punctuation">:</span> <span class="token number">5</span>      <span class="token key atrule">periodSeconds</span><span class="token punctuation">:</span> <span class="token number">10</span>    <span class="token key atrule">livenessProbe</span><span class="token punctuation">:</span>      <span class="token key atrule">tcpSocket</span><span class="token punctuation">:</span>        <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8080</span>      <span class="token key atrule">initialDelaySeconds</span><span class="token punctuation">:</span> <span class="token number">15</span>      <span class="token key atrule">periodSeconds</span><span class="token punctuation">:</span> <span class="token number">20</span></code></pre></li></ul><p>对于HTTP 或者 TCP 存活检测可以使用命名的 ContainerPort。</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">ports</span><span class="token punctuation">:</span><span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> liveness<span class="token punctuation">-</span>port  <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">8080</span>  <span class="token key atrule">hostPort</span><span class="token punctuation">:</span> <span class="token number">8080</span><span class="token key atrule">livenessProbe</span><span class="token punctuation">:</span>  <span class="token key atrule">httpGet</span><span class="token punctuation">:</span>    <span class="token key atrule">path</span><span class="token punctuation">:</span> /healthz    <span class="token key atrule">port</span><span class="token punctuation">:</span> liveness<span class="token punctuation">-</span>port</code></pre><hr><h3><span id="启动探测">启动探测</span></h3><p>有时候，会有一些现有的应用程序在启动时需要较多的初始化时间。</p><p>为了避免容器在启动成功之前被存活、就绪探测器影响，使它们在启动运行之前就被杀掉，kubelet 使用<strong>启动探测器</strong>来知道应用程序容器什么时候启动了。</p><p>针对HTTP 或者 TCP 检测，可以通过设置 <code>failureThreshold * periodSeconds</code> 参数来保证有足够长的时间应对糟糕情况下的启动时间。</p><p>一旦启动探测成功一次，<strong>存活探测</strong>任务就会接管对容器的探测，对容器死锁可以快速响应。 如果启动探测一直没有成功，容器会在 300 秒后被杀死，并且根据 <code>restartPolicy</code> 来设置 Pod 状态。</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">ports</span><span class="token punctuation">:</span><span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> liveness<span class="token punctuation">-</span>port  <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">8080</span>  <span class="token key atrule">hostPort</span><span class="token punctuation">:</span> <span class="token number">8080</span><span class="token key atrule">livenessProbe</span><span class="token punctuation">:</span>  <span class="token key atrule">httpGet</span><span class="token punctuation">:</span>    <span class="token key atrule">path</span><span class="token punctuation">:</span> /healthz    <span class="token key atrule">port</span><span class="token punctuation">:</span> liveness<span class="token punctuation">-</span>port  <span class="token key atrule">failureThreshold</span><span class="token punctuation">:</span> <span class="token number">1</span>  <span class="token key atrule">periodSeconds</span><span class="token punctuation">:</span> <span class="token number">10</span><span class="token comment" spellcheck="true"># 应用程序将会有最多 5 分钟(30 * 10 = 300s) 的时间来完成它的启动</span><span class="token key atrule">startupProbe</span><span class="token punctuation">:</span>  <span class="token key atrule">httpGet</span><span class="token punctuation">:</span>    <span class="token key atrule">path</span><span class="token punctuation">:</span> /healthz    <span class="token key atrule">port</span><span class="token punctuation">:</span> liveness<span class="token punctuation">-</span>port  <span class="token key atrule">failureThreshold</span><span class="token punctuation">:</span> <span class="token number">30 </span>  <span class="token key atrule">periodSeconds</span><span class="token punctuation">:</span> <span class="token number">10</span></code></pre><h3><span id="存活探测">存活探测</span></h3><p>kubelet 使用<strong>存活探测器</strong>来知道<strong>什么时候要重启容器</strong>。  </p><p>例如，存活探测器可以捕捉到死锁（应用程序在运行，但是无法继续执行后面的步骤）。</p><p> 这样的情况下重启容器有助于让应用程序在有问题的情况下更可用。</p><h3><span id="就绪探测">就绪探测</span></h3><p>kubelet 使用<strong>就绪探测器</strong>可以知道<strong>容器什么时候准备好了并可以开始接受请求流量</strong>， 当一个 Pod 内的所有容器都准备好了，才能把这个 Pod 看作已经就绪。</p><p>有时候，应用程序会暂时性的不能提供通信服务。 例如，应用程序在启动时可能需要加载很大的数据或配置文件，或是启动后要依赖等待外部服务。 在这种情况下，<strong>既不想杀死应用程序，也不想给它发送请求</strong>。 Kubernetes 提供了就绪探测器来发现并缓解这些情况。 如果容器所在 Pod 上还在报未就绪的信息，<strong>就不接受通过 Kubernetes Service 的流量。</strong></p><p>就绪和存活探测可以在同一个容器上并行使用。 两者都可以确保流量不会发给还没有准备好的容器，并且容器会在它们失败的时候被重新启动。</p><p>就绪探测器的配置和存活探测器的配置相似。 唯一区别就是要使用 <code>readinessProbe</code> 字段，而不是 <code>livenessProbe</code> 字段。</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">readinessProbe</span><span class="token punctuation">:</span>  <span class="token key atrule">exec</span><span class="token punctuation">:</span>    <span class="token key atrule">command</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> cat    <span class="token punctuation">-</span> /tmp/healthy  <span class="token key atrule">initialDelaySeconds</span><span class="token punctuation">:</span> <span class="token number">5</span>  <span class="token key atrule">periodSeconds</span><span class="token punctuation">:</span> <span class="token number">5        </span></code></pre><h2><span id="部署策略">部署策略</span></h2><blockquote><p>参考： <a href="https://kubernetes.io/zh/docs/tasks/configure-pod-container/assign-pods-nodes-using-node-affinity/" target="_blank" rel="noopener">https://kubernetes.io/zh/docs/tasks/configure-pod-container/assign-pods-nodes-using-node-affinity/</a></p></blockquote><p>通常情况下，k8s调度程序会自动合理地将pod分配给节点，比如将Pod分散到节点上，不将Pod放置在可用资源不足的节点上等等。</p><p>但某些情况下，我们需要把Pod分配到特定的节点，而不是让k8s来自动调度，比如确保Pod最终落在连接了SSD的机器上。</p><p>可以通过标签选择器（nodeSelector）来约束pod分配给某个特定的节点。</p><p>通过以下约束过程可以让Pod分配在相应标签附加到的节点上：</p><ol><li><p>将标签粘贴到节点上</p><p><code>kubectl label nodes [节点名称] disktype=ssd</code></p></li><li><p>将nodeSelector字段添加到Pod配置中</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">env</span><span class="token punctuation">:</span> test<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">containers</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx    <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx    <span class="token key atrule">imagePullPolicy</span><span class="token punctuation">:</span> IfNotPresent  <span class="token comment" spellcheck="true"># nodeSelector</span>  <span class="token key atrule">nodeSelector</span><span class="token punctuation">:</span>    <span class="token key atrule">disktype</span><span class="token punctuation">:</span> ssd</code></pre></li></ol><h3><span id="亲和力和反亲和力">亲和力和反亲和力</span></h3><p><code>nodeSelector</code>已经提供了一种非常简单的方法来将pod约束到具有特定标签的节点，向 Node 对象添加标签可以将 pod 定位到特定的节点或节点组。 亲和力和反亲和力则扩展了更多的表达类型，其关键的增强功能为：</p><ol><li>除了通过逻辑AND运算创建的完全匹配之外，该语言还提供了更多匹配规则。</li><li>可以制定规则是”soft”/“preference”而不是硬性要求，因此，如果调度程序无法满足该要求，则仍会调度pod。</li><li>可以限制节点（或其他拓扑域）上运行的其他Pod上的标签，而不仅仅是节点本身上的标签，这允许配置哪些Pod可以和不能共置在一个节点上的规则</li></ol><h4><span id="节点亲和性">节点亲和性</span></h4><p>目前有两种类型的节点亲和性：</p><ol><li>硬需求<code>requiredDuringSchedulingIgnoredDuringExecution</code>，指定了将 Pod 调度到一个节点上 <em>必须</em>满足的规则，类似<code>nodeSelector</code>。</li><li>软需求<code>preferredDuringSchedulingIgnoredDuringExecution</code>，指定调度器将尝试执行但不能保证调度结果和预期一致。</li></ol><p>名称的<code>IgnoredDuringExecution</code>部分意味着即使节点的标签在运行时发生变更，从而不再满足 Pod 上的亲和性规则， Pod 也仍然继续在该节点上运行，类似<code>nodeSelector</code></p><h5><span id="示例">示例</span></h5><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> with<span class="token punctuation">-</span>node<span class="token punctuation">-</span>affinity<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">affinity</span><span class="token punctuation">:</span>    <span class="token key atrule">nodeAffinity</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># Pod 只能放置在具有标签键 kubernetes.io/e2e-az-name 且标签值为 e2e-az1 或 e2e-az2 的节点上</span>      <span class="token key atrule">requiredDuringSchedulingIgnoredDuringExecution</span><span class="token punctuation">:</span>        <span class="token key atrule">nodeSelectorTerms</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">matchExpressions</span><span class="token punctuation">:</span>          <span class="token punctuation">-</span> <span class="token key atrule">key</span><span class="token punctuation">:</span> kubernetes.io/e2e<span class="token punctuation">-</span>az<span class="token punctuation">-</span>name            <span class="token key atrule">operator</span><span class="token punctuation">:</span> In            <span class="token key atrule">values</span><span class="token punctuation">:</span>            <span class="token punctuation">-</span> e2e<span class="token punctuation">-</span>az1            <span class="token punctuation">-</span> e2e<span class="token punctuation">-</span>az2      <span class="token comment" spellcheck="true"># 在满足这些标准的节点中，具有标签键为 another-node-label-key 且标签值为 another-node-label-value 的节点应该优先使用</span>      <span class="token key atrule">preferredDuringSchedulingIgnoredDuringExecution</span><span class="token punctuation">:</span>      <span class="token comment" spellcheck="true"># weight 字段值的范围是 1-100</span>      <span class="token comment" spellcheck="true"># 对于每个符合所有调度要求的节点，调度器将遍历该字段的元素来计算总和，并且如果节点匹配对应的 MatchExpressions，则添加“权重”到总和，并且将这个评分与该节点的其他优先级函数的评分进行组合。 </span>      <span class="token comment" spellcheck="true"># 总分最高的节点是最优选的。</span>      <span class="token punctuation">-</span> <span class="token key atrule">weight</span><span class="token punctuation">:</span> <span class="token number">1</span>        <span class="token key atrule">preference</span><span class="token punctuation">:</span>          <span class="token key atrule">matchExpressions</span><span class="token punctuation">:</span>          <span class="token punctuation">-</span> <span class="token key atrule">key</span><span class="token punctuation">:</span> another<span class="token punctuation">-</span>node<span class="token punctuation">-</span>label<span class="token punctuation">-</span>key            <span class="token key atrule">operator</span><span class="token punctuation">:</span> In            <span class="token key atrule">values</span><span class="token punctuation">:</span>            <span class="token punctuation">-</span> another<span class="token punctuation">-</span>node<span class="token punctuation">-</span>label<span class="token punctuation">-</span>value  <span class="token key atrule">containers</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> with<span class="token punctuation">-</span>node<span class="token punctuation">-</span>affinity    <span class="token key atrule">image</span><span class="token punctuation">:</span> k8s.gcr.io/pause<span class="token punctuation">:</span><span class="token number">2.0</span></code></pre><h6><span id="注意事项">注意事项：</span></h6><ol><li>如果同时指定了 <code>nodeSelector</code> 和 <code>nodeAffinity</code>，<em>两者</em>必须都要满足， 才能将 Pod 调度到候选节点上。</li><li>如果指定了多个与 <code>nodeAffinity</code> 类型关联的 <code>nodeSelectorTerms</code>，则 <strong>如果其中一个</strong> <code>nodeSelectorTerms</code> 满足的话，pod将可以调度到节点上。</li><li>如果指定了多个与 <code>nodeSelectorTerms</code> 关联的 <code>matchExpressions</code>，则 <strong>只有当所有</strong> <code>matchExpressions</code> 满足的话，Pod 才会可以调度到节点上。</li><li>如果修改或删除了 pod 所调度到的节点的标签，Pod 不会被删除。 换句话说，亲和性选择只在 Pod 调度期间有效。</li></ol><h4><span id="容器组亲和性和反亲和性">容器组亲和性和反亲和性</span></h4><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> with<span class="token punctuation">-</span>pod<span class="token punctuation">-</span>affinity<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">affinity</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 仅当节点和至少一个已运行且有键为“security”且值为“S1”的标签 的 Pod 处于同一区域时，才可以将该 Pod 调度到节点上。</span>    <span class="token key atrule">podAffinity</span><span class="token punctuation">:</span>      <span class="token key atrule">requiredDuringSchedulingIgnoredDuringExecution</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">labelSelector</span><span class="token punctuation">:</span>          <span class="token key atrule">matchExpressions</span><span class="token punctuation">:</span>          <span class="token punctuation">-</span> <span class="token key atrule">key</span><span class="token punctuation">:</span> security            <span class="token key atrule">operator</span><span class="token punctuation">:</span> In            <span class="token key atrule">values</span><span class="token punctuation">:</span>            <span class="token punctuation">-</span> S1        <span class="token key atrule">topologyKey</span><span class="token punctuation">:</span> topology.kubernetes.io/zone     <span class="token comment" spellcheck="true"># 当节点和具有键 “security”和值“S2”的标签的 Pod 处于相同的区域，Pod 不能被调度到该节点上</span>    <span class="token key atrule">podAntiAffinity</span><span class="token punctuation">:</span>      <span class="token key atrule">preferredDuringSchedulingIgnoredDuringExecution</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">weight</span><span class="token punctuation">:</span> <span class="token number">100</span>        <span class="token key atrule">podAffinityTerm</span><span class="token punctuation">:</span>          <span class="token key atrule">labelSelector</span><span class="token punctuation">:</span>            <span class="token key atrule">matchExpressions</span><span class="token punctuation">:</span>            <span class="token punctuation">-</span> <span class="token key atrule">key</span><span class="token punctuation">:</span> security              <span class="token key atrule">operator</span><span class="token punctuation">:</span> In              <span class="token key atrule">values</span><span class="token punctuation">:</span>              <span class="token punctuation">-</span> S2          <span class="token key atrule">topologyKey</span><span class="token punctuation">:</span> topology.kubernetes.io/zone  <span class="token key atrule">containers</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> with<span class="token punctuation">-</span>pod<span class="token punctuation">-</span>affinity    <span class="token key atrule">image</span><span class="token punctuation">:</span> k8s.gcr.io/pause<span class="token punctuation">:</span><span class="token number">2.0</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 云原生相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对于endpoint（端点）的理解</title>
      <link href="2021/03/02/%E5%AF%B9%E4%BA%8EEndPoint%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>2021/03/02/%E5%AF%B9%E4%BA%8EEndPoint%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2><span id="对于endpoint端点的理解">对于endpoint（端点）的理解</span></h2><blockquote><p>参考文章：<a href="https://www.jianshu.com/p/808917d76b51" target="_blank" rel="noopener">https://www.jianshu.com/p/808917d76b51</a></p></blockquote><p>flask框架的程序理念是把URL地址映射到相应的业务逻辑上。</p><p>其中，映射过程并非直接为URL–&gt;viewfunction，而是URL–&gt;endpoint–&gt;viewfunction。</p><h3><span id="endpoint的存在意义">endpoint的存在意义</span></h3><p><strong>endpoint一般用作反向查询URL地址（viewfunction–&gt;endpoint–&gt;URL）。这样就可以让URL与视图间的关联代码进行解耦，比如：在两个视图通过<code>url_for()</code>进行相关联的时候，可以任意改变视图的URL，只要端点不变，就不需要改动关联代码。</strong></p><h4><span id="endpoint在蓝图中的应用">endpoint在蓝图中的应用</span></h4><p>除了解耦作用，endpoint在蓝图中还有更妙的用处：<strong>通过端点实现对命名空间的支持</strong></p><p>main.py</p><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> flask <span class="token keyword">import</span> Flask<span class="token punctuation">,</span> Blueprint<span class="token keyword">from</span> admin <span class="token keyword">import</span> admin<span class="token keyword">from</span> user <span class="token keyword">import</span> userapp <span class="token operator">=</span> Flask<span class="token punctuation">(</span>__name__<span class="token punctuation">)</span>app<span class="token punctuation">.</span>register_blueprint<span class="token punctuation">(</span>admin<span class="token punctuation">,</span> url_prefix<span class="token operator">=</span><span class="token string">'admin'</span><span class="token punctuation">)</span>app<span class="token punctuation">.</span>register_blueprint<span class="token punctuation">(</span>user<span class="token punctuation">,</span> url_prefix<span class="token operator">=</span><span class="token string">'user'</span><span class="token punctuation">)</span></code></pre><p>admin.py</p><pre class=" language-python"><code class="language-python">admin <span class="token operator">=</span> Blueprint<span class="token punctuation">(</span><span class="token string">'admin'</span><span class="token punctuation">,</span> __name__<span class="token punctuation">)</span>@admin<span class="token punctuation">.</span>route<span class="token punctuation">(</span><span class="token string">'/greeting'</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">greeting</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> <span class="token string">'Hello, administrative user!'</span></code></pre><p>user.py</p><pre class=" language-python"><code class="language-python">user <span class="token operator">=</span> Blueprint<span class="token punctuation">(</span><span class="token string">'user'</span><span class="token punctuation">,</span> __name__<span class="token punctuation">)</span>@user<span class="token punctuation">.</span>route<span class="token punctuation">(</span><span class="token string">'/greeting'</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">greeting</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> <span class="token string">'Hello, lowly normal user!'</span></code></pre><p>user.py</p><pre class=" language-python"><code class="language-python">user <span class="token operator">=</span> Blueprint<span class="token punctuation">(</span><span class="token string">'user'</span><span class="token punctuation">,</span> __name__<span class="token punctuation">)</span>@user<span class="token punctuation">.</span>route<span class="token punctuation">(</span><span class="token string">'/greeting'</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">greeting</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> <span class="token string">'Hello, lowly normal user!'</span></code></pre><p>打印url，可以发现虽然不同蓝图下的url相同，但是端点是不同的，也就是说不同的蓝图，他们的命名空间是相互隔离的。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">print</span> url_for<span class="token punctuation">(</span><span class="token string">'admin.greeting'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># Prints '/admin/greeting'</span><span class="token keyword">print</span> url_for<span class="token punctuation">(</span><span class="token string">'user.greeting'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># Prints '/user/greeting'</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> flask </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bisect&amp;pop,remove,del的区别&amp;双指针使用场景</title>
      <link href="2021/02/03/bisect%E5%92%8Cpop-remove-del%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E5%8F%8C%E6%8C%87%E9%92%88/"/>
      <url>2021/02/03/bisect%E5%92%8Cpop-remove-del%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E5%8F%8C%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<p>这篇文章有三个知识点：</p><ul><li>python的二分查找库bisect</li><li>pop,remove,del的区别</li><li>双指针使用场景的简单说明</li></ul><h2><span id="bisect">bisect</span></h2><p>bisect是一种数组二分查找算法库，返回合适的插入位置索引。</p><blockquote><p>参考：<a href="https://docs.python.org/zh-cn/3.6/library/bisect.html" target="_blank" rel="noopener">https://docs.python.org/zh-cn/3.6/library/bisect.html</a></p></blockquote><h3><span id="用途">用途</span></h3><ul><li>对有序列表提供支持，辅助进行查找，插入，排序。</li></ul><h3><span id="常用函数搜索与插入">常用函数【搜索与插入】</span></h3><blockquote><p>要注意搜索是 O(log n) 的，插入却是 O(n) 的（<em>数组的插入</em>）</p></blockquote><h4><span id="搜索">搜索</span></h4><p>在 a 中找到数字 x 合适的插入点以维持有序,当不存在和x相同的数时，下面两个方法返回的结果相同：</p><ol><li><p><code>bisect.bisect_left(a, x, lo=0, hi=len(a))</code><br> 返回的插入点 i 可以将数组 a 分成两部分。左侧是 all(val &lt; x for val in a[lo:i]) ，右侧是 all(val &gt;= x for val in a[i:hi])<br> <strong>在存在多个和x相等的数时，a[i]是第一个和x相等的数</strong></p></li><li><p><code>bisect.bisect_right(a, x, lo=0, hi=len(a))</code><br><strong>在存在多个和x相等的数时，a[i]是第一个不和x相等的数，左侧是小于等于x的数</strong></p></li></ol><pre><code>    a=[1,2,2,3,4]    print(bisect.bisect_left(a, 2)) # 1    print(bisect.bisect_right(a, 2))# 3</code></pre><h4><span id="插入">插入</span></h4><p>将 x 插入到一个<strong>有序</strong>序列 a 里，并维持其有序：</p><ol><li><p><code>bisect.insort_left(a, x, lo=0, hi=len(a))</code><br>相当于 a.insert(bisect.bisect_left(a, x, lo, hi), x)。  </p></li><li><p><code>bisect.insort_right(a, x, lo=0, hi=len(a))</code><br>相当于 a.insert(bisect.bisect_right(a, x, lo, hi), x)。  </p></li></ol><h2><span id="popremovedel的区别">pop,remove,del的区别</span></h2><p>在使用目的上都是为了从一个列表中移除元素</p><table><thead><tr><th>不同点</th><th>使用结果</th><th>返回数据</th><th>异常</th></tr></thead><tbody><tr><td>remove</td><td>移除第一个相同的元素</td><td>不返回数据</td><td><code>ValueError: list.remove(x): x not in list</code></td></tr><tr><td>del</td><td>按照索引移除元素</td><td>不返回数据</td><td><code>IndexError: list assignment index out of range</code></td></tr><tr><td>pop</td><td>按照索引移除元素</td><td>返回被移除的元素</td><td><code>IndexError: pop index out of range</code></td></tr></tbody></table><h2><span id="双指针使用场景的简单说明">双指针使用场景的简单说明</span></h2><ol><li>从两端向中间迭代数组：一个指针从头部开始，另一个指针从尾部开始。【如反转】</li><li>同时有一个快指针和一个慢指针：确定两个指针的移动策略。【如原地移除一个列表中所有等于val的元素】</li></ol>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> package </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python基础</title>
      <link href="2021/01/17/python%E5%9F%BA%E7%A1%80-%E4%B8%80/"/>
      <url>2021/01/17/python%E5%9F%BA%E7%A1%80-%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这篇文章主要的内容是不同语言的比较，python基本数据类型，socket相关，线程与进程，高阶函数：迭代器，生成器，装饰器</p></blockquote><h2><span id="python和java的区别">python和java的区别</span></h2><ol><li>JAVA编译以后才能运行，python直接就可以运行；</li><li>JAVA是混合型语言，python是解释型语言。JAVA可以是解释型的，因为java代码编译后不能直接运行，它是解释运行在JVM上的；但是现在的JVM为了效率，都有一些JIT优化，它又会把.class的二进制代码编译为本地的代码直接运行。</li><li>JAVA 的类型要声明，Python 的类型不需要。</li><li>JAVA 中的字符串以双引号括起来，Python 中单引号或双引号都可以</li><li>python是弱类型语言，java是强类型。</li><li>Python是函数为一等公民的语言,而Java是类为一等公民的语言</li></ol><h3><span id="python和java都是面向对象的">python和java都是面向对象的</span></h3><h4><span id="定义">定义</span></h4><ul><li><p>编译型语言：把做好的源程序全部编译成二进制代码的可运行程序。然后，可直接运行这个程序。 </p></li><li><p>解释型语言：把做好的源程序翻译一句，然后执行一句，直至结束！ </p></li></ul><h4><span id="区别">区别</span></h4><ul><li><p>编译型语言，执行速度快、效率高；依靠编译器、跨平台性差些。 </p></li><li><p>解释型语言，执行速度慢、效率低；依靠解释器、跨平台性好。 </p></li></ul><h3><span id="为什么python比较慢">为什么python比较慢</span></h3><p>Python的缓慢主要是由于它动态的特点。每次读取、写入变量或引用变量类型时都会进行检查，比较和转换类型是耗时的。<br>另外，在具有多个cpu的机器上使用多线程时，python都会比较慢。这是由于python中GIL的存在，python的多线程是伪多线程，他在同一时刻只能运行一个线程，但其他语言比如说java，就可以在多个核上同时运行多个线程。</p><h2><span id="基本数据类型">基本数据类型</span></h2><ol><li>不可变：frozenset不可变集合，数值（整数，浮点数，复数，bool），字符串，元组</li><li>可变：字典，列表，集合set</li></ol><h2><span id="socket相关">socket相关</span></h2><h3><span id="socket">socket</span></h3><blockquote><p>Socket 是一种网络间不同计算机上的进程通信的一种方法</p></blockquote><h4><span id="pythonampsocket">python&amp;socket</span></h4><pre><code>import socket               # 导入 socket 模块s = socket.socket()         # 创建 socket 对象host = socket.gethostname() # 获取本地主机名port = 12345                # 设置端口s.bind((host, port))        # 绑定端口s.listen(5)                 # 等待客户端连接while True:c,addr = s.accept()     # 建立客户端连接print &#39;连接地址：&#39;, addrc.send(&#39;欢迎访问菜鸟教程！&#39;)c.close()                # 关闭连接</code></pre><h3><span id="web-socket">web socket</span></h3><blockquote><p>WebSocket 是一种在单个 TCP 连接上进行全双工通信的协议。</p></blockquote><h4><span id="socket和web-socket的区别">socket和web socket的区别</span></h4><ol><li>Socket 是传输控制层的接口。用户可以通过 Socket 来操作底层 TCP/IP 协议族通信。</li><li>WebSocket 是一个完整应用层协议。</li><li>Socket 更灵活，WebSocket 更易用。</li><li>两者都能做即时通讯</li></ol><h4><span id="为什么有了-http-还需要-websocket">为什么有了 HTTP 还需要 WebSocket？</span></h4><p>http通信协议不是双工的，只能客户端先发送请求，服务器响应请求。如果有需要服务端主动通知的业务，就需要轮询（客户端定时向服务端发送请求）。轮询的效率低，非常浪费资源。为了解决 Web 端即时通讯的需求就出现了 WebSocket。</p><h2><span id="装饰器">装饰器</span></h2><p>本质上，decorator就是一个返回函数的高阶函数。装饰器本质上是一个Python函数，它可以让其他函数在不需要做任何代码变动的前提下增加额外功能，装饰器的返回值也是一个函数对象。可以进行插入日志、性能测试、权限校验这些操作。</p><h2><span id="迭代器和生成器的区别">迭代器和生成器的区别</span></h2><h3><span id="在python的实现中">在python的实现中：</span></h3><ul><li>实现了<code>__iter__</code>方法和<code>__next__</code>方法的类对象，就是迭代器</li><li>使用yield语句返回结果就是生成器</li></ul><h3><span id="定义">定义</span></h3><h4><span id="迭代器">迭代器</span></h4><blockquote><p><strong>迭代器是用来帮助我们记录每次迭代访问到的位置，当我们对迭代器使用next()函数的时候，迭代器会向我们返回它所记录位置的下一个位置的数据</strong>。<br>iter()函数会返回一个定义了next()方法的迭代器对象，它在容器中逐个访问容器内的元素。<br>next()也是python内置函数。在没有后续元素时，next()会抛出一个StopIteration异常，通知for语句循环结束。</p></blockquote><pre><code>class Fib(object):    def __init__(self, max):        self.max = max    def __iter__(self):        self.a = 0        self.b = 1        return self    def __next__(self):        fib = self.b        if fib &gt; self.max:            raise StopIteration        self.a, self.b = self.b, self.a + self.b        return fib# 定义一个main函数，循环遍历每一个菲波那切数def main():    # 20以内的数    fib = Fib(20)    for i in fib:        print(i)</code></pre><h4><span id="生成器">生成器</span></h4><blockquote><p><strong>延迟操作。也就是在需要的时候才产生结果，不是立即产生结果。</strong>.<br><em>区别</em>：生成器是只能遍历一次的。<br><em>联系</em>：生成器是一类特殊的迭代器。</p></blockquote><pre><code>def Fib(max):    a, b = 0, 1    for _ in range (max):        yield b        a, b = b, a + b    return </code></pre><h2><span id="变量打印">变量打印</span></h2><h3><span id="方法1">方法1</span></h3><p>直接print(变量名)</p><h3><span id="方法2">方法2</span></h3><p>运用%：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">print</span> <span class="token punctuation">(</span><span class="token string">"%s %s "</span> <span class="token operator">%</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#两个变量要加（）</span></code></pre><p>说明：</p><p>(1) %字符：标记转换说明符的开始</p><p>(2) 转换标志：-表示左对齐；+表示在转换值之前要加上正负号；“”（空白字符）表示正数之前保留空格；0表示转换值若位数不够则用0填充</p><p>(3) 最小字段宽度：转换后的字符串至少应该具有该值指定的宽度。如果是*，则宽度会从值元组中读出。</p><p>(4) 点(.)后跟精度值：如果转换的是实数，精度值就表示出现在小数点后的位数。如果转换的是字符串，那么该数字就表示最大字段宽度。如果是*，那么精度将从元组中读出</p><h4><span id="字符串格式化转换类型">字符串格式化转换类型</span></h4><table><thead><tr><th>转换类型</th><th>含义</th></tr></thead><tbody><tr><td>d,i</td><td>带符号的十进制整数</td></tr><tr><td>o</td><td>不带符号的八进制</td></tr><tr><td>u</td><td>不带符号的十进制</td></tr><tr><td>x</td><td>不带符号的十六进制（小写）</td></tr><tr><td>X</td><td>不带符号的十六进制（大写）</td></tr><tr><td>e</td><td>科学计数法表示的浮点数（小写）</td></tr><tr><td>E</td><td>科学计数法表示的浮点数（大写）</td></tr><tr><td>f,F</td><td>十进制浮点数</td></tr><tr><td>g</td><td>如果指数大于-4或者小于精度值则和e相同，其他情况和f相同</td></tr><tr><td>G</td><td>如果指数大于-4或者小于精度值则和E相同，其他情况和F相同</td></tr><tr><td>C</td><td>单字符（接受整数或者单字符字符串）</td></tr><tr><td>r</td><td>字符串（使用repr转换任意python对象)</td></tr><tr><td>s</td><td>字符串（使用str转换任意python对象）</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷题一周总结 2020.12.20</title>
      <link href="2020/12/20/%E5%88%B7%E9%A2%98%E4%B8%80%E5%91%A8%E6%80%BB%E7%BB%93-2020-12-20/"/>
      <url>2020/12/20/%E5%88%B7%E9%A2%98%E4%B8%80%E5%91%A8%E6%80%BB%E7%BB%93-2020-12-20/</url>
      
        <content type="html"><![CDATA[<h2><span id="递归与回溯对比">递归与回溯对比</span></h2><blockquote><p>来自拉勾《300分钟搞定数据结构与算法》之递归与回溯</p></blockquote><table><thead><tr><th style="text-align:center">顺序</th><th style="text-align:center">回溯</th><th style="text-align:center">递归</th></tr></thead><tbody><tr><td style="text-align:center">第一步</td><td style="text-align:center">判断当前情况是否非法，如果非法就立即返回</td><td style="text-align:center">判断输入或者状态是否非法，如果非法就报错</td></tr><tr><td style="text-align:center">第二步</td><td style="text-align:center">当前情况是否已经满足递归结束条件，如果是就将当前结果保存起来并返回</td><td style="text-align:center">判断是否满足结束递归的条件。在这一步当中，处理的基本上都是一些推导过程当中所定义的初始情况</td></tr><tr><td style="text-align:center">第三步</td><td style="text-align:center">当前情况下，遍历所有可能出现的情况并进行下一步的尝试</td><td style="text-align:center">将问题的规模缩小，递归调用。在归并排序和快速排序中，我们将问题的规模缩小了一半，而在汉诺塔和解码的例子中，我们将问题的规模缩小了一个</td></tr><tr><td style="text-align:center">第四步</td><td style="text-align:center">递归完毕后，立即回溯，回溯的方法就是取消前一步进行的尝试</td><td style="text-align:center">利用在小规模问题中的答案，结合当前的数据进行整合，得出最终的答案</td></tr></tbody></table><h2><span id="题目归类">题目归类</span></h2><h3><span id="构建最大最小字符串数字">构建最大（最小）字符串（数字）</span></h3><p><a href="https://leetcode-cn.com/problems/create-maximum-number/" target="_blank" rel="noopener">拼接最大数</a><br><a href="https://leetcode-cn.com/problems/remove-duplicate-letters/" target="_blank" rel="noopener">去除重复字母</a><br><a href="https://leetcode-cn.com/problems/remove-k-digits/" target="_blank" rel="noopener">移掉K位数字</a></p><h4><span id="核心思想">核心思想</span></h4><ol><li><p>都使用单调递增栈来进行操作并保存最后答案</p></li><li><p>去掉一个数字后,低位会替代高位。</p><ol><li>返回247去掉一个数字后最大的数</li><li>答案为47，思路为去掉遇到的第一个a[i-1] &lt; a[i]的数，如果遍历完数组还没遇到就去掉最后一个数<pre class=" language-python"><code class="language-python"><span class="token keyword">if</span> a<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>             <span class="token keyword">del</span> a<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true"># del速度比pop快</span></code></pre></li></ol></li><li><p>判断什么时候出栈入栈很重要</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 出栈</span><span class="token keyword">while</span> stack <span class="token operator">and</span> ord<span class="token punctuation">(</span>stack<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">></span> ord<span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token operator">and</span> k<span class="token punctuation">:</span></code></pre></li><li><p>一般时间复杂度和空间复杂度都为O(N)，所有字符最多各进栈出栈一次，空间复杂度为单调递增栈</p></li></ol><h4><span id="题解参考">题解参考</span></h4><p><a href="https://leetcode-cn.com/problems/remove-k-digits/solution/yi-zhao-chi-bian-li-kou-si-dao-ti-ma-ma-zai-ye-b-5/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/remove-k-digits/solution/yi-zhao-chi-bian-li-kou-si-dao-ti-ma-ma-zai-ye-b-5/</a></p><hr><h3><span id="队列">队列</span></h3><p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">二叉树的层序遍历</a></p><h4><span id="核心思想">核心思想</span></h4><ol><li>用队列，先入先出</li><li>如何分层次：<ol><li>用null来做标记，遇到null时说明一层已遍历完，在队列尾部加上null并cnt+1</li><li>一口气把当前层次（队列当前的长度）全都遍历完毕，一边遍历一边把下一层的节点入栈，当前层次遍历完后再进入下一层的全部遍历。</li></ol></li><li>结束的标志：栈为空</li></ol><hr><h3><span id="栈">栈</span></h3><p><a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="noopener">有效的括号</a></p><ul><li>简单题</li><li>要注意判断最后是否有效的条件：<ul><li>遍历时左右括号不能对应/栈为空就返回False</li><li><strong>最后的栈是否为空</strong></li></ul></li></ul><hr><h3><span id="动态规划贪心">动态规划/贪心</span></h3><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">买卖股票的最佳时机</a></p><ul><li><p>能买卖1次，贪心</p></li><li><p>假设前面已经在最低点购买了股票，判断卖出的时机是否为最高点</p></li><li><p>转移方程为</p><pre class=" language-python"><code class="language-python"><span class="token keyword">if</span> <span class="token punctuation">(</span>prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> minprice<span class="token punctuation">)</span><span class="token punctuation">:</span>    minprice <span class="token operator">=</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">#更新买入的最低点，确保在前面的最低点购买了股票</span><span class="token keyword">elif</span> <span class="token punctuation">(</span>prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> minprice <span class="token operator">></span> maxprofit<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true"># 判断卖出的时机是否为最高点</span>    maxprofit <span class="token operator">=</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> minprice<span class="token punctuation">;</span></code></pre></li></ul><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/" target="_blank" rel="noopener">买卖股票的最佳时机含手续费</a></p><ul><li><p>能买卖n次，可以dp也可以贪心</p></li><li><p>贪心即：<strong>当我们卖出一支股票时，我们就立即获得了以相同价格并且免除手续费买入一支股票的权利</strong></p></li></ul><pre class=" language-python"><code class="language-python">  n <span class="token operator">=</span> len<span class="token punctuation">(</span>prices<span class="token punctuation">)</span>  buy <span class="token operator">=</span> prices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> fee  profit <span class="token operator">=</span> <span class="token number">0</span>  <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> fee <span class="token operator">&lt;</span> buy<span class="token punctuation">:</span>      buy <span class="token operator">=</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> fee      <span class="token keyword">elif</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> buy<span class="token punctuation">:</span>        profit <span class="token operator">+=</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> buy        buy <span class="token operator">=</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        <span class="token keyword">return</span> profit</code></pre><ul><li><p>Dp，需要考虑当前手上持有股票（现在买入，之前就买入），不持有股票两种状态（现在卖出，之前就不持有）。</p></li><li><p>转移方程：<code>dp[i][0]=max{dp[i−1][0],dp[i−1][1]+prices[i]−fee}</code></p><pre class=" language-python"><code class="language-python">dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span>prices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>prices<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        a1 <span class="token operator">=</span> <span class="token number">0</span>        a2 <span class="token operator">=</span> <span class="token operator">-</span>prices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> index <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>prices<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># 转移方程，a1为当前手上不持有股票的最大利润，a2为当前手上持有股票的最大利润</span>            a1<span class="token punctuation">,</span>a2 <span class="token operator">=</span> max<span class="token punctuation">(</span>a1<span class="token punctuation">,</span>a2<span class="token operator">+</span>prices<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token operator">-</span>fee<span class="token punctuation">)</span><span class="token punctuation">,</span>max<span class="token punctuation">(</span>a1<span class="token operator">-</span>prices<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">,</span>a2<span class="token punctuation">)</span>        <span class="token keyword">return</span> a1</code></pre></li></ul><p><a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">最大子序和</a></p><ul><li><p>和贪婪差不多，子序必须是连续的，如果前面的序列为负数，则去掉。</p></li><li><p>动态转移方程为：</p><pre class=" language-python"><code class="language-python">pre <span class="token operator">=</span> max<span class="token punctuation">(</span>pre <span class="token operator">+</span> x<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true"># 动态转移方程</span>maxAns <span class="token operator">=</span> max<span class="token punctuation">(</span>maxAns<span class="token punctuation">,</span> pre<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true"># 用来保存最后结果，特别是当序列全为负数时，保存的是最大的数</span></code></pre></li></ul><hr><h3><span id="数学题">数学题</span></h3><blockquote><p>要找到数学公式</p></blockquote><p><a href="https://leetcode-cn.com/problems/rotate-image/" target="_blank" rel="noopener"> 旋转图像</a></p><ol><li><p>方法1:找公式</p><ol><li>matrix[row] [col]<br>matrix[col] [n−row−1]<br>matrix[n−row−1] [n−col−1]<br>matrix[n−col−1] [row]</li></ol></li><li><p>方法2: 利用翻转的特性（旋转=先水平翻转再沿着斜线翻转）</p><ol><li>拆解一次旋转的步骤<br>matrix[row] [col] = matrix[col] [n−row−1]<br>-&gt; matrix[n−row−1] [col]<br>-&gt; matrix[col] [n−row−1]</li></ol></li><li>水平翻转的特性：<br>   [x,y] = [n-x-1,y]<br>   沿着对角线翻转的特性：<br>   [x,y] = [y,x]<br>   垂直翻转的特性：<br>   [x,y]=[x,n-y-1]</li></ol><p><a href="https://leetcode-cn.com/problems/monotone-increasing-digits/" target="_blank" rel="noopener">单调递增的数字</a></p><ul><li>找到最大数字的规律：低位变9，高位-1</li><li>关键位置是非递增的位置</li></ul><hr><h3><span id="双指针">双指针</span></h3><p><a href="https://leetcode-cn.com/problems/valid-palindrome/" target="_blank" rel="noopener">验证回文串</a></p><ul><li>退出循环条件不是边界值（-1或len），而是双指针相遇</li></ul><hr><h3><span id="小技巧异或计数求和数据结构的应用">小技巧（异或，计数，求和，数据结构的应用）</span></h3><p><a href="https://leetcode-cn.com/problems/find-the-difference/" target="_blank" rel="noopener">找不同</a></p><p><a href="https://leetcode-cn.com/problems/merge-sorted-array/" target="_blank" rel="noopener">合并两个有序数组</a></p><p><a href="https://leetcode-cn.com/problems/monotone-increasing-digits/" target="_blank" rel="noopener">单调递增的数字</a></p><ul><li>累加法 1..11..111..1111..11111…11111</li></ul><p><a href="https://leetcode-cn.com/problems/group-anagrams/" target="_blank" rel="noopener">字母异位词分组</a></p><p><a href="https://leetcode-cn.com/problems/contains-duplicate/" target="_blank" rel="noopener">存在重复元素</a></p><p><a href="https://leetcode-cn.com/problems/word-pattern/" target="_blank" rel="noopener">单词规律</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
            <tag> 递归 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序&amp;异或</title>
      <link href="2020/12/13/%E6%8E%92%E5%BA%8F&amp;%E5%BC%82%E6%88%96/"/>
      <url>2020/12/13/%E6%8E%92%E5%BA%8F&amp;%E5%BC%82%E6%88%96/</url>
      
        <content type="html"><![CDATA[<blockquote><p>今天练习了各种排序，总结了可以用异或解决的题目特征</p></blockquote><h3><span id="leetcode排序">leetcode(排序）:</span></h3><p><a href="https://leetcode-cn.com/problems/sort-an-array/submissions/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sort-an-array/submissions/</a></p><h5><span id="桶排序">桶排序</span></h5><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">sortArray</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> nums <span class="token operator">or</span> len<span class="token punctuation">(</span>set<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token punctuation">:</span>            <span class="token keyword">return</span> nums        max_num <span class="token operator">=</span> max<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        min_num <span class="token operator">=</span> min<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        bucket_num <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># init bucket</span>        bucket_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>bucket_num<span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token comment" spellcheck="true"># select</span>        <span class="token keyword">for</span> num <span class="token keyword">in</span> nums<span class="token punctuation">:</span>            bucket_list<span class="token punctuation">[</span>int<span class="token punctuation">(</span><span class="token punctuation">(</span>num<span class="token operator">-</span>min_num<span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token punctuation">(</span>max_num<span class="token operator">-</span>min_num<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>num<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># sort</span>        result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> bucket <span class="token keyword">in</span> bucket_list<span class="token punctuation">:</span>            <span class="token keyword">if</span> bucket<span class="token punctuation">:</span>                bucket<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> bucket <span class="token keyword">in</span>  bucket_list<span class="token punctuation">:</span>            <span class="token keyword">for</span> num <span class="token keyword">in</span> bucket<span class="token punctuation">:</span>                result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>num<span class="token punctuation">)</span>        <span class="token keyword">return</span> result</code></pre><h4><span id="快速排序">快速排序</span></h4><h5><span id="双边循环法">双边循环法</span></h5><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">quick_sort</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>nums<span class="token punctuation">,</span>start<span class="token punctuation">,</span>end<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> start <span class="token operator">>=</span> end<span class="token punctuation">:</span>            <span class="token keyword">return</span>        mid <span class="token operator">=</span> self<span class="token punctuation">.</span>sort<span class="token punctuation">(</span>nums<span class="token punctuation">,</span>start<span class="token punctuation">,</span>end<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>quick_sort<span class="token punctuation">(</span>nums<span class="token punctuation">,</span>start<span class="token punctuation">,</span>mid<span class="token number">-1</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>quick_sort<span class="token punctuation">(</span>nums<span class="token punctuation">,</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>end<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">sort</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>nums<span class="token punctuation">,</span>start<span class="token punctuation">,</span>end<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> start <span class="token operator">>=</span> end<span class="token punctuation">:</span>            <span class="token keyword">return</span>        mark <span class="token operator">=</span> start        <span class="token keyword">while</span> start <span class="token operator">&lt;</span> end<span class="token punctuation">:</span>            <span class="token keyword">while</span> nums<span class="token punctuation">[</span>end<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>mark<span class="token punctuation">]</span> <span class="token operator">and</span> start <span class="token operator">&lt;</span> end<span class="token punctuation">:</span>                end <span class="token operator">-=</span> <span class="token number">1</span>            <span class="token keyword">while</span> nums<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> nums<span class="token punctuation">[</span>mark<span class="token punctuation">]</span> <span class="token operator">and</span> start <span class="token operator">&lt;</span> end<span class="token punctuation">:</span>                start <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">if</span> start <span class="token operator">&lt;</span> end<span class="token punctuation">:</span>                nums<span class="token punctuation">[</span>end<span class="token punctuation">]</span> <span class="token operator">^</span><span class="token operator">=</span> nums<span class="token punctuation">[</span>start<span class="token punctuation">]</span>                nums<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">^</span><span class="token operator">=</span> nums<span class="token punctuation">[</span>end<span class="token punctuation">]</span>                nums<span class="token punctuation">[</span>end<span class="token punctuation">]</span> <span class="token operator">^</span><span class="token operator">=</span> nums<span class="token punctuation">[</span>start<span class="token punctuation">]</span>        <span class="token keyword">if</span> nums<span class="token punctuation">[</span>mark<span class="token punctuation">]</span> <span class="token operator">!=</span> nums<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">:</span>            nums<span class="token punctuation">[</span>mark<span class="token punctuation">]</span> <span class="token operator">^</span><span class="token operator">=</span> nums<span class="token punctuation">[</span>end<span class="token punctuation">]</span>            nums<span class="token punctuation">[</span>end<span class="token punctuation">]</span> <span class="token operator">^</span><span class="token operator">=</span> nums<span class="token punctuation">[</span>mark<span class="token punctuation">]</span>            nums<span class="token punctuation">[</span>mark<span class="token punctuation">]</span> <span class="token operator">^</span><span class="token operator">=</span> nums<span class="token punctuation">[</span>end<span class="token punctuation">]</span>        <span class="token keyword">return</span> end    <span class="token keyword">def</span> <span class="token function">sortArray</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 快排</span>        self<span class="token punctuation">.</span>quick_sort<span class="token punctuation">(</span>nums<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> nums</code></pre><h5><span id="单边循环法">单边循环法</span></h5><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">sort</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>nums<span class="token punctuation">,</span>start<span class="token punctuation">,</span>end<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> start <span class="token operator">>=</span> end<span class="token punctuation">:</span>            <span class="token keyword">return</span>        mark <span class="token operator">=</span> start        <span class="token keyword">for</span> cnt <span class="token keyword">in</span> range<span class="token punctuation">(</span>start<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>end<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>cnt<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">:</span>                mark <span class="token operator">+=</span> <span class="token number">1</span>                <span class="token keyword">if</span> mark <span class="token operator">!=</span> cnt<span class="token punctuation">:</span>                    nums<span class="token punctuation">[</span>mark<span class="token punctuation">]</span> <span class="token operator">^</span><span class="token operator">=</span> nums<span class="token punctuation">[</span>cnt<span class="token punctuation">]</span>                    nums<span class="token punctuation">[</span>cnt<span class="token punctuation">]</span> <span class="token operator">^</span><span class="token operator">=</span> nums<span class="token punctuation">[</span>mark<span class="token punctuation">]</span>                    nums<span class="token punctuation">[</span>mark<span class="token punctuation">]</span> <span class="token operator">^</span><span class="token operator">=</span> nums<span class="token punctuation">[</span>cnt<span class="token punctuation">]</span>         <span class="token keyword">if</span> mark <span class="token operator">!=</span> start<span class="token punctuation">:</span>            nums<span class="token punctuation">[</span>mark<span class="token punctuation">]</span> <span class="token operator">^</span><span class="token operator">=</span> nums<span class="token punctuation">[</span>start<span class="token punctuation">]</span>            nums<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">^</span><span class="token operator">=</span> nums<span class="token punctuation">[</span>mark<span class="token punctuation">]</span>            nums<span class="token punctuation">[</span>mark<span class="token punctuation">]</span> <span class="token operator">^</span><span class="token operator">=</span> nums<span class="token punctuation">[</span>start<span class="token punctuation">]</span>         self<span class="token punctuation">.</span>sort<span class="token punctuation">(</span>nums<span class="token punctuation">,</span>start<span class="token punctuation">,</span>mark<span class="token number">-1</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>sort<span class="token punctuation">(</span>nums<span class="token punctuation">,</span>mark<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>end<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">sortArray</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 快排</span>        self<span class="token punctuation">.</span>sort<span class="token punctuation">(</span>nums<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> nums</code></pre><h5><span id="非递归">非递归</span></h5><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">sort</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>nums<span class="token punctuation">,</span>start<span class="token punctuation">,</span>end<span class="token punctuation">)</span><span class="token punctuation">:</span>        mark <span class="token operator">=</span> start        <span class="token keyword">for</span> cnt <span class="token keyword">in</span> range<span class="token punctuation">(</span>start<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>end<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>cnt<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">:</span>                mark <span class="token operator">+=</span> <span class="token number">1</span>                <span class="token keyword">if</span> mark <span class="token operator">!=</span> cnt<span class="token punctuation">:</span>                    nums<span class="token punctuation">[</span>mark<span class="token punctuation">]</span> <span class="token operator">^</span><span class="token operator">=</span> nums<span class="token punctuation">[</span>cnt<span class="token punctuation">]</span>                    nums<span class="token punctuation">[</span>cnt<span class="token punctuation">]</span> <span class="token operator">^</span><span class="token operator">=</span> nums<span class="token punctuation">[</span>mark<span class="token punctuation">]</span>                    nums<span class="token punctuation">[</span>mark<span class="token punctuation">]</span> <span class="token operator">^</span><span class="token operator">=</span> nums<span class="token punctuation">[</span>cnt<span class="token punctuation">]</span>         <span class="token keyword">if</span> mark <span class="token operator">!=</span> start<span class="token punctuation">:</span>            nums<span class="token punctuation">[</span>mark<span class="token punctuation">]</span> <span class="token operator">^</span><span class="token operator">=</span> nums<span class="token punctuation">[</span>start<span class="token punctuation">]</span>            nums<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">^</span><span class="token operator">=</span> nums<span class="token punctuation">[</span>mark<span class="token punctuation">]</span>            nums<span class="token punctuation">[</span>mark<span class="token punctuation">]</span> <span class="token operator">^</span><span class="token operator">=</span> nums<span class="token punctuation">[</span>start<span class="token punctuation">]</span>         <span class="token keyword">return</span> mark    <span class="token keyword">def</span> <span class="token function">sortArray</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 快排</span>        stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"start"</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token string">"end"</span><span class="token punctuation">:</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>stack<span class="token punctuation">)</span><span class="token punctuation">:</span>            dic <span class="token operator">=</span> stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>            mark <span class="token operator">=</span> self<span class="token punctuation">.</span>sort<span class="token punctuation">(</span>nums<span class="token punctuation">,</span>dic<span class="token punctuation">[</span><span class="token string">"start"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>dic<span class="token punctuation">[</span><span class="token string">"end"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> dic<span class="token punctuation">[</span><span class="token string">"start"</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> mark<span class="token number">-1</span><span class="token punctuation">:</span>                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"start"</span><span class="token punctuation">:</span>dic<span class="token punctuation">[</span><span class="token string">"start"</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">"end"</span><span class="token punctuation">:</span>mark<span class="token number">-1</span><span class="token punctuation">}</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> dic<span class="token punctuation">[</span><span class="token string">"end"</span><span class="token punctuation">]</span> <span class="token operator">></span> mark<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span>                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"start"</span><span class="token punctuation">:</span>mark<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">"end"</span><span class="token punctuation">:</span>dic<span class="token punctuation">[</span><span class="token string">"end"</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> nums</code></pre><h4><span id="区间优化后的鸡尾酒排序">区间优化后的鸡尾酒排序</span></h4><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">sortArray</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 鸡尾酒排序</span>        right_border <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>        left_border <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            not_sorted <span class="token operator">=</span> <span class="token boolean">True</span>            <span class="token comment" spellcheck="true"># 奇数轮</span>            last_change_index <span class="token operator">=</span> right_border<span class="token number">-1</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>left_border<span class="token punctuation">,</span>right_border<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                    nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">^</span><span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span>                    nums<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">^</span><span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span>                    nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">^</span><span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span>                    not_sorted <span class="token operator">=</span> <span class="token boolean">False</span>                    last_change_index <span class="token operator">=</span> j             right_border <span class="token operator">=</span> last_change_index            <span class="token keyword">if</span> not_sorted<span class="token punctuation">:</span>                <span class="token keyword">break</span>            not_sorted <span class="token operator">=</span> <span class="token boolean">True</span>            <span class="token comment" spellcheck="true"># 偶数轮</span>            last_change_index <span class="token operator">=</span> left_border<span class="token operator">+</span><span class="token number">1</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>right_border<span class="token punctuation">,</span>left_border<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                    nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">^</span><span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span>                    nums<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">^</span><span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span>                    nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">^</span><span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span>                    not_sorted <span class="token operator">=</span> <span class="token boolean">False</span>                    last_change_index <span class="token operator">=</span> j             left_border <span class="token operator">=</span> last_change_index            <span class="token keyword">if</span> not_sorted<span class="token punctuation">:</span>                <span class="token keyword">break</span>        <span class="token keyword">return</span> nums</code></pre><hr><h3><span id="异或">异或</span></h3><h4><span id="知识点">知识点</span></h4><ol><li>相同为0，不同为1（真值表）</li><li>0异或任何一个数还是这个数本身</li><li>一个数异或其本身为0</li></ol><h4><span id="可以用异或解决的题目特征">可以用异或解决的题目特征</span></h4><p>存在并且只有一个数字会重复奇数次，要找出这个数字是什么</p><p><strong>解释</strong></p><ol><li>出现偶数次的数字异或结果为0（知识点3）</li><li>异或满足交换律，将所有数字异或起来的值为出现奇数次的数字（知识点2）</li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 异或 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker的基本使用命令</title>
      <link href="2019/04/20/docker%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>2019/04/20/docker%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1><span id="docker的基本使用命令">docker的基本使用命令</span></h1><blockquote><p>[ ]表示可选  </p></blockquote><h2><span id="容器">容器</span></h2><ol><li><p>查看正在运行的容器<br><code>docker ps</code><br>查询最后一次创建的容器<br><code>docker ps -l</code><br>列出所有的容器 ID<br><code>docker ps -aq</code></p></li><li><p>在后台运行一个python的web应用<br><code>docker run -d -P [hostport]:[containerport] 镜像名 python 要运行的文件名如app.py</code>  </p><blockquote><p>参数说明:<br>-d:让容器在后台运行。<br>-P:将容器内部使用的网络端口映射到我们使用的主机上   </p></blockquote><p> 运行交互式容器<br><code>docker run -i -t 镜像名 /bin/bash</code>  </p><blockquote><p>各个参数解析：<br>-t:在新容器内指定一个伪终端或终端。<br>-i:允许你对容器内的标准输入 (STDIN) 进行交互。    </p></blockquote><p> 重新以交互模式进入存在的容器<br> <code>docker attach 容器id</code>  </p></li><li><p>查看容器的端口映射<br> <code>docker port 容器id</code> or <code>docker port 容器名</code></p></li><li>查看web应用程序日志<br> <code>docker logs 容器ID或者名字</code><br> -f: 让 docker logs 像使用 tail -f 一样来输出容器内部的标准输出。</li><li>停止容器<br> <code>docker stop 容器名</code><br> 停止所有的容器<br> <code>docker stop $(docker ps -aq)</code></li><li>启动已经停止的web应用容器<br> <code>docker start 容器id</code><br> 重启没有停止的web应用容器<br> <code>docker restart 容器id</code>  </li><li>移除容器(移除容器时容器必须是停止状态)<br> <code>docker rm 容器名</code><br> 删除所有的容器<br> <code>docker rm $(docker ps -aq)</code><br> 删除所有停止的容器<br> <code>docker container prune -f</code></li><li>退出容器<br> <code>ctrl+d</code></li><li>如果要正常退出不关闭容器，请按Ctrl+P+Q进行退出容器</li></ol><h2><span id="镜像">镜像</span></h2><ol><li>载入镜像<br><code>docker pull 镜像名[：标签]</code><br>标签可选，没有标签默认latest</li></ol><ul><li><p>查看镜像<br><code>docker images</code>  </p></li><li><p>使用镜像<br><code>run 镜像名</code></p></li><li><p>删除镜像<br><code>docker rmi 镜像名或id</code><br>删除所有的镜像<br><code>docker rmi $(docker images -q)</code><br>删除所有不使用的镜像<br><code>docker image prune --force --all</code></p></li><li><p>查找镜像<br><code>docker search 镜像名</code></p></li></ul><h3><span id="创建镜像">创建镜像</span></h3><blockquote><p>当我们从docker镜像仓库中下载的镜像不能满足我们的需求时，我们可以通过以下两种方式对镜像进行更改。<br>1.从已经创建的容器中更新镜像，并且提交这个镜像<br>2.使用 Dockerfile 指令来创建一个新的镜像</p></blockquote><h4><span id="从已经创建的容器中更新镜像">从已经创建的容器中更新镜像</span></h4><h5><span id="更新镜像包">更新镜像包</span></h5><p>新镜像之前，我们需要使用镜像来创建一个容器。<br>runoob@runoob:~$ docker run -t -i ubuntu:15.10 /bin/bash<br><strong>root@e218edb10161:/# 在运行的容器内使用 <code>apt-get update</code> 命令进行更新和安装想要安装的包</strong><br>在完成操作之后，输入 <code>exit</code>命令来退出这个容器。</p><p>此时ID为e218edb10161的容器，是按我们的需求更改的容器。我们可以通过命令 <code>docker commit</code>来提交容器副本。</p><p>runoob@runoob:~$ <code>docker commit -m=&quot;has update&quot; -a=&quot;runoob&quot; e218edb10161 runoob/ubuntu:v2</code><br>sha256:70bf1840fd7c0d2d8ef0a42a817eb29f854c1af8f7c59fc03ac7bdee9545aff8</p><blockquote><p>各个参数说明：<br>-m: 提交的描述信息<br>-a: 指定镜像作者<br>e218edb10161：容器ID<br>runoob/ubuntu:v2: 指定要创建的目标镜像名</p></blockquote><p>我们可以使用 <code>docker images</code> 命令来查看我们的新镜像 runoob/ubuntu:v2：</p><h5><span id="导入和导出镜像包">导入和导出镜像包</span></h5><h6><span id="export和import">export和import</span></h6><p><strong>export</strong><br><code>docker export 容器名 &gt; 导出路径，一般以.tar结尾</code><br>举例：<br>我们使用容器 furious_bell，现在要将这个容器保存为一个文件 myunbuntu-export-1204.tar<br><code>docker export furious_bell &gt; /home/myubuntu-export-1204.tar</code><br><strong>import</strong><br><code>docker import - 要导入的包路径或url</code><br>举例：<br><code>docker import - /home/myubuntu-export-1204.tar</code><br>通过指定 URL 或者某个目录来导入<br><code>sudo docker import http://example.com/exampleimage.tgz example/imagerepo</code></p><h6><span id="save和load">save和load</span></h6><p><strong>save</strong><br><code>docker save 9610cfc68e8d &gt; /home/myubuntu-save-1204.tar</code><br>有点慢，稍微等待一下，没有任何warn信息就表示保存OK。9610cfc68e8d 是镜像ID<br><strong>load</strong><br>现在就可以在任何装 docker 的地方加载刚保存的镜像了<br><code>docker load &lt; /home/myubuntu-save-1204.tar</code></p><h6><span id="导出-export-与-保存-save-的区别">导出 export 与 保存 save 的区别</span></h6><ol><li><p>export导出的镜像文件大小 小于 save保存的镜像</p></li><li><p>export 导出（import导入）是根据容器拿到的镜像，再导入时会丢失镜像所有的历史，所以无法进行回滚操作（<code>docker tag &lt;LAYER ID&gt; &lt;IMAGE NAME&gt;</code>）；而save保存（load加载）的镜像，没有丢失镜像的历史，可以回滚到之前的层（layer）。（查看方式：<code>docker images --tree</code>） <strong>确切的说，export其实是容器的保存，只把镜像当前的状态保存下来，没有历史版本等信息，所以文件比较小</strong></p></li></ol><p>注：导入加载进来觉得不合适可以使用 docker rm 容器ID 、 docker rmi 镜像ID 来删掉和移除所有的容器和镜像（大扫除）：<br><code>docker kill $(docker ps -q)</code> ; <code>docker rm $(docker ps -a -q)</code> ; <code>docker rmi $(docker images -q -a)`</code>   </p><hr><h4><span id="使用-dockerfile-来创建一个新的镜像">使用 Dockerfile 来创建一个新的镜像</span></h4><h5><span id="创建-dockerfile文件">创建 Dockerfile文件</span></h5><p><code>vim dockerfile</code>   </p><h5><span id="进入-dockerfile文件进行编辑">进入 dockerfile文件进行编辑</span></h5><blockquote><p><strong>Docker语法：</strong><br>FROM 基础镜像base image<br>MAINTAINER 维护者<br>RUN 执行命令<br>ADD 添加文件<br>COPY 拷贝文件<br>CMD 执行命令<br>EXPOSE 执行命令<br>WORKDIR 指定路径<br>ENV 设定环境变量<br>USER 指定路径<br>VOLUME 逻辑卷挂载点mount point<br><strong>注意事项</strong>  </p><ol><li>使用apt-get install 要在最后加 –assume-yes ，否则会abort</li><li>使用yum还是apt取决于base image环境，不是取决于自己服务器的环境</li><li>每次使用RUN指令都是新增一层镜像，所以最好用&amp;&amp; 连接多个RUN</li><li>换行是\</li><li>为了让镜像包不臃肿最后要删除。。。什么什么的</li></ol></blockquote><h6><span id="使用dockerfile">使用dockerfile</span></h6><p><code>docker build -t 镜像名 dockfile所在目录，当前目录可用.</code></p><h2><span id="其他">其他</span></h2><h3><span id="拷贝">拷贝</span></h3><ol><li><p>从容器拷贝文件到宿主机<br> 拷贝方式为：<br> <strong>docker cp 容器名：容器中要拷贝的文件名及其路径 要拷贝到宿主机里面对应的路径</strong><br> 例如，将容器:mycontainer中路径：/opt/testnew/下的文件：file.txt<br> 拷贝到宿主机：<br> /opt/test/<br> 路径下，在宿主机中执行命令如下：<br> <code>docker cp mycontainer：/opt/testnew/file.txt /opt/test</code></p></li><li><p>从宿主机拷贝文件到容器拷贝方式为：</p><p><strong>docker cp 宿主机中要拷贝的文件名及其路径 容器名：要拷贝到容器里面对应的路径</strong></p><p>例如，将宿主机中路径：</p><p>/opt/test/ 下的文件 file.txt</p><p>拷贝到容器：mycontainer 的：/opt/testnew/</p><p>路径下，同样还是在宿主机中执行命令如下：</p><p><code>docker cp /opt/test/file.txt mycontainer:/opt/testnew</code></p></li><li>不管容器有没有启动，拷贝命令都会生效</li></ol><h3><span id="映射">映射</span></h3><h4><span id="docker-给运行中的容器添加映射端口">DOCKER 给运行中的容器添加映射端口</span></h4><p>方法1  </p><ol><li>获得容器IP<br>将container_name 换成实际环境中的容器名<br>docker inspect <code>container_name</code> | grep IPAddress</li><li>iptable转发端口<br>将容器的8000端口映射到docker主机的8001端口<br><code>iptables -t nat -A  DOCKER -p tcp --dport 8001 -j DNAT --to-destination 172.17.0.19:80</code>  </li></ol><p>方法2  </p><ol><li>提交一个运行中的容器为镜像<br><code>docker commit containerid foo/live</code></li><li>运行镜像并添加端口<br><code>docker run -d -p 8000:80  foo/live /bin/bash</code>  </li></ol><p>方法3(已确认)  </p><ol><li>停止容器  </li><li>停止docker服务(systemctl stop docker)  </li><li>修改这个容器的hostconfig.json文件中的端口（原帖有人提到，如果config.v2.json里面也记录了端口，也要修改）  <pre><code>cd /var/lib/docker/3b6ef264a040* #这里是CONTAINER IDvi hostconfig.json如果之前没有端口映射, 应该有这样的一段:&quot;PortBindings&quot;:{}增加一个映射, 这样写:&quot;PortBindings&quot;:{&quot;3306/tcp&quot;:[{&quot;HostIp&quot;:&quot;&quot;,&quot;HostPort&quot;:&quot;3307&quot;}]}前一个数字是容器端口, 后一个是宿主机端口.而修改现有端口映射更简单, 把端口号改掉就行.</code></pre>4) 启动docker服务(systemctl start docker)<br>5) 启动容器  </li></ol><hr><h2><span id="参考">参考</span></h2><p><a href="http://www.runoob.com/docker" target="_blank" rel="noopener">菜鸟教程</a><br><a href="https://colobu.com/2018/05/15/Stop-and-remove-all-docker-containers-and-images/" target="_blank" rel="noopener">停止、删除所有的docker容器和镜像</a><br><a href="https://yeasy.gitbooks.io/docker_practice/introduction/what.html" target="_blank" rel="noopener">docker从入门到实践</a><br><a href="https://blog.csdn.net/a906998248/article/details/46236687" target="_blank" rel="noopener">导入和导出</a><br><a href="https://blog.csdn.net/dongdong9223/article/details/71425077" target="_blank" rel="noopener">复制文件</a><br><a href="https://blog.csdn.net/wesleyflagon/article/details/78961990" target="_blank" rel="noopener">修改端口</a></p>]]></content>
      
      
      <categories>
          
          <category> 云原生相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 备忘 </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git的用法</title>
      <link href="2019/02/24/git%E7%9A%84%E7%94%A8%E6%B3%95/"/>
      <url>2019/02/24/git%E7%9A%84%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1><span id="git的简单指令和例子">git的简单指令和例子</span></h1><h2><span id="配置git简写">配置git简写</span></h2><pre class=" language-git"><code class="language-git">git config --global -e</code></pre><pre class=" language-git"><code class="language-git">[alias]    st = status    co = checkout    br = branch    mg = merge    ci = commit     md = commit --amend    dt = difftool    mt = mergetool    last = log -1 HEAD    cf = config    line = log --oneline    latest = for-each-ref --sort=-committerdate --format=<span class="token string">'%(committerdate:short) %(refname:short) [%(committername)]'</span>    ls = log --pretty=format:\<span class="token string">"%C(yellow)%h %C(blue)%ad %C(red)%d %C(reset)%s %C(green)[%cn]\"</span> --decorate --date=short    hist = log --pretty=format:\<span class="token string">"%C(yellow)%h %C(red)%d %C(reset)%s %C(green)[%an] %C(blue)%ad\"</span> --topo-order --graph --date=short    type = cat-file -t    dump = cat-file -p</code></pre><h2><span id="checkout">checkout</span></h2><blockquote><p>神器！！</p></blockquote><pre><code>git checkout master</code></pre><p>回到 master 分支。分支会在下一节中讲到，而现在，你只需要将它视为回到项目「当前」状态的一种方式。</p><pre><code>git checkout &lt;commit&gt; &lt;file&gt;</code></pre><p>查看文件之前的版本。它将工作目录中的 <code>&lt;file&gt;</code> 文件变成 <code>&lt;commit&gt;</code> 中那个文件的拷贝，并将它加入缓存区,如果进行了改名，则会新加这一个文件。</p><pre><code>git checkout &lt;commit&gt;</code></pre><p>更新工作目录中的所有文件，使得和某个特定提交中的文件一致。你可以将提交的哈希字串，或是标签作为 <code>&lt;commit&gt;</code> 参数。这会使你处在分离 HEAD 的状态。</p><h2><span id="add">add</span></h2><p>eg. 只要是同一个文件，文件名不一样也会进行覆盖</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 备忘 </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>做第一个项目时遇到的一些小坑</title>
      <link href="2019/02/21/%E5%81%9A%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%A1%B9%E7%9B%AE%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E5%9D%91/"/>
      <url>2019/02/21/%E5%81%9A%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%A1%B9%E7%9B%AE%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<h1><span id="第一个项目的踩坑总结">第一个项目的踩坑总结</span></h1><blockquote><p>在大一上的一个寒假里参与了一个项目中拍图搜题的后台部分，由于是第一次参与项目，踩了不少坑，简单的总结一下</p></blockquote><h4><span id="与前端交互最好不要使用socket通信">与前端交互最好不要使用socket通信</span></h4><h5><span id="原因1">原因1</span></h5><p>前端通常使用js或者vue.js等各种模板，这里面的websocket模块和python的socket模块是不一样的，python的socket协议中不需要握手，而websocket中需要一次握手，经过实验，需用上以下代码。</p><pre class=" language-python"><code class="language-python">     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Accept new connection from %s:%s...'</span> <span class="token operator">%</span> addr<span class="token punctuation">)</span>    receivedData <span class="token operator">=</span> str<span class="token punctuation">(</span>sock<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">2048</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>receivedData<span class="token punctuation">)</span>    entities <span class="token operator">=</span> receivedData<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">"\\r\\n"</span><span class="token punctuation">)</span>    Sec_WebSocket_Key <span class="token operator">=</span> entities<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">":"</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'258EAFA5-E914-47DA-95CA-C5AB0DC85B11'</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>Sec_WebSocket_Key<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># print("key ", Sec_WebSocket_Key)</span>    response_key <span class="token operator">=</span> base64<span class="token punctuation">.</span>b64encode<span class="token punctuation">(</span>hashlib<span class="token punctuation">.</span>sha1<span class="token punctuation">(</span>bytes<span class="token punctuation">(</span>Sec_WebSocket_Key<span class="token punctuation">,</span> encoding<span class="token operator">=</span><span class="token string">"utf8"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>digest<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    response_key_str <span class="token operator">=</span> str<span class="token punctuation">(</span>response_key<span class="token punctuation">)</span>    response_key_str <span class="token operator">=</span> response_key_str<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token number">30</span><span class="token punctuation">]</span>    <span class="token comment" spellcheck="true"># print(response_key_str)</span>    response_key_entity <span class="token operator">=</span> <span class="token string">"Sec-WebSocket-Accept: "</span> <span class="token operator">+</span> response_key_str <span class="token operator">+</span> <span class="token string">"\r\n"</span>    sock<span class="token punctuation">.</span>send<span class="token punctuation">(</span>bytes<span class="token punctuation">(</span><span class="token string">"HTTP/1.1 101 Web Socket Protocol Handshake\r\n"</span><span class="token punctuation">,</span> encoding<span class="token operator">=</span><span class="token string">"utf8"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    sock<span class="token punctuation">.</span>send<span class="token punctuation">(</span>bytes<span class="token punctuation">(</span><span class="token string">"Upgrade: websocket\r\n"</span><span class="token punctuation">,</span> encoding<span class="token operator">=</span><span class="token string">"utf8"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    sock<span class="token punctuation">.</span>send<span class="token punctuation">(</span>bytes<span class="token punctuation">(</span>response_key_entity<span class="token punctuation">,</span> encoding<span class="token operator">=</span><span class="token string">"utf8"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    sock<span class="token punctuation">.</span>send<span class="token punctuation">(</span>bytes<span class="token punctuation">(</span><span class="token string">"Connection: Upgrade\r\n\r\n"</span><span class="token punctuation">,</span> encoding<span class="token operator">=</span><span class="token string">"utf8"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"send the hand shake data"</span><span class="token punctuation">)</span></code></pre><p>其中Sec_WebSocket_Key的获取方式或许会随着其不同的握手信息而改变，需要自己进行修改。</p><h5><span id="原因2">原因2</span></h5><p>在经历千辛万苦接收到前端发送过来的信息后，会发现此信息不能被成功解码(尝试过常见的解码方式都不能被解出)</p><h5><span id="原因3">原因3</span></h5><p>此外，socket通信接收信息时一次性最多只能读取其缓存区内的全部信息，也就是说希望通过recv(200000)诸如此类的指令一次性取地全部信息是无效的，并且可能发生文件不能被完全接收，并且此bug不会被报错是很难被调试出来的（在本地接收到信息是完整的，而在服务器上接收到的信息却是不完整的，可用hash进行验证）。</p><h5><span id="原因4">原因4</span></h5><p>因此综上，只能通过分次接收获得如base64编码的长字节信息，而如果要让服务端停止通信，必须要在客户端将此次通信结束，这对接下来服务端向客户端发送数据造成了极大的不便</p><hr><blockquote><p>因此，极力推荐通过flask等框架进行通信，使用socket磨了半星期的我就是个sb</p></blockquote><hr><h4><span id="最好有一个服务器">最好有一个服务器</span></h4><p>只有有了服务器才能让前端与后端进行通信，否则只能在127.0.0.1内使用，不能让外网访问。</p><h4><span id="数据格式最好采用通用的格式如json">数据格式最好采用通用的格式如json</span></h4><p>不同的语言其内置造成数据类型可能是不同的，如果因为数据格式不兼容而造成与前端交互的不便就得不偿失了</p><h4><span id="服务器上的python版本">服务器上的python版本</span></h4><p>服务器自带的大多是python2.x版本，在抄网上教程时不能不带脑子的原样照搬，否则可能不仅不能成功切换的版本，而且在经历多个教程的洗礼后服务器上的环境会越来越混乱让你心烦意乱555</p><hr><blockquote><p>记忆中踩过比较深刻的坑大概是这么几个，事实上在这个本以为easy的小项目中踩过无数的坑，想到这就非常感谢已经毕业的课外老师兼大佬学长(给的东西都非常靠谱），虽然总是骂人但也会答复我的sb问题的可爱部长，还有耐心的前端学长对我这萌新的包容，如果不是他们我可能会在这个项目上浪费更多的时间，或许最好还不能成功完成这个项目。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> flask </tag>
            
            <tag> 踩坑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用的linux指令</title>
      <link href="2019/02/21/%E5%B8%B8%E7%94%A8%E7%9A%84linux%E6%8C%87%E4%BB%A4/"/>
      <url>2019/02/21/%E5%B8%B8%E7%94%A8%E7%9A%84linux%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2><span id="常用linux指令">常用linux指令</span></h2><h4><span id="cd">cd</span></h4><ol><li><code>cd /</code> 进入到根目录</li><li><code>cd ~</code>进入到根目录下的root目录即/root/</li><li>由<code>/</code>开头的是绝对路径，跟在cd后面可以进入相应的文件夹</li><li><code>cd ../</code>进入上一级目录</li></ol><h4><span id="常用文本编辑器">常用文本编辑器</span></h4><h5><span id="nano">nano</span></h5><h5><span id="vim">vim</span></h5><blockquote><p>vim常用命令</p><ol><li>w保存q退出!强制适用于只读保存文件</li><li>i进入插入模式，: 进入底线命令模式</li><li><code>/</code>加文字表示搜索后面相匹配的文字，<code>?</code>向前搜索，按n查看下一个匹配</li><li>[常用vim命令][<a href="http://www.runoob.com/linux/linux-vim.html]" target="_blank" rel="noopener">http://www.runoob.com/linux/linux-vim.html]</a></li></ol></blockquote><h4><span id="配置python时常用的命令">配置python时常用的命令</span></h4><blockquote><p>以下皆为举例形式</p></blockquote><ol><li><code>ll /usr/bin | grep python</code>查看/usr/bin下的python版本</li><li><code>mv /usr/bin/python  /usr/bin/python2.7</code>重命名旧版本</li><li><code>rm -rf /usr/bin/python</code>删除旧的软链接</li><li><code>ln -s 新链接源文件 链接文件</code> 创建新链接</li><li><code>python --version</code>或<code>python -V</code>查看python位置</li><li><code>which python</code>查看python指令所调用的目录 （非常重要 改了软链接不起作用很有可能是这条！！）</li><li><code>chmod 777 文件名</code>如果出现permission denied用此命令授予源文件权限</li><li><code>vim ~/.bash_profile</code>添加环境变量</li><li><code>vim ~/.bashrc</code>同样添加环境变量</li><li><code>source ~/.bash_profile</code>保存文件</li><li><code>pip install -r requirments.txt</code>新增依赖</li><li><code>pip freeze &gt; requirements.txt</code>导出该环境下的依赖到requirements.txt文件</li><li><code>tar -xf tgz包</code>解压tgz包</li><li>·<code>./configure --prefix=需要安装的目录</code>执行此命令前要先回到解压文件夹下</li><li><code>make &amp;&amp; make install</code>编译安装，需要紧跟上部</li><li><code>sh start.sh start/restart/stop/reload</code>执行 start.sh脚本，即shell脚本，可用于常开服务器端口</li><li><code>rm [-f][-R] 文件名</code> 不加参数删除单个文件，-f强行删除，-R删除目录下所有文件</li><li><code>update-alternatives --config python</code>快速切换python</li><li><code>update-alternatives --remove python /usr/bin/python2.7</code>移除旧版本</li></ol><h4><span id="其他的一些有用的命令">其他的一些有用的命令</span></h4><ol><li><code>ls  -a</code>显示所有文件和文件夹，包括隐藏</li><li><code>pstree -ap | grep gunicorn</code>获取gunicorn进程树</li><li><code>kill -9 查询出的主进程pid</code> 【强制】关闭主进程</li><li><code>kill -HUP 主进程id</code>重启gunicorn任务</li></ol><h3><span id="参考文档">参考文档</span></h3><p>[在软链接地方有坑其他ok的教程][<a href="https://www.cnblogs.com/mqxs/p/9103031.html]" target="_blank" rel="noopener">https://www.cnblogs.com/mqxs/p/9103031.html]</a></p><p>[安装python加虚拟环境的靠谱教程][<a href="https://shimo.im/docs/PITngHlPpaIdxtFa/read]" target="_blank" rel="noopener">https://shimo.im/docs/PITngHlPpaIdxtFa/read]</a></p><p>[linux命令大全][<a href="http://www.runoob.com/linux/linux-command-manual.html]" target="_blank" rel="noopener">http://www.runoob.com/linux/linux-command-manual.html]</a></p><p>[快速切换python][<a href="https://www.cnblogs.com/rexyan/p/7485135.html]" target="_blank" rel="noopener">https://www.cnblogs.com/rexyan/p/7485135.html]</a></p><p>[flask+ningx=gunicorn][<a href="https://www.cnblogs.com/Ray-liang/p/4837850.html]" target="_blank" rel="noopener">https://www.cnblogs.com/Ray-liang/p/4837850.html]</a></p><p>[virtuaenvwrapper基本使用][<a href="https://www.cnblogs.com/justbreaking/p/7103234.html]" target="_blank" rel="noopener">https://www.cnblogs.com/justbreaking/p/7103234.html]</a></p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 备忘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多肉植物养护知识</title>
      <link href="2018/12/23/%E6%A4%8D%E7%89%A9%E5%85%BB%E6%8A%A4%E7%9F%A5%E8%AF%86/"/>
      <url>2018/12/23/%E6%A4%8D%E7%89%A9%E5%85%BB%E6%8A%A4%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1><span id="多肉植物">多肉植物</span></h1><p>购买：</p><p><em>名字+多肉 的方式搜索，按销量排名，你可以开始看最低价格了，只看第一页，一般来说我们最终会选的店铺不会在第一二排（第一常识）。价格低的店铺鼠标放店家名上看评分，不是红的，跳过，宿迁沭阳，直接跳过，一般这样筛选下来，只会剩两三家。然后你再对比下这两三家确认下尺寸品相，看下评论的晒图，及店铺里其他多肉感觉上的价格，选定一家，按对方的最低包邮要求，先买上一次</em>，感觉好以后再来买第二次。（但，实际上，按这个方法你通常不会买第二次，因为你会一直发现，你想要买的多肉一直有便宜的店铺让你选！）<br><a href="https://www.drlmeng.com/wp-content/uploads/2017/10/maijiaming.jpg" target="_blank" rel="noopener">淘宝怎么选店铺</a><br>另外非常巧合的是，这些店铺通常都是大棚店铺，以山东为主、少量河南、江苏、河北。</p><h2><span id="基本知识">基本知识</span></h2><h3><span id="土壤">土壤</span></h3><blockquote><ul><li>排水性好</li><li>吸水性好</li><li>可以让空气到达根部</li></ul></blockquote><p>当土壤无法让空气到达植物的根部的时候， 根部就会出现死亡和腐烂，并且会从根部腐烂到植物主体。以上的这种假设可以通过在土壤中加入一些大的排水性好的颗粒来解决。</p><p>好的土壤混合：</p><p>1）40%的有营养的物质（例如<strong>泥炭</strong>，椰壳纤维）</p><p>2）60%的排水物质（例如粗沙， 轻石，<strong>珍珠岩</strong>或者砾石）</p><blockquote><p>此外还有一个建议在植株上铺一层铺面，从而防止在植物浇水时土溅到植物底部，并且提高土壤的渗透性。还可以反射阳光从而减少热量传输到根部。并且还可以预防土壤表面的板结。</p></blockquote><blockquote><p>铺面可采用珍珠岩等排水物质</p></blockquote><h4><span id="具体案例">具体案例</span></h4><blockquote><p>50%的蛭石，30%的泥炭土，20%珍珠岩</p><p>他们都有一个共同特点，那就是质轻</p></blockquote><p>蛭石它的主要作用就是保水，也就是锁水的意思，它可以吸收外界的水分然后缓慢释放，确保空气中的湿度。</p><p>起初，泥炭土并没有太大的作用，但是一旦叶插苗生根之后，泥炭富含有机质的特性就可以为小苗提供充足的营养了</p><p>珍珠岩价格便宜，混合到土壤中去可以增加土壤的体积，其次，珍珠岩质轻，不会在土壤中产生重量，而挤压导致土壤板结，小苗的前期根系非常脆弱，一旦土壤板结甚至于根系就只能晾晒到露天的环境而导致无法吸取土壤中的养分。</p><h3><span id="浇水">浇水</span></h3><blockquote><p>在生长季对多肉植物浇水的黄金规则就是在<strong>植物根部周围土壤快要完全干的时候再浇水</strong>。</p></blockquote><p>原理是这样的：“夏日种”会在春天进入生长季并且在夏天最炎热的时候停止生长，并且会早秋短暂生长，然后进入休眠。”冬日种“则是在秋天进入生长，并在最冷的时候停止生长，在早春短暂生长，然后进入休眠。</p><p>当植物在生长季有些干枯的时候通常都是植物需要水的标志，在休眠季则是正常休眠，并不需要关心干枯的表皮。</p><h3><span id="光照">光照</span></h3><p>一个大多数人都会犯的对于多肉植物光照的错误认知是，它们会喜欢尽可能多的直射光照。然而这并不是正确的，在野外许多的小型种都会生长在灌木丛的底下。另外多肉植物的茎（个人认为是叶片）的光合作用会因为直射光而受到影响。很多植物都会去减少茎表面受到直射光的面积。这一现象是因为植物的向光性。</p><p>这让我想到在户外植物的移栽，<strong>当移栽的时候植物相同的一面面向阳光并且给予它额外50%面积大遮光</strong>，直到它完全服盆。</p><h3><span id="温度">温度</span></h3><p>大部分的多肉植物会在<strong>白天14摄氏度到25摄氏度</strong>，<strong>夜晚4到10摄氏度</strong>的时候生长的比较好。要注意的是温度最好不要在0摄氏度以下，即使是在0摄氏度以下也不要超过一两个小时。</p><p>夏天的温度最好控制在白天25至38摄氏度，夜晚14至20度。</p><p>大部分多肉不喜欢夜晚在24度以上，并且在那些地方夏天多肉的数量会很明显分减少和消失。</p><p>要理解这个就得要明白多肉独特的光合作用，有一种叫做Crassulacean Acid Metabolism(某种酸性的新陈代谢）基本上与其他的植物完全的不同。多肉叶片和根茎上的气孔会在白天闭合，夜晚张开。只有在凉爽的夜晚才可以吸入二氧化碳，被植物中的有机酸萃取，这可以被形容为一种“延迟的光合作用”，因为这种对二氧化碳的作用只会在夜晚中的产生。这也是为什么温度和新鲜的空气在夜晚也很重要。</p><h3><span id="空气流通">空气流通</span></h3><p>流通的空气环境是养殖多肉<strong>最基本的条件</strong>，就像在上面所说的那样，在夜晚尤其重要。但多肉生长在一个封闭的温室中，安装风扇从而创造一个流通的空气环境是非常重要的。</p><p>这也意味着大多数的多肉并不能在办公桌前和窗台上很好的生存，尽管它们是些很好的室内装饰物， 也许它们可以在这种情况下生存很久，但是这对植物来说就是慢性死亡。</p><hr><h2><span id="进阶知识">进阶知识</span></h2><h3><span id="增肥">增肥</span></h3><blockquote><p>其实肉肉的增肥过程就是肉肉在健康成长过程中<strong>被控水</strong>的过程，肥的前提是健康，就好比一个人要不生病，健康的体质才是关键。如果你家的肉又弱又小还没长好根，你指望它能肥给你看就只能是个奢望了。</p></blockquote><h4><span id="多肉养肥的第一步修根">多肉养肥的第一步:修根</span></h4><blockquote><p>淘宝刚买回来和肉肉们长着长着就不行了，为了挽救它们需要修根或者砍头，给它们新生</p></blockquote><blockquote><p><strong>千万不能在修完根后立马种下</strong>，一定要放在阴凉通风处晾三天以上再上盆，我曾经因为懒，根一晾就是一周甚至一个月，也并不影响植株存活，甚至比只晾了三天上盆的更好发根(前提是在生长季)。</p></blockquote><p>肉肉状态追求的是上色控型，徒有个大饼脸并不是什么好事。另外根系发达与否，其实也只能证明肉肉曾经在别人手里活得怎么样，到了你的手里，根系能不能发达，还得看你的养功。为何这样说呢?我们可以把肉肉的茎比喻成它的肺，而诸多的根络则是肺上的支气管和毛细管，健康的肉肉在土里，根系越发达，吸收的水分和养分就越多，自然长得好，然而如果经过了脱盆及运输，<strong>由于生长环境的变化，毛细根会损坏和枯死</strong>，如果我们不加以修理就直接种下，这些枯死的毛细根就成了绊脚石，像一根根堵塞的吸管，<strong>没有办法运输养分，还徒增了“肺”的负担</strong>。就好比一个本来就虚弱的人，用了5000的肺活量使劲吸水，但由于吸管又多又堵，不但只吸到了很少的水，还平白消耗了巨大的能量。因此，但凡肉肉到我手上，我都会为它们修根。</p><p><strong>修根其实很简单，就是用手揪，把繁杂的毛细根都揪掉</strong>，有时为了迎合花盆大小或给肉肉重新塑型(比如杆子太长)，我还会把部分侧根也揪掉，甚至整个根都揪掉，这样不仅可以<em>刺激肉肉生根激素的分泌</em>，还更容易上盆，一插了事。</p><blockquote><p>一般来说修根我会修到这种程度<br><img src="https://www.drlmeng.com/wp-content/uploads/2018/03/feifei-12.jpg" alt="多肉修根"></p></blockquote><p>如果你修根修狠了，不小心把主根给拔断了也没关系，就当是给它们砍个头，重新发根无压力。</p><h4><span id="多肉养肥的第二步服盆"><strong>多肉养肥的第二步:服盆</strong></span></h4><p>数数大约<strong>七天</strong>了，就把盆里的土扒拉扒拉，露半截根出来，看<strong>长没长新根</strong>，如果长了，就轻轻把土盖回去，如果没见着，就全部扯出来，看到底长没长，然后再种回去(因为之前我修根比较彻底，肉肉基本就一杆子，所以拔和埋也就几秒钟的事)。这种方法比较暴力，很多肉友都不提倡，但患强迫症的我却一直是这么做的。这样会损伤到新长的嫩根是没错，但只要植株启动了长根机制，那损失的一点嫩根，一两天就又长回来了，无妨。当然拔的时候动作一定要轻，另外不可天天拔出来看，大约一周一次，直至确定长根了就不要再拔了。</p><p>因为只有长了根的肉肉才有吸水能力，如果<strong>肉肉没有长根，就不可给水</strong>，是的，一点水也不给，无论它看上去有多可怜，否则容易烂根。一旦确定长根了，就可以适当给水，但不能频繁浇水，否则肉肉只能活，而不好胖。</p><h4><span id="多肉养肥的第三步浇水"><strong>多肉养肥的第三步:浇水</strong></span></h4><p><strong>浇水是肥肉养成的关键</strong>。当你确定一定以及肯定你的肉已经成功发根的情况下，可以适当给水，所谓适当，是指<strong>水少+次数少</strong>，过个<em>十天半个月</em>，用手抓抓植株向上轻提，感觉到明显抓力了，那就恭喜你，可以开始炼肥肉了。炼肥肉的秘诀在于管住你的手，不要心血来潮突然爱它们了，就给一瓢水，也不要因为你自己觉得渴，就臆想肉肉们也渴，又给一瓢水，也不要因为你曾经隔两天浇一次水，持续了两个月，肉肉们奇迹般的没有挂，所以就想给水就给水……因为这些小动作或许不会要了肉肉的命，却很难将它们养肥。养肥肉是要遵守原则的，那就是<strong>尽量把浇水间隔拉长，只在它们最最渴望的时候给水，而且要就滴水不给，要给就给得透透的</strong>，为何久旱逢甘霖会那么快乐，估计就是如此吧。如何判断它们何时最最渴望水呢？不用插牙签，也不用敲盆壁，只需<strong>算时间+捏叶子，大约有个把礼拜没浇水了，并且原来坚挺的叶子，现在软趴趴了(必须两者同时满足)</strong>，那么就可以来一场酣畅淋漓的大水，直到浇透为止(以上经验<em>只针对在生长季的有健康根系的肉肉</em>有效)。通过这样的给水方式，肉肉一个多月就可以慢慢肥起来了。</p><hr><h3><span id="分身">分身</span></h3><blockquote><p>让多肉变成多头的办法主要有砍头法、摘心法以及拔叶法，不过不管哪一种办法，建议大家把多肉养大一点再进行，不要贪快哦。</p></blockquote><h4><span id="砍头法">砍头法</span></h4><p>用剪刀剪断盆栽的中部，使其与本株分离，将剪下来的盆栽放到<strong>阴凉通风的地方晾干个两三天</strong>，让伤口部分晾干出<strong>白色的一层壳</strong>，就可以拿去花盆里种了(叶插)。</p><h4><span id="摘心法">摘心法</span></h4><p>摘除多肉的<strong>顶尖头</strong>，这也是一个多肉变多头的办法。</p><h4><span id="拔叶法叶插法">拔叶法(叶插法)</span></h4><blockquote><p>想要达到90%以上的发芽率首先必须是在通风的环境，其次要有充足的散射光，温度需要在10-30度，如果一直保持在13-25度，那么发芽率将会更高。</p></blockquote><h5><span id="季节">季节</span></h5><p>叶插的季节一般选择春季和秋季为宜，因为这两个季节肉肉处于生长阶段。</p><h5><span id="叶片选择">叶片选择</span></h5><blockquote><p>千万不要硬摘</p></blockquote><p>叶片要尽量选择<strong>生长健康、成熟饱满</strong>的叶子，像刚生长出来的新叶子、有病虫害的叶子都是不行的。选好叶片后，将叶片从母体上摘下来，<strong>捏住叶片，左右摇晃</strong>几下就会很轻松的将叶片摘下。将摘下的叶片放到<strong>有阳光的地方静置一两个小时</strong>，让伤口部分晾干出<strong>白色的一层壳</strong>，目的是让叶片根部的破口自动愈合，防止化水腐烂。</p><h5><span id="叶插">叶插</span></h5><p>将选好的叶片正面朝上（就是<strong>叶子在母体上生长的方向</strong>）摆在准备好的花土上即可，就像在野外叶子自然掉落那样，<strong>不要刻意将叶子往土里插</strong>。接下来就是将叶插的花盆放到阴凉或散光通风处静静等待叶片生根发芽了。这期间不要把叶片拿起来看有没有生根发芽,<strong>第一个月是不需要浇水的，只需要静静地等待叶子生根发芽就可以了</strong>。如果花土干燥了，可以滴一些水在土上，不要浇到叶片上，浇水也不要过频，防止叶片腐烂。</p><h5><span id="新芽养护">新芽养护</span></h5><p>不同种类的多肉叶插生根出芽的时间也不一样，像<strong>艾伦、白牡丹</strong>这类很见长的，大概<strong>一周至十天</strong>左右就能生根发芽；像奥普琳娜这样的“老顽固”，也许要等上两三个月。当然，有些叶片是先生根再发芽，有些叶片是先发芽再生根，这个都是没有问题的。</p><p>当新芽长到一定程度大，母体叶子就会变皱化水干枯，这时候就可以小心翼翼的将<strong>母体叶子从根部剪掉</strong>，将新的肉芽移栽到其他盆里了</p><p>一个月后当<strong>明显看到根系已经稳固的扎入土</strong>中就可以适当浇水了</p><h6><span id="切接">切接</span></h6><p><a href="https://www.drlmeng.com/qiejie.html" target="_blank" rel="noopener">https://www.drlmeng.com/qiejie.html</a></p><hr><p>资料来源：</p><p> <a href="https://www.drlmeng.com/yangfei.html" target="_blank" rel="noopener">https://www.drlmeng.com/yangfei.html</a></p><p><a href="https://baijiahao.baidu.com/s?id=1595730040993683919&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">https://baijiahao.baidu.com/s?id=1595730040993683919&amp;wfr=spider&amp;for=pc</a></p><p><a href="https://baijiahao.baidu.com/s?id=1556146387021977&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">https://baijiahao.baidu.com/s?id=1556146387021977&amp;wfr=spider&amp;for=pc</a></p>]]></content>
      
      
      <categories>
          
          <category> 娱乐 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 植物 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《我的第一本算法书》知识总结</title>
      <link href="2018/12/05/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E6%9C%AC%E7%AE%97%E6%B3%95%E4%B9%A6%E9%87%8D%E7%82%B9%E6%80%BB%E7%BB%93/"/>
      <url>2018/12/05/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E6%9C%AC%E7%AE%97%E6%B3%95%E4%B9%A6%E9%87%8D%E7%82%B9%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2><span id="安全算法">安全算法</span></h2><h3><span id="概论">概论</span></h3><h4><span id="用互联网传输数据时可能会发生的四个主要问题">用互联网传输数据时可能会发生的四个主要问题</span></h4><p>1.窃听：</p><p>A向B发送的消息在传输途中被X偷看</p><p>2.假冒：</p><p>A以为向B发送了信息，但B可能是X冒充的</p><p>B以为A收到了信息，A可能是X冒充的</p><p>3.篡改:</p><p>B确实收到了A发送的信息，但可能在途中被X篡改或者数据在传输过程中损坏</p><p>4.事后否认：</p><p>B从A那里收到了消息，但作为消息发送者A对B抱有恶意，在事后称”这不是我发送的消息”，这种情况会使互联网上的商业交易或合同签署无法成立</p><h4><span id="解决这些问题的安全技术">解决这些问题的安全技术</span></h4><table><thead><tr><th>问题</th><th>解决方法</th></tr></thead><tbody><tr><td>窃听</td><td>加密</td></tr><tr><td>假冒</td><td>消息认证码or数字签名</td></tr><tr><td>篡改</td><td>消息认证码or数字签名</td></tr><tr><td>事后否认</td><td>数字签名</td></tr></tbody></table><hr><blockquote><p>加密方法分为两种：加密和解密都使用相同密钥的”<strong>共享密钥加密</strong>“，分别使用不同密钥加密的”<strong>公开密钥加密</strong>“</p></blockquote><h3><span id="共享密钥加密">共享密钥加密</span></h3><p>A使用密钥将数据加密，然后将密钥和密文发送给B，B再使用相同密钥解密得到数据。</p><h4><span id="优点">优点</span></h4><ol><li>解密速度相对较快</li></ol><h4><span id="问题">问题</span></h4><p>1.密钥和密文都有被第三者窃听的风险：</p><p>解决方法：使用公开密钥加密或迪菲-赫尔曼密钥交换方法使密钥安全送出</p><p>2.篡改</p><p>解决方法：消息认证码</p><p>3.事后否认</p><p>解决方法：数字签名</p><p>4.无法确定信息的发送者（中间人攻击）</p><p>解决方法：数字证书</p><p>5.密钥的需求数量会随着发送人数的增多而急剧增多，5个人要10个，100个人要4950(n(n-1)/2)个</p><h3><span id="公开密钥加密">公开密钥加密</span></h3><p>公开密钥加密是加密和解密使用不同密钥的一种加密方法，由于使用密钥的不同，这种算法也被称为<strong>“非对称加密”</strong>。加密使用的密钥叫做”公开密钥”，解密用的叫做“私有密钥”，由<strong>接收方</strong>生成公开密钥和私有密钥。</p><h4><span id="优点">优点</span></h4><ol><li>即使X窃听了A发送给B的密文和公开密钥，依旧无法解密，安全性更高</li><li>多个人给一个人传输数据时可以把公开密钥放在网上，比较方便，且需要的密钥数量较小。</li></ol><h4><span id="缺点">缺点</span></h4><p>1.公开密钥可靠性问题：当A把公开密钥发送给B时，被X的公开密钥掉包，由于公开密钥无法显示自己是由谁生成的，所以A和B不会发现自己收到的公开密钥已经被人替换，此时当B向A发送用X的公开密钥加密后的密文时，X可以窃听此密文，然后用自己X的私钥进行解密得到数据。这种通过<strong>中途替换公开密钥来攻击的方法叫做”中间人攻击”</strong></p><p>解决方法：数字证书</p><p>2.公开密钥的加密和解密都比较耗时，所以这种方法不适用发送零碎数据的方法</p><p>解决方法：混合加密</p><p>3.篡改</p><p>解决方法：消息认证码</p><p>4.事后否认</p><p>解决方法：数字签名</p><p>5.无法确定信息的发送者（中间人攻击）</p><p>解决方法：数字证书</p><h3><span id="混合加密">混合加密</span></h3><p>发送消息者使用<strong>共享密钥</strong>对<strong>数据</strong>进行加密(共享密钥的<em>加密</em>速度加快)，然后使用<strong>公开密钥</strong>对<strong>共享密钥</strong>进行加密。</p><p>接收消息者用<strong>私有密钥</strong>对<strong>共享密钥</strong>进行解密，然后用共享密钥对数据进行解密(共享密钥的<em>解密</em>速度加快)。</p><h4><span id="优点">优点</span></h4><blockquote><p>在安全性和处理速度上都有优势</p></blockquote><h4><span id="缺点">缺点</span></h4><p>1.中间人攻击：</p><p>解决方法：数字证书</p><p>3.篡改</p><p>解决方法：消息认证码</p><p>4.事后否认</p><p>解决方法：数字签名</p><h3><span id="迪菲-赫尔曼密钥交换">迪菲-赫尔曼密钥交换</span></h3><h4><span id="原理">原理</span></h4><p>P和S两个密钥可以通过一种方法合成密钥P-S</p><h5><span id="特点">特点</span></h5><ol><li>只能合成，密钥P-S不能分解成P和S</li><li>合成后的密钥可以继续作为新的元素与别的密钥进行合成</li><li>密钥的合成结果与合成顺序无关，只与用了哪些密钥有关，比如密钥A-B-C和密钥B-A-C是一样的。</li></ol><h4><span id="过程">过程</span></h4><p>由A生成密钥P，A把密钥P发送给B，A和B各自用自己的私有密钥SA,SB生成PSA,PSB，A将密钥PSA发送给B，B也将密钥PSB发送给A，A和B利用私有密钥PSA,PSB合成PSBSA，<em>PSBSA这个密钥将作为”加密密钥“和”解密密钥“</em>来使用。在此过程中，即使X窃听到了所有过程中传输的密钥，<strong>由于他没有A和B的私有密钥</strong>，无法合成最后的密钥PSBSA。</p><h4><span id="用数学表示这种密钥交换法">用数学表示这种密钥交换法</span></h4><p>公开密钥P用<em>P,G</em>两个整数来表示，<em>P</em>是一个非常大的素数，<em>G</em>是素数<em>P</em>对应的生成元或其中一个。</p><p>首先,A准备素数<em>P</em>和生成元<em>G</em>，这两个数公开也没有关系，然后A将这两个数发送给B。接下来A和B各自准备秘密数字X和Y，X和Y都必须小于<em>P</em>-2。A和B分别计算（G的各自秘密数字(x/y)次方)mod <em>P</em>，此处的运算等同于概念意义上的<strong>合成</strong>，A和B将各自的计算结果发给对方，A和B收到对方的计算结果后，先计算这个值的秘密数字次方，然后再mod  <em>P</em>，最后A和B会得到相同的结果。</p><h3><span id="优点">优点</span></h3><p>安全性：使用迪菲-赫尔曼密钥交换，通信双方仅通过交换一些公开信息就可以实现密钥交换，但实际上双方并没有交换密钥，而是生成了密钥。该方法又被叫做”迪菲-赫尔曼密钥协议”</p><h3><span id="缺点">缺点</span></h3><p>1.中间人攻击：</p><p>解决方法：数字证书</p><p>2.篡改</p><p>解决方法：消息认证码</p><p>3.事后否认</p><p>解决方法：数字签名</p><h3><span id="消息认证码">消息认证码</span></h3><p>消息认证码可以实现”认证”和”检测篡改”两个功能。</p><p>A生成一个用于制作消息认证码的密钥，然后使用<strong>安全方法</strong>将密钥发送给B，然后A用密钥和密文生成一个值，这个值就是消息认证码(简称MAC)，我们可以把这个值想象成哈希值，然后A将MAC和密文一起发送给B，B也需要使用密钥生成MAC，若两个MAC相同，则消息没有篡改。</p><h4><span id="优点">优点</span></h4><p>即使X为了让他对密文的篡改得合理而篡改了MAC，因为X没有计算MAC的密钥，无法使篡改后的MAC变的合理，只要B计算出MAC值发现不同就可以确认发生的篡改。</p><h4><span id="缺点">缺点</span></h4><p>1.AB双方都可以对消息加密并且算出MAC，无法证明原本的信息是A发送的还是B发送的，即事后否认问题</p><p>解决方法：数字签名</p><p>2.中间人攻击</p><p>解决方法：数字证书</p><h3><span id="数字签名">数字签名</span></h3><p>数字签名只有发信者才可以产生，因此使用他就能确定谁是消息的发送者。</p><p>A将公开密钥发送给B，A使用<strong>私有密钥加密消息</strong>，用公有密钥加密数据，私有密钥加密后的消息就是数字签名，A将数据，消息和签名都发送给B，B使用公开密钥对签名密文进行解密，用私有密钥对数据进行解密，对解密后的签名进行确认，如果一致就是A发送的。</p><blockquote><p>公开密钥的加密和解密都比较耗时，为了节约运算时间，实际上不会对消息直接进行加密，而是先求得消息的哈希值再对哈希值进行加密，然后将其作为签名进行使用。</p></blockquote><h4><span id="优点">优点</span></h4><p><em>只能由持有私有密钥的A来加密，但只要由公开密钥，谁都可以解开的密文</em>作为密码没有任何意义，但从另一个角度讲，他可以保证密文的制作者只能是A，并且由于B只有公开密钥无法生成A的签名，预防了事后否认的问题</p><blockquote><p>不是所有的公开密钥加密具有这个性质，但RSA加密算法是可以的</p></blockquote><h4><span id="缺点">缺点</span></h4><p>2.中间人攻击</p><p>解决方法：数字证书</p><h3><span id="数字证书">数字证书</span></h3><p>防止中间者攻击，保证公开密钥的正确性。</p><p>A有公开密钥PA和私有密钥SA，现在想将公开密钥发送给B，首先他需要向认证中心（CA）申请发行证书证明密钥确实由A自己生成，认证中心保管着他们自己的PC和SC，A将PA和包含邮箱信息的个人资料发送给认证中心，认证中心进行确认后用私有密钥SC对A的资料进行数字签名，然后将数字签名和资料放进同一个文件中，把这个文件发送给A，这个文件就是A的数字证书。A将作为公开密钥的数字证书发送给B，B收到数字证书后<strong>确认证书里的邮件地址确实是A的地址</strong>，然后B获取认证中心CA 的公开密钥PC对证书内的签名进行校验，判断他是否为认证中心给出的签名，最后再从证书中取得PA。</p><h4><span id="优点">优点</span></h4><p>由于X没有A的邮箱地址，无法获得A的证书。</p><h4><span id="可能存在的缺点">可能存在的缺点</span></h4><p>B得到的公开密钥Pc可能不是来自认证中心，X可能冒充认证中心。但认证中心的公开密钥也是以数字证书的形式交付的，会有更高级别的认证中心(最高的是根认证中心RCA)对这个认证中心进行署名，类似树形结构。</p><blockquote><p>交付公开密钥不只存在于个人与个人之间，他还存在于网站之间的通信，用于网站通信的证书叫做”服务器证书“，服务器证书与域名信息相对于，就像个人的证书会与他的邮箱信息相对应一样。</p><p>数字证书就像这样通过认证中心来担保公开密钥的制作者。这一系列技术规范被称为”公钥基础设施“（PKI）</p></blockquote><h2><span id="聚类">聚类</span></h2><p>聚类就是在输入为多个数时，将<strong>相似</strong>的数据分为一组的操作，1各组叫1个蔟。</p><p>根据数据类型的不同，定义该数据是否相似的标准也不同，具体来说，是要根据两个数据之间的<strong>差距</strong>来定义，可以用两点间的之前距离来表示差距（距离的定义方法有很多）</p><p>在定义好数据间的差距之后，聚类的方法根据设定的条件（如蔟的数量和每个蔟的数据量）也有很多种。其中最基本最有代表性的聚类算法是”K-means“算法。</p><h3><span id="k-means算法">K-means算法</span></h3><p>根据事先给定的蔟的数量进行聚类。</p><blockquote><p>随机选择三个点最为蔟的中心点，计算各个数据分别和三个中心点的哪一个点最接近，将数据分到相应的蔟中，这样，就完成了第一次聚类。然后计算各个蔟的重心，将蔟的中心点移到这个位置，安照以上步骤重新进行聚类，不断重复前面的步骤直到中心点不再发生变化位置。</p></blockquote><blockquote><p>如果设定的数据不合理，运行的结果可能不符合我们的需求，因此可以事先对数据进行分析推算出一个合适的数量，并且即使蔟的数量相同，如果随机设置的最初的中心点最初的位置不同，聚类的结果也会发生变化，因此我们可以通过改变随机设定的中心点位置来不断尝试k-means算法，从中选择最合适的聚类结果。</p></blockquote><h3><span id="层次聚类算法">层次聚类算法</span></h3><p>一开始每个数据都自成一类，不需事先给定蔟的数量。</p><blockquote><p>在一开始有n个数据会形成n个蔟，然后重复执行“将距离最近的两个蔟合并成一个”，这样的操作重复n-1次，没执行一次，蔟就会减少一个，执行n-1次后，所有数据都被分到了一个蔟之中。在这个过程中，每个阶段的蔟的数量都不同，对应的聚类结果也不同，只要从中选择最为合理的一个结果即可。</p></blockquote><h2><span id="比较">比较</span></h2><table><thead><tr><th>数据结构</th><th>二叉树</th><th>堆</th></tr></thead><tbody><tr><td>特点</td><td>每个结点的值大于其左子树任意一个结点的值，小于其右子树任意一个结点的值</td><td>父结点大于子节结点</td></tr><tr><td>查找</td><td>从顶端开始不断与顶点大小进行比以决定往左还是往右寻找</td><td>最上面的顶点是<strong>最小</strong></td></tr><tr><td>添加</td><td>从顶点开始，不停与结点比较决定是往左移还是往右移</td><td>往右下添加数据，如果一行满了就新起一行加在最左端，最后再不断与父结点比较以决定是否往上移</td></tr><tr><td>删除（有子节点）</td><td>在被删除的子树上寻找最大结点然后将最大结点往上移到被删除的节点位置上，如果移动的节点还有子节点就递归执行前面的操作。</td><td>根据堆的特点进行操作</td></tr><tr><td>优势</td><td>如果树的形状较为均衡，比较大小和移动的次数最多为logn（树的高度）</td><td>在不断需要计算最小值的算法中可以优化时间复杂度，如排序。</td></tr></tbody></table><blockquote><ul><li>树删除有节点的子树移动右子树的最小节点也没问题，只需要保持树的特点就行。</li><li>有很多以二叉查找树为基础扩展的树形结构，如平衡二叉查找树，另外，节点数可以自己设定。</li><li>在堆中，无论数据量多大，取出最小值的时间复杂度为O(1)，在取出之后需要将最后的数据移到最顶端，然后比较他与子节点的数据一边往下移动，所以取出数据需要的运行时间与树的高度成正比，由于树的高度为logn，所以重构树的时间复杂度为logn</li><li>在此列表中的前提是每个结点都不相同</li></ul></blockquote><hr><table><thead><tr><th>图的遍历</th><th>广度优先</th><th>深度优先</th></tr></thead><tbody><tr><td>特点</td><td>从起点开始顺着边搜索直到达到指定顶点</td><td>沿着一条路径不断向下直到不能继续为止再折返</td></tr><tr><td><strong>选哪一个顶点作为下一个顶点的基准</strong></td><td>离起点最近的顶点（FIFO)</td><td>最新成为候补的顶点（LIFO）</td></tr><tr><td>数据结构</td><td>队列</td><td>栈</td></tr><tr><td>思想</td><td></td><td>递归</td></tr></tbody></table><blockquote><ul><li>有闭环的图算法也是一样的</li></ul></blockquote><hr><table><thead><tr><th>排序</th><th>冒泡</th><th>选择</th><th>插入</th><th>堆</th></tr></thead><tbody><tr><td>时间复杂度(最糟糕的情况下)</td><td>n^2^/2=O(n^2^)</td><td>n^2^/2=O(n^2^)</td><td>n^2^/2=O(n^2^)</td><td>O(nlogn)</td></tr><tr><td>简单解释</td><td>从左至右不断进行数字比较和交换（两个for循环），将最大的数一个个依次滚动到最后</td><td>使用线性查找每次找出最小值然后与第一个位置进行交换，依次类推</td><td>假设最左已排好序，从未排好序区域（除最左以外的区域）与排好序的区域进行比较往左插入，依次类推。最糟糕的情况是要将数据从小到大排序时，输入数据是从大到小的。</td><td>一开始需要将n个数据存进堆里，时间复杂度为O(nlogn)【重构一次要O(logn)，需要重构n次】每次取出最大的数据并重构dO(logn)</td></tr></tbody></table><blockquote><ul><li>堆排序其实相当于把堆嵌入到包含序列的数组中，强行在数组中使用了堆结构</li></ul></blockquote><blockquote><ul><li>快速排序和归并的复杂度也是O(nlogn)</li><li>归并分割序列花费的时间不算在运行时间内(当作序列本来就是分割好的)，在合并两个已排好的序列中，只需重复比较首位数据的大小，然后移动较小的数据，因此只需花费和两个子序列相应的运行时间，完成一行归并所需的运行时间取决于这一行的数据量。设每一行的数据量为n，对半分割后可分成logn行，每行要比较n次</li><li>快速排序中可用到递归思想，不断选取基准点，将基准点小的往左移大的往右移直到只有1个数或者0个数或者以排完序不需要移动为止</li></ul></blockquote><hr><h2><span id="网页排名佩奇排名">网页排名（佩奇排名）</span></h2><p>以前的搜索引擎是根据关键词和网页内容的关联性来决定搜索结果的排列，这种方法没有考虑网页是否含有效内容，因此搜索精度较低。</p><p>而网页排名是利用网页之间的链接结构算出网页价值的算法，<em>有链入页面的网页权重是其链入页面的权重之和，如果一个网页链向多个页面，那么其链向的所有页面将平分他的权重</em>，在网页排名中链入的页面越多则其价值就越高。</p><blockquote><p>但出现环状的链接结构的情况下呢？</p></blockquote><blockquote><p>使用随机游走模型，假设有一个人在随机浏览网页，根据他的浏览计算每个网页的浏览概率，并将其概率当成网页的权重来使用</p></blockquote><blockquote><p>用游走模型计算的加权结果和网页排名算出来的值几乎是一样的。</p><p>事实上 一般不会用模拟而用更高效的算法来计算，但无论使用哪种计算，计算结果几乎都是相同的。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阅读总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c里的静态变量只初始化一次的原因</title>
      <link href="2018/12/03/c%E9%87%8C%E7%9A%84%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%8F%AA%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%80%E6%AC%A1%E7%9A%84%E5%8E%9F%E5%9B%A0/"/>
      <url>2018/12/03/c%E9%87%8C%E7%9A%84%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%8F%AA%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%80%E6%AC%A1%E7%9A%84%E5%8E%9F%E5%9B%A0/</url>
      
        <content type="html"><![CDATA[<h2><span id="c里的静态变量只初始化一次的原因">c里的静态变量只初始化一次的原因</span></h2><blockquote><p>来源于百度：</p></blockquote><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"stdafx.h"</span></span><span class="token keyword">int</span> <span class="token function">_tmain</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> _TCHAR<span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> initNum <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">static</span> <span class="token keyword">int</span> n1 <span class="token operator">=</span> initNum<span class="token punctuation">;</span>n1<span class="token operator">++</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> n1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">[</span><span class="token operator">/</span>code<span class="token punctuation">]</span>输出结果：<span class="token number">4</span><span class="token number">5</span><span class="token number">6</span><span class="token number">7</span><span class="token number">8</span></code></pre><p>在这里我们可以看到虽然代码循环了5次，静态变量n1确实只初始化了一次。那么为什么呢？继续上代码，相信大家就会明白些许了。</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">_tmain</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> _TCHAR<span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> initNum <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">static</span> <span class="token keyword">int</span> n1 <span class="token operator">=</span> initNum<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//我们在这里了两句代码</span><span class="token keyword">int</span><span class="token operator">*</span> p <span class="token operator">=</span> <span class="token operator">&amp;</span>n1<span class="token punctuation">;</span>p<span class="token operator">++</span><span class="token punctuation">;</span><span class="token operator">*</span>p <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//end</span>n1<span class="token operator">++</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> n1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">[</span><span class="token operator">/</span>code<span class="token punctuation">]</span>输出结果：<span class="token number">4</span><span class="token number">4</span><span class="token number">4</span><span class="token number">4</span><span class="token number">4</span></code></pre><p>这次，静态变量居然跟随着5次循环也初始化了5次。你一定非常诧异，其实我们不难推断，其实<strong>静态变量就是通过静态变量后面的一个32位内存位来做记录，以标识这个静态变量是否已经初始化</strong>。而我们的p++;*p = 0;却每次都将这个值赋值为0，所以程序就一直认为n1一直没有被初始化过，并每次都初始化一次。看一下内存，就更明了了：<br>0x00E8716C 03 00 00 00 01 00 00 00 00 00 00 00 00 00 00 00 b0 e7 1e 6a 00 00 00<br>这里的内存地址就是静态变量n1的地址，值是3，后面还有一个1，你看到了吗，这个就是程序用来记录该静态变量是否初始化的标识位啦。现在你一定明白原理了，并且能轻松记住静态变量的特性了吧。<br>以上代码有一点需要说明：代码中之所以要用int initNum = 3;而不是直接用static int n1 = 3;是因为如果给静态变量直接赋值一个常量的话，编译器会进行优化，导致程序在一启动时，就初始化好了，不便于我们观察静态变量内存上的改变。</p>]]></content>
      
      
      <categories>
          
          <category> c </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 静态和动态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js的基本操作</title>
      <link href="2018/11/29/js/"/>
      <url>2018/11/29/js/</url>
      
        <content type="html"><![CDATA[<h2><span id="定义变量">定义变量</span></h2><h3><span id="声明">声明</span></h3><p>var <em>变量名</em>；</p><blockquote><p>即使不声明也可以使用，先声明后使用更规范</p></blockquote><h2><span id="定义函数">定义函数</span></h2><h3><span id="声明">声明</span></h3><p>function <em>函数名</em> {}</p><h3><span id="使用">使用</span></h3><p>函数名();</p><h2><span id="如何输出空格">如何输出空格</span></h2><p>在写JS代码的时候，大家可以会发现这样现象:</p><p><strong>document.write(“   1      2                3  “);</strong></p><p><strong>结果:</strong> <strong>1 2 3</strong></p><p>无论在输出的内容中什么位置有多少个空格，显示的结果好像只有一个空格。</p><p>这是因为浏览器显示机制，对手动敲入的空格，将连续多个空格显示成1个空格。</p><p><strong>解决方法:</strong></p><ol><li><p>使用输出html标签&nbsp;来解决</p><p><strong>document.write(“&nbsp;&nbsp;”+”1”+”&nbsp;&nbsp;&nbsp;&nbsp;”+”23”);</strong></p><p><strong>结果:</strong>  1    23</p></li><li><p>使用CSS样式来解决</p><p>document.write(“<span style="white-space:pre;">“+”  1        2    3    “+”</span>“);</p><p><strong>结果:</strong>  1       2     3    </p><p>在输出时添加“white-space:pre;”样式属性。这个样式表示”<strong>空白会被浏览器保留</strong>“</p></li></ol><h2><span id="输出">输出</span></h2><h3><span id="documentwrite">document.write();</span></h3><pre class=" language-js"><code class="language-js">输出多项内容，内容之间用<span class="token operator">+</span>号连接。<span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">"text/javascript"</span><span class="token operator">></span>  <span class="token keyword">var</span> mystr<span class="token operator">=</span><span class="token string">"hello"</span><span class="token punctuation">;</span>  document<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>mystr<span class="token operator">+</span><span class="token string">"I love JavaScript"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//多项内容之间用+号连接</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span></code></pre><pre class=" language-js"><code class="language-js">输出HTML标签，并起作用，标签使用<span class="token string">""</span>括起来。<span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">"text/javascript"</span><span class="token operator">></span>  <span class="token keyword">var</span> mystr<span class="token operator">=</span><span class="token string">"hello"</span><span class="token punctuation">;</span>document<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>mystr<span class="token operator">+</span><span class="token string">"&lt;br>"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//输出hello后，输出一个换行符</span>  document<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"JavaScript"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span></code></pre><h2><span id="alert">alert</span></h2><blockquote><p>alert弹出消息对话框(包含一个确定按钮)，并且<strong>按顺序弹出消息框</strong>。</p></blockquote><p><strong>注意:</strong></p><ol><li><p>在点击对话框”确定”按钮前，不能进行任何其它操作。</p></li><li><p>消息对话框通常可以用于调试程序。</p></li><li><p>alert输出内容，可以是字符串或变量，与document.write 相似。</p></li></ol><p><strong>语法:</strong></p><pre class=" language-js"><code class="language-js"><span class="token function">alert</span><span class="token punctuation">(</span>字符串或变量<span class="token punctuation">)</span><span class="token punctuation">;</span>  </code></pre><h2><span id="javascript-确认confirm-消息对话框">JavaScript-确认（confirm 消息对话框）</span></h2><blockquote><p>弹出对话框(包括一个确定按钮和一个取消按钮)</p></blockquote><p><strong>消息对话框是排它的，即用户在点击对话框按钮前，不能进行任何其它操作。</strong></p><p><strong>语法:</strong></p><pre><code>confirm(str);</code></pre><p><strong>参数说明:</strong></p><pre><code>str：在消息对话框中要显示的文本返回值: Boolean值</code></pre><p><strong>返回值:</strong></p><pre><code>当用户点击&quot;确定&quot;按钮时，返回true当用户点击&quot;取消&quot;按钮时，返回false</code></pre><p><strong>注:</strong> <strong>通过返回值可以判断用户点击了什么按钮</strong></p><h2><span id="javascript-提问prompt-消息对话框">JavaScript-提问（prompt 消息对话框）</span></h2><p><strong>prompt</strong>弹出消息对话框,通常用于询问一些需要与用户交互的信息。弹出消息对话框（包含一个确定按钮、取消按钮与一个文本输入框）。</p><p><strong>语法:</strong></p><pre><code>prompt(str1, str2);</code></pre><p><strong>参数说明：</strong></p><pre><code>str1: 要显示在消息对话框中的文本，不可修改str2：文本框中的内容，可以修改</code></pre><p><strong>返回值:</strong></p><pre><code>1. 点击确定按钮，文本框中的内容将作为函数返回值2. 点击取消按钮，将返回null</code></pre><h2><span id="javascript-打开新窗口windowopen">JavaScript-打开新窗口（window.open）</span></h2><p>open() 方法可以查找一个已经存在或者新建的浏览器窗口。</p><p><strong>语法：</strong></p><pre><code>window.open([URL], [窗口名称], [参数字符串])</code></pre><p><strong>参数说明:</strong></p><pre><code>URL：可选参数，在窗口中要显示网页的网址或路径。如果省略这个参数，或者它的值是空字符串，那么窗口就不显示任何文档。窗口名称：可选参数，被打开窗口的名称。    1.该名称由字母、数字和下划线字符组成。    2.&quot;_top&quot;、&quot;_blank&quot;、&quot;_self&quot;具有特殊意义的名称。       _blank：在新窗口显示目标网页       _self：在当前窗口显示目标网页       _top：框架网页中在上部窗口中显示目标网页   3.相同 name 的窗口只能创建一个，要想创建多个窗口则 name 不能相同。   4.name 不能包含有空格。参数字符串：可选参数，设置窗口参数，各参数用逗号隔开。</code></pre><p><strong>参数表:</strong></p><p><strong><img src="http://img.mukewang.com/52e3677900013d6a05020261.jpg" alt="img"></strong></p><p>例如:打开<a href="http://www.imooc.com网站，大小为300px" target="_blank" rel="noopener">http://www.imooc.com网站，大小为300px</a> * 200px，无菜单，无工具栏，无状态栏，有滚动条窗口：</p><pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">"text/javascript"</span><span class="token operator">></span> window<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">'http://www.imooc.com'</span><span class="token punctuation">,</span><span class="token string">'_blank'</span><span class="token punctuation">,</span><span class="token string">'width=300,height=200,menubar=no,toolbar=no, status=no,scrollbars=yes'</span><span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span></code></pre><p><strong>注意：</strong>运行结果考虑浏览器兼容问题。</p><h2><span id="javascript-关闭窗口windowclose">JavaScript-关闭窗口（window.close）</span></h2><p>close()关闭窗口</p><p><strong>用法：</strong></p><pre><code>window.close();   //关闭本窗口(暂时不知道怎么用)</code></pre><p>或</p><pre><code>&lt;窗口对象&gt;.close();   //关闭指定的窗口</code></pre><p>例如:关闭新建的窗口。</p><pre><code>&lt;script type=&quot;text/javascript&quot;&gt;   var mywin=window.open(&#39;http://www.imooc.com&#39;); //将新打的窗口对象，存储在变量mywin中   mywin.close();&lt;/script&gt;</code></pre><p><strong>注意:上面代码在打开新窗口的同时，关闭该窗口，看不到被打开的窗口。</strong></p><h2><span id="认识dom">认识DOM</span></h2><p>文档对象模型DOM（Document Object Model）定义访问和处理HTML文档的标准方法。DOM 将HTML文档呈现为带有元素、属性和文本的树结构（节点树）。</p><p><strong>先来看看下面代码:</strong></p><p><strong><img src="http://img.mukewang.com/52e4be610001c67307860420.jpg" alt="img"></strong></p><p><strong>将HTML代码分解为DOM</strong> <em>节点层次图:</em></p><p><strong><img src="http://img.mukewang.com/52e4bd0f0001dd8d04830279.jpg" alt="img"></strong></p><p><strong>HTML文档可以说由节点构成的集合，三种常见的DOM节点:</strong></p><p><strong>1. 元素节点：</strong>上图中<html>、<body>、<p>等都是元素节点，即标签。</p><p><strong>2. 文本节点:</strong>向用户展示的内容，如<li>…</li>中的JavaScript、DOM、CSS等文本。</p><p><strong>3. 属性节点:</strong>元素属性，如<a>标签的链接属性href=”<a href="http://www.imooc.com&quot;。" target="_blank" rel="noopener">http://www.imooc.com&quot;。</a></a></p><p><strong>看下面代码:</strong></p><pre><code>&lt;a href=&quot;http://www.imooc.com&quot;&gt;JavaScript DOM&lt;/a&gt;</code></pre><p><a href="http://img.mukewang.com/52e4bdb80001064c04480196.jpg" target="_blank" rel="noopener"><img src="http://img.mukewang.com/52e4bdb80001064c04480196.jpg" alt="img"></a></p><h3><span id="id">id</span></h3><p>学过HTML/CSS样式，都知道，网页由标签将信息组织起来，而标签的id属性值是唯一的，就像是每人有一个身份证号一样，只要通过身份证号就可以找到相对应的人。那么在网页中，我们通过id先找到标签，然后进行操作。</p><p><strong>语法:</strong></p><pre><code> document.getElementById(“id”) </code></pre><p><strong>看看下面代码:</strong></p><p><strong><img src="http://img.mukewang.com/52e4c5950001054207900423.jpg" alt="img"></strong></p><p><strong>结果:null</strong> <strong>或[object HTMLParagraphElement]</strong></p><p><strong><img src="http://img.mukewang.com/52e4c6080001734c03800275.jpg" alt="img"></strong></p><p><strong>注:获取的元素是一个对象，如想对元素进行操作，我们要通过它的属性或方法。</strong></p><h2><span id="innerhtml-属性">innerHTML 属性</span></h2><p>innerHTML 属性用于获取或替换 HTML 元素的内容。</p><p><strong>语法:</strong></p><pre><code>Object.innerHTML</code></pre><p><strong>注意:</strong></p><p>1.Object是获取的元素对象，如通过document.getElementById(“ID”)获取的元素。</p><p>2.注意书写，innerHTML区分大小写。</p><p>3.输出方式</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> mychar <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"con"</span><span class="token punctuation">)</span>document<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>mychar<span class="token punctuation">)</span><span class="token punctuation">;</span>document<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>mychar<span class="token punctuation">.</span>innerHTML<span class="token punctuation">)</span></code></pre><blockquote><p>两种输出方式的结果是不一样的，第一个可能输出[obiect HTMLHeadingElemrnt],第二个可能输出标题内容</p></blockquote><h2><span id="改变-html-元素的样式">改变 HTML 元素的样式</span></h2><p><strong>语法:</strong></p><pre><code>Object.style.property=new style;</code></pre><p><strong>注意:</strong>Object是获取的元素对象，如通过document.getElementById(“id”)获取的元素。</p><p><strong>基本属性表（property）:</strong></p><p><strong><img src="http://img.mukewang.com/52e4d4240001dd6c04850229.jpg" alt="img"></strong></p><p><strong>注意:</strong>该表只是一小部分CSS样式属性，其它样式也可以通过该方法设置和修改。</p><h4><span id="例子">例子</span></h4><p>改变 </p><p> 元素的样式，将颜色改为红色，字号改为20,背景颜色改为蓝：</p><pre><code>&lt;p id=&quot;pcon&quot;&gt;Hello World!&lt;/p&gt;&lt;script&gt;   var mychar = document.getElementById(&quot;pcon&quot;);   mychar.style.color=&quot;red&quot;;   mychar.style.fontSize=&quot;20&quot;;   mychar.style.backgroundColor =&quot;blue&quot;;&lt;/script&gt;</code></pre><h2><span id="display属性">display属性</span></h2><blockquote><p>显示和隐藏</p></blockquote><p><strong>语法：</strong></p><pre><code>Object.style.display = value</code></pre><p><strong>注意:</strong>Object是获取的元素对象，如通过document.getElementById(“id”)获取的元素。</p><p><strong>value取值</strong>:</p><p><strong><img src="http://img.mukewang.com/52e4dba5000179da04110095.jpg" alt="img"></strong></p><p><strong>看看下面代码:</strong></p><p><img src="http://img.mukewang.com/52e4dcf50001bead09310689.jpg" alt="img"></p><h2><span id="控制类名classname-属性">控制类名（className 属性）</span></h2><p>className 属性设置或返回元素的class 属性。</p><p><strong>语法：</strong></p><pre><code>object.className = classname</code></pre><p><strong>作用:</strong></p><p>1.获取元素的class 属性</p><p>2.为网页内的某个元素指定一个css样式来更改该元素的外观</p><p><strong>看看下面代码，获得 <p> 元素的 class 属性和改变className：</p></strong></p><p><a href="http://img.mukewang.com/52e4e28c0001c97f07980838.jpg" target="_blank" rel="noopener"><img src="http://img.mukewang.com/52e4e28c0001c97f07980838.jpg" alt="img"></a></p><p><strong>结果:</strong></p><p><strong><img src="http://img.mukewang.com/52e4e711000135d903810270.jpg" alt="img"></strong></p></body></html></p>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ruby的基础知识</title>
      <link href="2018/11/28/Ruby/"/>
      <url>2018/11/28/Ruby/</url>
      
        <content type="html"><![CDATA[<h1><span id="ruby">Ruby</span></h1><h3><span id="interpreted-vs-compiled">Interpreted vs Compiled</span></h3><p>Depending on the programming language you’re using, it will either be a <a href="http://en.wikipedia.org/wiki/Compiled_language" target="_blank" rel="noopener">compiled language</a> or an <a href="https://desk-fd.zol-img.com.cn/t_s960x600c5/g5/M00/0B/05/ChMkJlcgb6mIY7cbAAg5YZ7Q3FwAAQrzAAWO2sACDl5956.jpg[interpreted" target="_blank" rel="noopener">https://desk-fd.zol-img.com.cn/t_s960x600c5/g5/M00/0B/05/ChMkJlcgb6mIY7cbAAg5YZ7Q3FwAAQrzAAWO2sACDl5956.jpg[interpreted</a> language](<a href="http://en.wikipedia.org/wiki/Interpreted_language)" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Interpreted_language)</a>. <strong>Compiled</strong> programs will first be converted to machine code and then you will be able to run the program. <strong>Interpreted languages</strong> will be interpreted and converted to machine code <strong>at run time.</strong></p><h3><span id="putsampampprint">puts&amp;&amp;print</span></h3><p>you need to use the method <code>puts</code> which is short for “out<strong>put s</strong>tring.” And because Hello World! is a string, you need to surround your text with <code>&quot;&quot;</code>.</p><blockquote><p>both “” and ‘’  is ok</p></blockquote><h3><span id="differenece">differenece</span></h3><p>The primary difference between them is that <code>puts</code> <strong>adds a new line</strong> after executing, and <code>print</code> does not.</p><h3><span id="return">return</span></h3><blockquote><p>both of print and puts will return nil</p></blockquote><p><em>example</em></p><p>To both print and return your name, you could write:</p><pre><code>def print_and_return_name    puts &quot;Guy Fieri&quot;  &quot;Guy Fieri&quot;end</code></pre><p>There is one other way to return a value from a method and that is to use the <code>return</code> keyword.</p><p>Let’s take a look:</p><pre><code>def stylish_chef    best_hairstyle = &quot;Guy Fieri&quot;    return &quot;Martha Stewart&quot;    &quot;Guy Fieri&quot;end</code></pre><blockquote><p> it will just return the first value following <code>return</code></p></blockquote><h3><span id="sanitizing-user-input-the-strip-and-chomp-methods">Sanitizing User Input: The <code>strip</code> and <code>chomp</code> Methods</span></h3><p>One thing to know about the <code>#gets</code> method is that it captures a new line character at the end of whatever input it is storing. We don’t want extra whitespace or new lines to be appended to the user input we are trying to store. So, we can chain a call to the <code>#strip</code>method to remove any new lines or leading and trailing whitespace.</p><p>The <code>#chomp</code> method works similarly, and you are likely to see <code>#gets.chomp</code> used in some examples online. <strong>The <code>#chomp</code> method removes any new lines at the end of a string while the <code>#strip</code> method removes whitespace (leading and trailing) <em>and</em> new lines.</strong></p><h2><span id="irb">IRB</span></h2><h3><span id="what-is-irb">What is IRB?</span></h3><p>IRB stands for “Interactive Ruby.” It’s a Ruby shell or REPL.</p><h2><span id="how-do-you-use-it">How do you use it?</span></h2><p>IRB allows you to execute ruby in the terminal .To access IRB, just type <code>irb</code> in the terminal. IRB allows you to do anything you can do in a Ruby file.use exit to leave IRB.</p><hr><h2><span id="four-common-error-types">Four Common Error Types</span></h2><h3><span id="name-errors">Name Errors</span></h3><p>NameErrors are caused when a given name is invalid or undefined. Whenever the Ruby interpreter encounters a word it doesn’t recognize, it assumes that word is the name of a variable or a method. If that word was never defined as either a variable or a method, it will result in a name error.</p><h3><span id="syntax-errors">Syntax Errors</span></h3><p>Syntax errors are pretty self-explanatory: they’re the result of incorrect syntax. Thankfully, they’re usually followed by a guess about the location of the error. For instance:</p><pre><code>2.times do  puts &quot;hi&quot;</code></pre><p>Will result in:</p><pre><code>2: syntax error, unexpected end-of-input, expecting keyword_end</code></pre><p>Here, Ruby is saying that on line 2, there is a missing <code>end</code> (every <code>do</code> keyword must be followed by some code and then an <code>end</code> keyword). Always read the full details of syntax errors and look for line numbers, which usually appear at the beginning of the error message.</p><h3><span id="type-errors">Type Errors</span></h3><p>When you try and do a mathematical operation on two objects of a different type, you will receive a TypeError. For example if you try and add a string to an integer, Ruby will complain.</p><pre><code>1 + &quot;1&quot;</code></pre><p>Will produce the following error:</p><pre><code>TypeError: String can&#39;t be coerced into Fixnum</code></pre><h3><span id="division-errors">Division Errors</span></h3><p>DivisionErrors are caused when a given number is divided by 0.</p><hr><h2><span id="variable">variable</span></h2><p>Note: The syntax of <code>#{current_president}</code> simply injects the value of the variable <code>current_president</code> into the string. This is called <a href="http://stackoverflow.com/questions/10076579/string-concatenation-vs-interpolation-in-ruby" target="_blank" rel="noopener">Interpolation</a> .where you are simply adding together multiple strings.</p><blockquote><p>In Ruby, a variable can point to almost any type of value including numbers, strings, arrays, and hashes.</p></blockquote><blockquote><ul><li>Variable names should start with a lowercase letter. A variable that begins with an uppercase letter is known as a <strong>constant</strong> and has different characteristics.</li></ul></blockquote><blockquote><ul><li>There is strong convention among Rubyists to use what is known as <em>snake case</em> <code>this_is_an_example_of_snake_case</code> words are separated by underscores. </li></ul></blockquote><blockquote><ul><li>A Ruby variable cannot start with a number, be a Ruby reserved word, or have punctuation or space characters.</li></ul></blockquote><blockquote><ul><li>Ruby is what is known as a <em>dynamically typed</em> language. That means the value of a variable can change its type and does not need to be explicitly and permanently defined. </li></ul></blockquote><blockquote><ul><li>It is also a <em>strongly typed</em> language. This means a variable will never be automatically <em>coerced</em> to another type without you explicitly changing the type. </li></ul></blockquote><h4><span id="how-you-interpolate-variables-into-strings">How You Interpolate Variables into Strings</span></h4><p>To interpolate, you wrap the variable like <code>#{this}</code>.</p><h4><span id="another-way-to-interpolate-variables-into-strings">Another Way to Interpolate Variables into Strings</span></h4><p>Some Rubyists write this another way, like this:</p><pre><code>answer = &quot;Flamboyance&quot;puts &quot;A group of flamingos is called a &quot; + answer + &quot;.&quot;</code></pre><blockquote><p> Single quotes: <code>&#39;&#39;</code> <strong>do not support string interpolation</strong></p></blockquote><hr><h2><span id="ruby-data-types"><strong>Ruby Data Types</strong></span></h2><h3><span id="creating-strings">Creating Strings</span></h3><p>There are two ways to create a string. In fact, we’ve already created a string just by typing <code>&quot;hello&quot;</code>.</p><p>Try it out by opening up IRB, and typing <code>&quot;hello&quot;.class</code></p><p>You should see a return value of <code>=&gt; String</code>. You can actually call <code>.class</code> on any object to find out what type of data, i.e. what class, it is.</p><p><strong>The Literal Constructor:</strong> This is the method through which we created our “hello” string.</p><p><strong>The Class Constructor:</strong> You can also create a string with <code>String.new</code>. This will create an empty string.</p><p><code>String.new(&quot;hello&quot;)</code> on the other hand, will create this string: <code>&quot;hello&quot;</code>. For the most part, you will create strings using the first method discussed here––simply by enclosing whatever text you want in quotes.</p><p>Because every string is based on Ruby’s String class, there are certain behaviors, or methods, available to us for operating on them. You can learn more about the many String methods by reading the <a href="http://ruby-doc.org/core-2.2.0/String.html" target="_blank" rel="noopener">Ruby documentation</a> on Strings. For now, we’ll just take a look at a few examples.</p><pre><code>&quot;hello&quot;.size   =&gt; 5&quot;hello&quot;.upcase   =&gt; &quot;HELLO&quot;&quot;hello&quot;.reverse   =&gt; &quot;olleh&quot;</code></pre><h3><span id="booleans">Booleans</span></h3><p>There are only two values of the Boolean data type: <code>true</code> and <code>false</code>. In Ruby, however, there is no such thing as a Boolean class. <strong>Instead</strong>, every appearance, or instance, of <code>true</code> and <code>false</code> in your program are instances of TrueClass and FalseClass respectively.</p><blockquote><p>Unlike strings, there is not a way to create a Boolean value, other than to explicitly write <code>true</code> or <code>false</code>. Later, we will see that we can write lines of code that <em>evaluate to</em> or return <code>true</code> and <code>false</code>, </p></blockquote><p><strong>In Ruby only false and nil are falsey. Everything else is truthy (yes, even 0 is truthy).</strong></p><h4><span id="what-are-boolean-operators">What are Boolean Operators?</span></h4><p>Boolean operators are really methods which means that they have return values. What do they return? <code>true</code> or <code>false</code> of course!</p><p>In Ruby there are three main boolean operators:</p><ul><li><code>!</code> (“single-bang”) which represents “NOT”,</li><li><code>&amp;&amp;</code> (“double-ampersand”) which represents “AND”, and</li><li><code>||</code> (“double-pipe”) which represents “OR”</li></ul><h4><span id="comparison-operators">Comparison Operators</span></h4><table><thead><tr><th>Operator</th><th>Operation</th></tr></thead><tbody><tr><td><code>==</code></td><td>If the values of the two operands are <em>equal</em>, then the evaluation is <code>true</code>.</td></tr><tr><td><code>!=</code></td><td>If the values of the two operands are <em>not equal</em>, then the evaluation is <code>true</code>.</td></tr><tr><td><code>&gt;</code></td><td>If the value of the left operand is <em>greater than</em> the value of the right operand, then the evaluation is <code>true</code>.</td></tr><tr><td><code>&lt;</code></td><td>If the value of the left operand is less than the value of the right operand, then the evaluation is <code>true</code>.</td></tr><tr><td><code>&gt;=</code></td><td>If the value of the left operand is <em>greater than or equal to</em> the value of the right operand, then the evaluation is <code>true</code>.</td></tr><tr><td><code>&lt;=</code></td><td>If the left operand is <em>less than or equal to</em> the value of the right operand, then the evaluation is <code>true</code>.</td></tr></tbody></table><h3><span id="number">number</span></h3><p> You can read more about Fixnums <a href="http://ruby-doc.org/core-2.2.0/Fixnum.html" target="_blank" rel="noopener">here</a> and more about Floats <a href="http://ruby-doc.org/core-2.2.0/Float.html" target="_blank" rel="noopener">here</a>.</p><pre><code>7.5.floor  =&gt; this method will round the float down to the nearest fixnum. Here it will return 7 7.5.ceil  =&gt; 810.next  =&gt; 11</code></pre><blockquote><p>change: <code>&#39;5&#39;.to_i</code>.</p></blockquote><h3><span id="symbols">Symbols</span></h3><p>A symbol is a representation of a piece of data. Symbols look like this <code>:my_symbol</code>. If I make a symbol, <code>:my_symbol</code>, and then use that symbol later on in my code, my program will refer to the same area of memory in both cases. This is different from, for example, strings, which take up new areas of memory every time they are used.</p><blockquote><p>You write symbols by placing a <code>:</code> in front of the symbol name.</p><pre><code>:this_is_a_symbol</code></pre></blockquote><h2><span id="arrays">Arrays</span></h2><p>Arrays are collections of Ruby objects. You can store any type of data in an array.</p><p>There are a number of ways to create an array. Just like with creating strings, you can use the literal constructor or the class constructor.</p><p><strong>The Literal Constructor:</strong><code>[1, 3, 400, 7]</code> is an array of integers. Any set of comma separated data enclosed in brackets is an array. So, by simply writing something like the above, you can create an array.</p><p><strong>The Class Constructor:</strong> You can also create an array with the <a href="http://ruby-doc.org/core-2.2.0/Array.html" target="_blank" rel="noopener"><code>Array.new</code> syntax</a>. Just typing <code>Array.new</code> will create an empty array (<code>=&gt; []</code>).</p><p> For now, we’ll preview a few array methods, and you can check out more <a href="http://ruby-doc.org/core-2.2.0/Array.html" target="_blank" rel="noopener">here</a>.</p><pre><code>[5, 100, 234, 7, 2].sort   =&gt; [2, 5, 7, 100, 234][1, 2, 3].reverse  =&gt; [3, 2, 1]</code></pre><h3><span id="more-ways">more ways</span></h3><p>The shovel method employs the “shovel” operator <code>&lt;&lt;</code> and allows you to add (“shovel”) items onto the <strong>end</strong> of an array:</p><pre><code>famous_cats = [&quot;lil&#39; bub&quot;, &quot;grumpy cat&quot;, &quot;Maru&quot;] famous_cats &lt;&lt; &quot;nala cat&quot; famous_cats #=&gt; [&quot;lil&#39; bub&quot;, &quot;grumpy cat&quot;, &quot;Maru&quot;, &quot;nala cat&quot;]</code></pre><p>The shovel method <code>&lt;&lt;</code> is the preferred syntax for adding elements to an array, however you might see other methods used in examples online:</p><h4><span id="the-push-method">The <code>.push</code> Method</span></h4><p>Calling <code>.push</code> on an array with an argument of the element you wish to add to that array, will also add that element to the <strong>end</strong> of the array. It has the same effect as the shovel method explained above. However the <code>.push</code> will also let you add multiple elements to an array, whereas the shovel method will only add one element.</p><pre class=" language-ruby"><code class="language-ruby">famous_cats <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"lil' bub"</span><span class="token punctuation">,</span> <span class="token string">"grumpy cat"</span><span class="token punctuation">,</span> <span class="token string">"Maru"</span><span class="token punctuation">]</span> famous_cats<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">"nala cat"</span><span class="token punctuation">)</span> famous_cats <span class="token comment" spellcheck="true">#=> ["lil' bub", "grumpy cat", "Maru", "nala cat"]</span></code></pre><h4><span id="the-unshift-method">The <code>.unshift</code> Method</span></h4><p>To add an element to the <em>front</em> of an array, you can call the <code>.unshift</code> method on it with an argument of the element you wish to add:</p><pre><code>famous_cats = [&quot;lil&#39; bub&quot;, &quot;grumpy cat&quot;, &quot;Maru&quot;]famous_cats.unshift(&quot;nala cat&quot;)famous_cats.inspect #=&gt; [&quot;nala cat&quot;, &quot;lil&#39; bub&quot;, &quot;grumpy cat&quot;, &quot;Maru&quot;]</code></pre><h3><span id="removing-items-from-an-array">Removing Items From an Array</span></h3><h4><span id="the-pop-method">The <code>.pop</code> Method</span></h4><p>Calling <code>.pop</code> on an array will remove the <em>last</em> item from the <em>end</em> of the array. The <code>.pop</code> method will also supply the removed element as its return:</p><pre><code>famous_cats = [&quot;lil&#39; bub&quot;, &quot;grumpy cat&quot;, &quot;Maru&quot;]maru_cat = famous_cats.pop famous_cats #=&gt; [&quot;lil&#39; bub&quot;, &quot;grumpy cat&quot;]maru_cat #=&gt; Maru</code></pre><h4><span id="the-shift-method">The <code>.shift</code> Method</span></h4><p>Calling <code>.shift</code> on an array will remove the <em>first</em> item from the <em>front</em> of the array. The <code>.shift</code> method will also supply the removed element as a return:</p><pre><code>famous_cats = [&quot;lil&#39; bub&quot;, &quot;grumpy cat&quot;, &quot;Maru&quot;]lil_bub = famous_cats.shift famous_cats #=&gt; [&quot;grumpy cat&quot;, &quot;Maru&quot;]lil_bub #=&gt; lil&#39; bub</code></pre><h4><span id="the-reverse-method">The <code>.reverse</code> Method</span></h4><p>This method reverses an array.</p><pre><code>famous_wizards = [&quot;Dumbledore&quot;, &quot;Gandalf&quot;, &quot;Merlin&quot;]famous_wizards.reverse #=&gt; [&quot;Merlin&quot;, &quot;Gandalf&quot;, &quot;Dumbledore&quot;]</code></pre><h4><span id="the-include-method">The <code>.include?</code> Method</span></h4><p>This method will return a boolean of whether or not the array contains (or <em>includes</em>) the element submitted to it inside the parentheses:</p><pre><code>famous_cats = [&quot;lil&#39; bub&quot;, &quot;grumpy cat&quot;, &quot;Maru&quot;]famous_cats.include?(&quot;Garfield&quot;) #=&gt; falsefamous_cats.include?(&quot;Maru&quot;) #=&gt; true</code></pre><h2><span id="additional-resources">Additional Resources</span></h2><ul><li><a href="https://www.codecademy.com/courses/ruby-beginner-en-F3loB/0/1?curriculum_id=5059f8619189a5000201fbcb" target="_blank" rel="noopener">Arrays on Codecademy</a></li><li><a href="http://zetcode.com/lang/rubytutorial/arrays/" target="_blank" rel="noopener">Ruby Arrays on Zet Code</a></li><li><a href="http://www.tutorialspoint.com/ruby/ruby_arrays.htm" target="_blank" rel="noopener">Ruby Arrays on Tutorials Point</a></li></ul><h3><span id="nested-array">nested array</span></h3><blockquote><p> A nested, or multidimensional array, is an array whose individual elements are also arrays.</p></blockquote><h4><span id="adding-data-to-a-nested-array">Adding Data to a Nested Array</span></h4><p>To add data to a nested array, we can use the same <code>&lt;&lt;</code>, or shovel, method we use to add data to a one-dimensional array.</p><p>To add another student to our <code>students</code> array:</p><pre class=" language-ruby"><code class="language-ruby">students <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"Mike"</span><span class="token punctuation">,</span> <span class="token string">"Tim"</span><span class="token punctuation">,</span> <span class="token string">"Monique"</span><span class="token punctuation">]</span>students <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token string">"Sarah"</span>students <span class="token comment" spellcheck="true">#=> ["Mike", "Tim", "Monique", "Sarah"]</span></code></pre><p>To add an element to an array that is nested inside of another array, we first use the same bracket notation as above to dig down to the nested array, and <em>then</em> we can use the <code>&lt;&lt;</code> on it. To illustrate, let’s add another piece of info, <code>&quot;Class President&quot;</code>, to the nested array that describes Monique.</p><p>First, we have to access Monique’s array.</p><pre><code>nested_students[2]</code></pre><p>Then – bam! – we hit it with the shovel, <code>&lt;&lt;</code>.</p><pre><code>nested_students[2] &lt;&lt; &quot;Class President&quot;</code></pre><p>Now, our <code>nested_students</code> array looks like this:</p><pre><code>nested_students = [ [&quot;Mike&quot;, &quot;Grade 10&quot;, &quot;A average&quot;], [&quot;Tim&quot;, &quot;Grade 10&quot;, &quot;C average&quot;],  [&quot;Monique&quot;, &quot;Grade 11&quot;, &quot;B average&quot;, &quot;Class President&quot;]]</code></pre><h3><span id="iterating-over-nested-arrays">Iterating Over Nested Arrays</span></h3><p>What if we want to add data to <em>every array that is nested within the parent array</em>? It would be very tedious if we had to calculate the length of the array and then, one-by-one, modify each individual child array using bracket notation and the <code>&lt;&lt;</code> method.</p><p>When we are dealing with a one-dimensional array and want to do something to every element, we iterate, using methods like <code>#each</code> and <code>#collect</code>. If, for example, we wanted to <code>puts</code> out every member of the <code>students</code> array, we could do so like this:</p><pre class=" language-ruby"><code class="language-ruby">students<span class="token punctuation">.</span><span class="token keyword">each</span> <span class="token keyword">do</span> <span class="token operator">|</span>student<span class="token operator">|</span>      puts student<span class="token keyword">end</span></code></pre><p>In order to manipulate or operate on each element of a nested array, we must first dig down into that level of the array. For example, run the following code in IRB:</p><pre class=" language-ruby"><code class="language-ruby">nested_students <span class="token operator">=</span> <span class="token punctuation">[</span>      <span class="token punctuation">[</span><span class="token string">"Mike"</span><span class="token punctuation">,</span> <span class="token string">"Grade 10"</span><span class="token punctuation">,</span> <span class="token string">"A average"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>      <span class="token punctuation">[</span><span class="token string">"Tim"</span><span class="token punctuation">,</span> <span class="token string">"Grade 10"</span><span class="token punctuation">,</span> <span class="token string">"C average"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>      <span class="token punctuation">[</span><span class="token string">"Monique"</span><span class="token punctuation">,</span> <span class="token string">"Grade 11"</span><span class="token punctuation">,</span> <span class="token string">"B average"</span><span class="token punctuation">,</span> <span class="token string">"Class President"</span><span class="token punctuation">]</span>    <span class="token punctuation">]</span> nested_students<span class="token punctuation">.</span><span class="token keyword">each</span> <span class="token keyword">do</span> <span class="token operator">|</span>student_array<span class="token operator">|</span>      <span class="token comment" spellcheck="true"># #inspect returns a human-readable representation of the array </span>    puts student_array<span class="token punctuation">.</span>inspect<span class="token keyword">end</span></code></pre><p>The <code>.each</code> method prints out each nested array separately and then returns the original array:</p><pre><code>[&quot;Mike&quot;, &quot;Grade 10&quot;, &quot;A average&quot;][&quot;Tim&quot;, &quot;Grade 10&quot;, &quot;C average&quot;][&quot;Monique&quot;, &quot;Grade 11&quot;, &quot;B average&quot;, &quot;Class President&quot;]#  =&gt; [[&quot;Mike&quot;, &quot;Grade 10&quot;, &quot;A average&quot;], [&quot;Tim&quot;, &quot;Grade 10&quot;, &quot;C average&quot;], [&quot;Monique&quot;, &quot;Grade 11&quot;, &quot;B average&quot;, &quot;Class President&quot;]]</code></pre><p>In the example above, we are iterating through the list of arrays that make up the top level of the <code>nested_students</code> array. If we want to iterate through the elements <em>inside</em> each child array, we add a second layer of iteration <em>inside</em> the first:</p><pre class=" language-ruby"><code class="language-ruby">nested_students <span class="token operator">=</span> <span class="token punctuation">[</span>  <span class="token punctuation">[</span><span class="token string">"Mike"</span><span class="token punctuation">,</span> <span class="token string">"Grade 10"</span><span class="token punctuation">,</span> <span class="token string">"A average"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token punctuation">[</span><span class="token string">"Tim"</span><span class="token punctuation">,</span> <span class="token string">"Grade 10"</span><span class="token punctuation">,</span> <span class="token string">"C average"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token punctuation">[</span><span class="token string">"Monique"</span><span class="token punctuation">,</span> <span class="token string">"Grade 11"</span><span class="token punctuation">,</span> <span class="token string">"B average"</span><span class="token punctuation">,</span> <span class="token string">"Class President"</span><span class="token punctuation">]</span><span class="token punctuation">]</span> nested_students<span class="token punctuation">.</span><span class="token keyword">each</span> <span class="token keyword">do</span> <span class="token operator">|</span>student_array<span class="token operator">|</span>      student_array<span class="token punctuation">.</span><span class="token keyword">each</span> <span class="token keyword">do</span> <span class="token operator">|</span>student_detail<span class="token operator">|</span>            puts student_detail          <span class="token keyword">end</span><span class="token keyword">end</span></code></pre><p>Copy and paste the above code into IRB. You should see the following output:</p><pre><code>MikeGrade 10A averageTimGrade 10C averageMoniqueGrade 11B averageClass President</code></pre><blockquote><p>album_element.class != Array</p></blockquote><h3><span id="boolean-enumerables">Boolean Enumerables</span></h3><blockquote><ul><li>all?</li><li>none?</li><li>any?</li><li>include?</li></ul></blockquote><h4><span id="examples">examples</span></h4><pre class=" language-ruby"><code class="language-ruby"><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">.</span>none<span class="token operator">?</span><span class="token punctuation">{</span><span class="token operator">|</span>i<span class="token operator">|</span> i<span class="token punctuation">.</span>even<span class="token operator">?</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">#=> true</span></code></pre><pre class=" language-ruby"><code class="language-ruby"><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">.</span>any<span class="token operator">?</span><span class="token punctuation">{</span><span class="token operator">|</span>i<span class="token operator">|</span> i <span class="token operator">></span> <span class="token number">99</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">#=> true</span></code></pre><pre class=" language-ruby"><code class="language-ruby">the_numbers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">16</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">,</span><span class="token number">42</span><span class="token punctuation">]</span>the_numbers<span class="token punctuation">.</span>include<span class="token operator">?</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">#=> true</span>the_numbers<span class="token punctuation">.</span>include<span class="token operator">?</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">#=> false</span></code></pre><h3><span id="search-enumerables">search enumerables</span></h3><blockquote><ul><li>select</li><li>detect or find(<em>detect and find are two names for the same method</em>)</li><li>reject</li></ul></blockquote><pre class=" language-ruby"><code class="language-ruby"><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">.</span>select<span class="token punctuation">{</span><span class="token operator">|</span>i<span class="token operator">|</span> i<span class="token punctuation">.</span>odd<span class="token operator">?</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">#=> [1,3,5]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">.</span>select<span class="token punctuation">{</span><span class="token operator">|</span>i<span class="token operator">|</span> i<span class="token punctuation">.</span>is_a<span class="token operator">?</span><span class="token punctuation">(</span><span class="token builtin">String</span><span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">#=> []</span></code></pre><pre class=" language-ruby"><code class="language-ruby"><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">.</span>detect<span class="token punctuation">{</span><span class="token operator">|</span>i<span class="token operator">|</span> i<span class="token punctuation">.</span>even<span class="token operator">?</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">#=> 2</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">.</span>detect<span class="token punctuation">{</span><span class="token operator">|</span>i<span class="token operator">|</span> i<span class="token punctuation">.</span>is_a<span class="token operator">?</span><span class="token punctuation">(</span><span class="token builtin">String</span><span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">#=> nil</span></code></pre><blockquote><p>Notice also that <code>#detect</code> will always return a single object where <code>#select</code> will always return an array.</p></blockquote><pre class=" language-ruby"><code class="language-ruby"><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span>reject<span class="token punctuation">{</span><span class="token operator">|</span>i<span class="token operator">|</span> i<span class="token punctuation">.</span>even<span class="token operator">?</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">#=> [1]</span></code></pre><h2><span id="hashes">Hashes</span></h2><p>Hashes also store objects in Ruby. However, they differ from arrays in that they function like dictionaries. Instead of a simple comma separated list, hashes are composed of key/value pairs. Each key points to a specific value––just like a word and a definition in a regular dictionary.</p><p>Hashes look like this: <code>{&quot;i&#39;m a key&quot; =&gt; &quot;i&#39;m a value!&quot;, &quot;key2&quot; =&gt; &quot;value2&quot;}</code></p><p>The curly brackets denote the hash and this particular hash has two key/value pairs.</p><h3><span id="creating-hashes">Creating Hashes</span></h3><p>Hashes can be created with literal constructors and class constructors.</p><p><strong>The Literal Constructor:</strong> You can create a hash by simply writing key/value pairs enclosed in curly braces.</p><p><strong>The Class Constructor:</strong> Or, you can use the <a href="http://ruby-doc.org/core-2.2.0/Hash.html" target="_blank" rel="noopener"><code>Hash.new</code> syntax</a>, which would create an empty hash, <code>{}</code>.</p><h3><span id="operating-on-hashes">Operating on Hashes</span></h3><p>There are many methods for operating on hashes and their individual key/value pairs. We will learn much more about them later, but you can preview some methods <a href="http://ruby-doc.org/core-2.2.0/Hash.html" target="_blank" rel="noopener">here</a>.</p><h2><span id="method">Method</span></h2><h3><span id="defining-a-method">Defining a Method</span></h3><p>You can define a method in Ruby with the <code>def</code> keyword. A method’s name can begin with any lowercase letter. Here’s a quick example:</p><pre><code>def greeting # Method Signature  puts &quot;Hello World&quot; # Method Bodyend # Method Closing</code></pre><p>That first line, <code>def greeting</code>, is called the method signature, it defines the basic properties of the method including the name of the method, <code>greeting</code>.</p><p>Once you open a method definition with the <code>def</code> keyword, all subsequent lines in your program are considered the method’s body, the actual procedure or code that your method will run every time it’s called.</p><p>You must terminate every opening <code>def</code> of a method with a corresponding <code>end</code> in order to close the method body.<strong>The body of a method should be indented two (2) spaces, placing it visually within the method.</strong>(<em>just for beauty</em>)</p><h4><span id="excute-it">Excute it</span></h4><pre><code>greeting</code></pre><blockquote><p>no()</p></blockquote><h3><span id="control-flow">control flow</span></h3><ul><li><code>if</code>, <code>else</code>, and <code>elsif</code> statements,</li><li><code>case</code> statements,</li><li>loops.</li></ul><h4><span id="if">if</span></h4><pre class=" language-ruby"><code class="language-ruby">dog <span class="token operator">=</span> <span class="token string">"thirsty"</span><span class="token keyword">if</span> dog <span class="token operator">==</span> <span class="token string">"hungry"</span>  puts <span class="token string">"Refilling food bowl."</span><span class="token keyword">elsif</span> dog <span class="token operator">==</span> <span class="token string">"thirsty"</span>  puts <span class="token string">"Refilling water bowl."</span><span class="token keyword">else</span>  puts <span class="token string">"Reading newspaper."</span><span class="token keyword">end</span></code></pre><h4><span id="loops">Loops</span></h4><pre class=" language-ruby"><code class="language-ruby"><span class="token number">10</span><span class="token punctuation">.</span>times <span class="token keyword">do</span>   puts <span class="token string">"Hi! Welcome to my very repetitive program"</span><span class="token keyword">end</span></code></pre><pre class=" language-ruby"><code class="language-ruby">counter <span class="token operator">=</span> <span class="token number">0</span>loop <span class="token keyword">do</span>   counter <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span>  puts <span class="token string">"Iteration <span class="token interpolation"><span class="token delimiter tag">#{</span>counter<span class="token delimiter tag">}</span></span> of the loop"</span>  <span class="token keyword">if</span> counter <span class="token operator">>=</span> <span class="token number">10</span>     <span class="token keyword">break</span>  <span class="token keyword">end</span><span class="token keyword">end</span></code></pre><h4><span id="while">while</span></h4><pre class=" language-ruby"><code class="language-ruby">counter <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">while</span> counter <span class="token operator">&lt;</span> <span class="token number">20</span>  puts <span class="token string">"The current number is less than 20."</span>  counter <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span><span class="token keyword">end</span></code></pre><h4><span id="until">until</span></h4><p><code>Until</code> is simply the inverse of a <code>while</code> loop. An <code>until</code> keyword will <strong>keep executing a block <em>until a specific condition is true</em>.</strong> In other words, the block of code following <code>until</code> will execute while the condition is false. One helpful way to think about it is to read <code>until</code> as “if not”.</p><pre class=" language-ruby"><code class="language-ruby">counter <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">until</span> counter <span class="token operator">==</span> <span class="token number">20</span>  puts <span class="token string">"The current number is less than 20."</span>  counter <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span><span class="token keyword">end</span></code></pre><h3><span id="iteration-vs-looping">Iteration vs. Looping</span></h3><p>In previous readings we discussed the four loop types, <code>loop</code>, <code>times</code>, <code>while</code>, and <code>until</code>. Now we’re going to discuss the difference between looping and iteration. <strong>Looping</strong> occurs when you tell your program to do something a certain number of times. <strong>Iteration</strong> occurs when you have a collection of data (for example, an array), and you operate on each member of that collection.</p><p>For example, if I tell my program to print out the phrase “I love programming!” five times, that’s <em>looping</em>. If I tell my program to enumerate over the array <code>[1, 2, 3, 4, 5]</code> and add <code>10</code> to each number, that’s <em>iteration</em>.</p><blockquote><p>each - The Most Abstract<br>Being abstract is something profoundly different from being vague…. The purpose of abstraction is not to be vague, but to create a new semantic level in which one can be absolutely precise.<br>— Edsger Dijkstra</p></blockquote><h2><span id="using-each">Using <code>#each</code></span></h2><p>The <code>#each</code> method is a prime example of an iterator. Here’s a boilerplate example of its usage:</p><pre class=" language-ruby"><code class="language-ruby">primary_colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"Red"</span><span class="token punctuation">,</span> <span class="token string">"Yellow"</span><span class="token punctuation">,</span> <span class="token string">"Blue"</span><span class="token punctuation">]</span>primary_colors<span class="token punctuation">.</span><span class="token keyword">each</span> <span class="token keyword">do</span> <span class="token operator">|</span>color<span class="token operator">|</span>    puts <span class="token string">"Primary Color <span class="token interpolation"><span class="token delimiter tag">#{</span>color<span class="token delimiter tag">}</span></span> is <span class="token interpolation"><span class="token delimiter tag">#{</span>color<span class="token punctuation">.</span>length<span class="token delimiter tag">}</span></span> letters long."</span><span class="token keyword">end</span></code></pre><p><code>#each</code> is called on the collection <code>primary_colors</code>, which is an array containing 3 individual strings.</p><p>A block is passed to <code>#each</code>, opened by the code that starts with <code>do</code> and closed by the <code>end</code>. Every <code>do</code> needs a closing <code>end</code>.</p><pre class=" language-ruby"><code class="language-ruby">primary_colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"Red"</span><span class="token punctuation">,</span> <span class="token string">"Yellow"</span><span class="token punctuation">,</span> <span class="token string">"Blue"</span><span class="token punctuation">]</span>primary_colors<span class="token punctuation">.</span><span class="token keyword">each</span> <span class="token keyword">do</span> <span class="token operator">|</span>color<span class="token operator">|</span> <span class="token comment" spellcheck="true"># do begins a block  </span><span class="token comment" spellcheck="true"># the lines between the do/end are the block's body</span>    puts <span class="token string">"Primary Color <span class="token interpolation"><span class="token delimiter tag">#{</span>color<span class="token delimiter tag">}</span></span> is <span class="token interpolation"><span class="token delimiter tag">#{</span>color<span class="token punctuation">.</span>length<span class="token delimiter tag">}</span></span> letters long."</span><span class="token keyword">end</span> <span class="token comment" spellcheck="true"># end terminates the block</span></code></pre><p>The output from this code is:</p><pre><code>Primary Color Red is 3 letters long.Primary Color Yellow is 6 letters long.Primary Color Blue is 4 letters long.</code></pre><p>We can see that the block passed to <code>each</code> is executed once for each element in the original collection. If there were 5 colors in <code>primary_colors</code>, the block would have run 5 times. We call each run, each execution, of the block passed to the iterator (<code>#each</code> in this case), an iteration. It’s a word used to refer to each ‘step’, or each ‘execution’, of a block. An iteration is the singular execution of a sequence of code (that we call a block) within a loop.</p><p>When we iterate over a collection of elements using <code>#each</code> (and also in other iterators and enumerables we’ll soon learn about),<strong> the iterator <code>#each</code> yields each element one at a time to every iteration via a variable declared with the opening of the block.</strong></p><p>After the opening <code>do</code> of our code above, we see <code>|color|</code>. <code>|</code> is called a pipe. After <code>do</code>, <strong>we declare a local variable <code>color</code> by enclosing it in <code>| |</code> pipes.</strong> This variable’s value is automatically assigned the element from the array for the current iteration. So on the first iteration of the <code>each</code> above, the variable <code>color</code> would be equal to <code>&quot;Red&quot;</code>. But on the next iteration of the block, <code>color</code> will be reassigned the value of the next element in the <code>primary_colors</code> array, <code>&quot;Yellow&quot;</code>.</p><h4><span id="the-syntax">The <code>{ }</code> Syntax</span></h4><p>Another way of establishing a code block that you may encounter is to use curly brackets, <code>{ }</code>, instead of the <code>do</code>/<code>end</code> keywords. Let’s take a look:</p><pre><code>brothers = [&quot;Tim&quot;, &quot;Tom&quot;, &quot;Jim&quot;]brothers.each{|brother| puts &quot;Stop hitting yourself #{brother}!&quot;}</code></pre><p>It is appropriate to use the <code>{ }</code> syntax when the code in the block is short and can <strong>fit on one line</strong>.</p><h3><span id="rsepc">rsepc</span></h3><blockquote><pre class=" language-ruby"><code class="language-ruby">rspec <span class="token operator">--</span>fail<span class="token operator">-</span>fast</code></pre></blockquote><h4><span id="describe"><code>describe</code></span></h4><p>The first thing RSpec allows you to do with its DSL is to define what it is you are describing.</p><h4><span id="it"><code>it</code></span></h4><p>Now that we’ve created a structure to group our tests together using the <code>describe</code> method, we can move on to actually describing the desired functionality. Every specification in RSpec begins with the <code>it</code> method.</p><h4><span id="expect-to-and-eq"><code>expect</code>, <code>to</code>, and <code>eq</code>.</span></h4><p><code>expect()</code> is a method that accepts our unknown value or variable, the thing we’re testing. So for instance, in a simple math equation, imagine the following:</p><pre><code>x = 1 + 1expect(x)</code></pre><p>Since <code>x</code> is the unknown variable, we’d be testing the expectation of the value of <code>x</code>, so we pass that value to the <code>expect</code> method. I can imagine it’s weird to think of the variable <code>x</code> as an unknown value worth confirming. You’re thinking, “It’s obviously 2!” But the truth is, you’re making the assumption that Ruby has a correct notion of arithmetic. As our programs become more complex and we use more variables, it’s very important to constantly validate our assumptions with expectations and testing. Let’s finish the example.</p><p>In addition to the <code>expect(x)</code> call, we need to communicate what we expect <code>x</code> to be equal to. To accomplish this, we chain a <code>to()</code>method to the <code>expect()</code>, so it simply looks like:</p><pre><code>x = 1 + 1expect(x).to</code></pre><p>Then finally we use what is known as a matcher, <code>eq</code>, to specify our expectation: that we expect the value of <code>x</code>, passed to the <code>expect</code>method, to equal (<code>to eq</code>) 2.</p><pre><code>x = 1 + 1expect(x).to eq(2)</code></pre><p>You won’t have to write your own tests for a while, so don’t worry about mastering the <code>expect</code>, <code>to</code>, and <code>eq</code> usage. The important part is that you can read the DSL and understand what it is trying to suggest.</p><blockquote><ol><li>RSpec looks in a directory named <code>spec</code> for all files that end with the pattern <code>_spec.rb</code>. Why the <code>spec</code> folder and the <code>_spec.rb</code> pattern? No reason, just convention.</li><li>RSpec then executes the Ruby code within each <code>_spec.rb</code> file.</li></ol></blockquote><h3><span id="class">class</span></h3><pre class=" language-ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">Dog</span><span class="token keyword">end</span>fido <span class="token operator">=</span> <span class="token constant">Dog</span><span class="token punctuation">.</span><span class="token keyword">new</span><span class="token class-name">fido</span> <span class="token comment" spellcheck="true">#=> #&lt;Dog:0x007fc52c2d7d20></span>snoopy <span class="token operator">=</span> <span class="token constant">Dog</span><span class="token punctuation">.</span><span class="token keyword">new</span><span class="token class-name">snoopy</span> <span class="token comment" spellcheck="true">#=> #&lt;Dog:0x007fc52c2d4170></span>snoopy <span class="token operator">==</span> fido <span class="token comment" spellcheck="true">#=> false - these dogs are not the same.</span></code></pre><h4><span id="implementing-instance-variables">Implementing Instance Variables</span></h4><p>We define an instance variable by prefacing the variable name with an <strong><code>@</code></strong> symbol.</p><p>Instance variables are bound to an instance of a class. <em>That means that the value held by an instance variable is specific to whatever instance of the class it happens to belong to</em>. Instance variables hold information about an instance, usually an attribute of that instance, and can be called on throughout the class, without needing to be passed into other methods as arguments (as would be the case with local variables).</p><p>Let’s refactor our <code>Dog</code> class to use an instance variable instead of a local variable to set and get an individual dog’s name.</p><p>Open up <code>dog.rb</code> and change the <code>Dog</code> class in the following way:</p><pre class=" language-ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">Dog</span>   <span class="token keyword">def</span> name<span class="token operator">=</span><span class="token punctuation">(</span>dogs_name<span class="token punctuation">)</span>      <span class="token variable">@this_dogs_name</span> <span class="token operator">=</span> dogs_name <span class="token keyword">end</span>   <span class="token keyword">def</span> name       <span class="token variable">@this_dogs_name</span> <span class="token keyword">end</span><span class="token keyword">end</span> lassie <span class="token operator">=</span> <span class="token constant">Dog</span><span class="token punctuation">.</span><span class="token keyword">new</span><span class="token class-name">lassie<span class="token punctuation">.</span>name</span> <span class="token operator">=</span> <span class="token string">"Lassie"</span> puts lassie<span class="token punctuation">.</span>name </code></pre><h4><span id="initialize">initialize</span></h4><blockquote><p> require certain arguments to be passed when instantiating the class to provide it with initial data</p></blockquote><pre class=" language-ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">Person</span>  <span class="token keyword">def</span> <span class="token function">initialize</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span>    <span class="token variable">@name</span> <span class="token operator">=</span> name  <span class="token keyword">end</span>  <span class="token keyword">def</span> name    <span class="token variable">@name</span>  <span class="token keyword">end</span><span class="token keyword">end</span>kanye <span class="token operator">=</span> <span class="token constant">Person</span><span class="token punctuation">.</span><span class="token keyword">new</span><span class="token punctuation">(</span><span class="token string">"Kanye"</span><span class="token punctuation">)</span>kanye<span class="token punctuation">.</span>name <span class="token comment" spellcheck="true">#=> "Kanye"</span></code></pre><h4><span id="setter-vs-getter-methods">Setter vs. Getter Methods</span></h4><p>Our Person class’ <code>#name</code> method is referred to as a <strong>“getter”</strong> or reader method. It returns information stored in an instance variable. In order to make a person’s name attribute <em>writable</em>, we need to define a <strong>“setter”</strong> or writer method.</p><h3><span id="defining-a-setter-method">Defining a Setter Method</span></h3><pre class=" language-ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">Person</span>     <span class="token keyword">def</span> <span class="token function">initialize</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span>          <span class="token variable">@name</span> <span class="token operator">=</span> name     <span class="token keyword">end</span>       <span class="token keyword">def</span> name         <span class="token variable">@name</span>     <span class="token keyword">end</span>      <span class="token keyword">def</span> name<span class="token operator">=</span><span class="token punctuation">(</span>new_name<span class="token punctuation">)</span>          <span class="token variable">@name</span> <span class="token operator">=</span> new_name      <span class="token keyword">end</span> <span class="token keyword">end</span></code></pre><p><strong>A setter method is defined with an <code>=</code>,</strong> equals sign, appended to the name of the method. The <code>=</code> is followed by the <code>(argument_name)</code>. Now that we’ve defined our setter method on the Person class, we can change Kanye’s name.</p><h3><span id="calling-a-setter-method">Calling a Setter Method</span></h3><p>To call a setter method, you use the <code>.</code> notation (dot notation) to call the method and set it equal to a new value.</p><pre class=" language-ruby"><code class="language-ruby">kanye <span class="token operator">=</span> <span class="token constant">Person</span><span class="token punctuation">.</span><span class="token keyword">new</span><span class="token punctuation">(</span><span class="token string">"Kanye"</span><span class="token punctuation">)</span>kanye<span class="token punctuation">.</span>name  <span class="token operator">=</span><span class="token operator">></span> <span class="token string">"Kanye"</span> kanye<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"Yeezy"</span>kanye<span class="token punctuation">.</span>name  <span class="token operator">=</span><span class="token operator">></span> <span class="token string">"Yeezy"</span></code></pre><p>You can also call a setter method like this:</p><pre class=" language-ruby"><code class="language-ruby">kanye<span class="token punctuation">.</span>name<span class="token operator">=</span><span class="token punctuation">(</span><span class="token string">"Yeezy"</span><span class="token punctuation">)</span></code></pre><p>But we prefer the first notation.</p><h4><span id="the-abstraction-of-instance-methods">The Abstraction of Instance Methods</span></h4><pre class=" language-ruby"><code class="language-ruby">kanye<span class="token punctuation">.</span><span class="token function">instance_variable_set</span><span class="token punctuation">(</span><span class="token punctuation">:</span><span class="token variable">@name</span><span class="token punctuation">,</span> <span class="token string">"Yeezy"</span><span class="token punctuation">)</span>kanye<span class="token punctuation">.</span><span class="token function">instance_variable_get</span><span class="token punctuation">(</span><span class="token punctuation">:</span><span class="token variable">@name</span><span class="token punctuation">)</span>  <span class="token operator">=</span><span class="token operator">></span> <span class="token string">"Yeezy"</span></code></pre><p><strong>Since this is the case, why do we even use instance setter and getter methods?</strong></p><blockquote><ul><li><p>, we care about our program’s readability and design. The above method is ugly. It places a verb at the end of the method name. </p></li><li><p>It exposes it directly to the person executing our code. This is bad practice because it forces our program to rely directly on the <code>@name</code> variable. </p></li><li><p>for example:We’ll initialize our <code>Person</code> instances with both a first and last name.</p><pre class=" language-ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">Person</span>       <span class="token keyword">def</span> <span class="token function">initialize</span><span class="token punctuation">(</span>first_name<span class="token punctuation">,</span> last_name<span class="token punctuation">)</span>          <span class="token variable">@first_name</span> <span class="token operator">=</span> first_name          <span class="token variable">@last_name</span> <span class="token operator">=</span> last_name      <span class="token keyword">end</span>      <span class="token comment" spellcheck="true">#... end</span></code></pre><p>With this change, our program  has some added functionality. We could imagine collecting all of our instances of <code>Person</code> and sorting them by last name, for example.</p><p>BUT, now, <strong>any other part of our program that was calling <code>instance_variable_get(:@name)</code> is broken!</strong></p><p>Let’s create our abstraction: the <code>#name=</code> and <code>#name</code> setter and getter instance methods:</p><pre class=" language-ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">Person</span>       <span class="token keyword">def</span> <span class="token function">initialize</span><span class="token punctuation">(</span>first_name<span class="token punctuation">,</span> last_name<span class="token punctuation">)</span>           <span class="token variable">@first_name</span> <span class="token operator">=</span> first_name           <span class="token variable">@last_name</span> <span class="token operator">=</span> last_name      <span class="token keyword">end</span>      <span class="token keyword">def</span> name<span class="token operator">=</span><span class="token punctuation">(</span>full_name<span class="token punctuation">)</span>          first_name<span class="token punctuation">,</span> last_name <span class="token operator">=</span> full_name<span class="token punctuation">.</span>split           <span class="token variable">@first_name</span> <span class="token operator">=</span> first_name           <span class="token variable">@last_name</span> <span class="token operator">=</span> last_name      <span class="token keyword">end</span>      <span class="token keyword">def</span> name           <span class="token string">"<span class="token interpolation"><span class="token delimiter tag">#{</span>@first_name<span class="token delimiter tag">}</span></span> <span class="token interpolation"><span class="token delimiter tag">#{</span>@last_name<span class="token delimiter tag">}</span></span>"</span><span class="token punctuation">.</span>strip      <span class="token keyword">end</span><span class="token keyword">end</span></code></pre><p><strong>Now, even if the content of the #name method changes, for example, Kanye changes his mind again and wants to be referred to only as “Yeezy” (using our interface this change would be kanye.name = “Yeezy”), the interface, how our application uses that content, remains constant.</strong> In other words, <strong>we can change the content of these methods according to our needs, without needing to hunt down every appearance of them in our program and change them as well</strong>, like we would need to do with our <code>instance_method_set</code> and <code>instance_method_get</code> usages.</p></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> ruby </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>隐藏和覆盖的区别和用法</title>
      <link href="2018/11/23/%E9%9A%90%E8%97%8F%E5%92%8C%E8%A6%86%E7%9B%96%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E7%94%A8%E6%B3%95/"/>
      <url>2018/11/23/%E9%9A%90%E8%97%8F%E5%92%8C%E8%A6%86%E7%9B%96%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2><span id="隐藏和覆盖的区别和用法">隐藏和覆盖的区别和用法</span></h2><blockquote><p>以下内容来自<a href="https://www.cnblogs.com/shakinghead/p/7445831.html" target="_blank" rel="noopener">隐藏和覆盖的区别和用法</a></p></blockquote><h3><span id="静态类型和动态类型">静态类型和动态类型</span></h3><p>任何一个引用变量都有两个类型：一个叫<strong>静态类型</strong>，也就是定义该引用变量的类型；另一个叫<strong>动态类型</strong>，也就是该引用实际指向的对象类型。</p><p>比如对于两个类A和类B，有：<strong>A a=new B()；</strong></p><p>那么，引用a的静态类型就是A，动态类型就是B。</p><p>java中引用的静态类型在编译的时候就可以确认，但是编译器无法得知这个引用的动态类型；只有当程序运行时，通过RTTI就可以检查出引用的动态类型。</p><h3><span id="静态绑定和动态绑定">静态绑定和动态绑定</span></h3><p>java中绑定的概念：对于一个程序，可以有很多的方法。这些方法的名称、参数类型和参数数量都可能相同或者不同，那么在调用一个方法的时候，如何将一个方法和该方法所在的类关联起来，这就是绑定。java中的绑定分为静态绑定和动态绑定。</p><p><strong>静态绑定</strong>：所有依赖于静态类型来将某方法和该方法所在的类关联起来的动作都是静态绑定。因为静态绑定在程序运行前发生，所有又叫前期绑定。</p><p><strong>动态绑定</strong>：所有依赖于动态类型来将某方法和该方法所在的类关联起来的动作都是动态绑定。因为动态绑定是在程序运行时，通过RTTI实现，所以又叫后期绑定。</p><p>举例：假如有一个父类Father和一个子类Son，子类重写了父类中的某个方法method()。有以下语句：</p><p>Father father=new Son()；</p><p>father.method()；</p><p>对于这个例子，静态绑定的过程是：java文件编译时，编译器检查出引用father的静态类型是Father类，由于将method()方法和父类Father关联起来。也就是说，程序运行前编译器是无法检查出引用father的动态类型的，所以会直接调用静态类型中对应的方法。</p><p>而动态绑定的过程是：当这个java程序运行起来了，RTTI检查出引用father的动态类型是Son类时，会将method()方法和子类Son关联起来，也就是决定调用动态类型Son类中的method()方法。具体过程为：①JVM提取对象的实际类型的方法表；②JVM搜索方法签名；③调用方法。</p><p>另外，要补充的是：java中类的属性也都是静态绑定的。这是因为静态绑定是有很多的好处，它可以让我们在编译期就发现程序中的错误，而不是在运行期。这样就可以提高程序的运行效率！<strong>而对方法采取动态绑定是为了实现多态。</strong></p><h3><span id="隐藏和覆盖">隐藏和覆盖</span></h3><p>当子类继承父类时，除了继承父类所有的成员变量和成员方法之外，还可以声明自己的成员变量和成员方法。那么，如果父类和子类的成员变量和方法同名会发生什么？假设有一个父类Father和一个子类Son。父类有一个成员变量a=0；有一个静态成员变量b=0；有一个成员方法a，输出0；有一个静态成员方法b，输出0。子类分别重写这些变量和方法，只是修改变量的值和方法的输出，全部改为1.   我们再声明一个静态类型是父类，动态类型是子类的引用：</p><p>Father father=new Son()；</p><p>通过这个引用访问子类的变量和调用子类的方法，那么，会有以下结论：</p><p>1、所有的成员变量（不管是静态还是非静态）都只进行静态绑定，所以JVM的绑定结果会是：直接访问静态类型中的成员变量，也就是父类的成员变量，输出0.</p><p>2、对于静态方法，也是只进行静态绑定，所以JVM会通过引用的静态类型，也就是Father类，来进行绑定，结果为：直接调用父类中的静态方法，输出0.</p><p>3、对于非静态方法，会进行动态绑定，JVM检查出引用father的动态类型，也就是Son类，绑定结果为：调用子类中的静态方法，输出1.</p><blockquote><p>对于1和2这两种情况，子类继承父类后，父类的属性和静态方法并没有被子类抹去，通过相应的引用可以访问的到。但是在子类中不能显示地看到，这种情况就称为隐藏。</p></blockquote><p>而对于3这种情况，子类继承父类后，父类的非静态方法被子类重写后覆盖上去，通过相应的引用也访问不到了（除非创建父类的对象来调用）。这种情况称为覆盖。</p><h3><span id="总结">总结</span></h3><p>在子类继承父类后：</p><p><strong>父类的成员变量只会被隐藏，而且支持交叉隐藏（比如静态变量被非静态变量隐藏）。父类的静态方法只会被静态方法隐藏，不支持交叉隐藏。父类的非静态方法会被覆盖，但是不能交叉覆盖。</strong></p><p>代码测试如下：</p><p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> test<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 隐藏和覆盖的区别 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HideAndCover</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Father father<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Son</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>father<span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>father<span class="token punctuation">.</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>        father<span class="token punctuation">.</span><span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        father<span class="token punctuation">.</span><span class="token function">d</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//声明父类</span><span class="token keyword">class</span> <span class="token class-name">Father</span><span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> b<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">d</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//声明子类</span><span class="token keyword">class</span> <span class="token class-name">Son</span> <span class="token keyword">extends</span> <span class="token class-name">Father</span><span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> b<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">d</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>运行结果为：</p><p>0</p><p>0</p><p>1</p><p>0</p><hr><h2><span id="相关讨论来源于geeklub官方qq群">相关讨论（来源于geeklub官方qq群）</span></h2><h3><span id="题目">题目：</span></h3><blockquote><p> 为什么string a = NULL;string b = NULL;  c=a+b;    得出来c的结果为NULL？</p></blockquote><h3><span id="回答">回答：</span></h3><blockquote><p> 与字符串有关的加法会自动创建一个 StringBuilder对象，然后所有的都直接 append进去。如果传进去的对象是 null 会调用一个 appendNULL,这个方法是把 n u l l四个字符append进去,所以任何类的null对象加进去都是一个null字符串。</p><p> 这个从JVM6.0开始就是用的这样的处理方式了 ，隐式调用toString 然后null的话返回null是JVM6.0之前的做法 那个时候toString还不是Object里的方法 算是Object的一个隐藏超类的方法，那个隐藏超类允许为null然后 toString返回null 但是后面全部合并到了Object里</p></blockquote><hr><h2><span id="补充面向对象的三个特点">补充：面向对象的三个特点</span></h2><p>封装、继承、多态。从一定角度来看，封装和继承几乎都是为多态而准备的</p><h3><span id="什么是多态">什么是多态</span></h3><p>指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式</p><h4><span id="实现多态的技术">实现多态的技术</span></h4><p>动态绑定（dynamic binding），是指在执行期间判断所引用对象的实际类型，根据其实际的类型调用其相应的方法</p><h4><span id="多态存在的三个必要条件">多态存在的三个必要条件</span></h4><ol><li>继承</li><li>重写</li><li>父类引用指向子类对象（超类又称为父类）</li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 静态和动态 </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c的指针</title>
      <link href="2018/11/22/c%E7%9A%84%E6%8C%87%E9%92%88/"/>
      <url>2018/11/22/c%E7%9A%84%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<blockquote><p> 指针的基本概念，一维数组的指针。</p></blockquote><h2><span id="什么是指针">什么是指针</span></h2><p>指针也称作指针变量，大小为4个字节（或8个字节）的变量，其内容代表一个内存地址。</p><blockquote><p>sizeof(T*)  4字节（64位计算机上可能是8字节）</p><p>T是任何变量类型</p></blockquote><h2><span id="指针的定义">指针的定义</span></h2><blockquote><p>类型名  * 指针变量名</p></blockquote><p>如 float<em>p，p是指针变量名，变量p的类型是<strong>float</strong> </em></p><blockquote><p>注意：保存地址的是p不是*p</p></blockquote><p>通过表达式 *p可以读写从地址p开始的sizeof(float)个字节,*p等价于存放在地址p处的一个float类型变量。</p><blockquote><p>注：float可以被任何变量类型替代</p></blockquote><h2><span id="指针用法">指针用法</span></h2><pre class=" language-c"><code class="language-c"><span class="token keyword">char</span> ch1 <span class="token operator">=</span> <span class="token string">'a'</span><span class="token keyword">char</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>ch1<span class="token keyword">char</span> ch2 <span class="token operator">=</span> <span class="token operator">*</span>pp <span class="token operator">=</span> <span class="token operator">&amp;</span>ch2<span class="token operator">*</span> p <span class="token operator">=</span> <span class="token string">'d'</span></code></pre><blockquote><p>注意要使用&amp;取地址运算符（&amp;x的类型是T<em>),p是地址，\</em>p是p所指的变量</p></blockquote><h2><span id="不同类型指针的相互赋值">不同类型指针的相互赋值</span></h2><blockquote><p>不同类型的指针，如果不经过强制类型转换，不能直接赋值</p></blockquote><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token operator">*</span>pn<span class="token punctuation">,</span><span class="token keyword">char</span> <span class="token operator">*</span>pc<span class="token punctuation">,</span><span class="token keyword">char</span> c <span class="token operator">=</span><span class="token number">0x65</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//0x是十六进制</span>pn <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>c<span class="token punctuation">;</span><span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token operator">*</span>pn<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//n值不确定</span><span class="token operator">*</span>pn <span class="token operator">=</span> <span class="token number">0x12345678</span><span class="token comment" spellcheck="true">//编译能过但运行可能出错</span></code></pre><h3><span id="运行出错的原因">运行出错的原因</span></h3><h4><span id="n值不确定">n值不确定</span></h4><p>*pn是int类型，读取四个字节，而c只占开始的一个字节</p><h4><span id="编译能过但运行可能出错">编译能过但运行可能出错</span></h4><p>从pn指向的4个字节往里面写东西，但不能确定c后面的3个字节是否能够访问（操作系统不让访问，导致程序崩溃），或者可以访问，但这3个空间可能是其他变量的空间（程序出错）</p><h2><span id="指针运算">指针运算</span></h2><h4><span id="两个同类型的指针变量可以比较大小">两个同类型的指针变量可以比较大小</span></h4><p>地址p1&lt;地址p2 p1&lt;p2的值为真</p><h4><span id="同类型的指针变量可以相减">同类型的指针变量可以相减</span></h4><p>两个T*类型的指针p1和p2</p><p>p1-p2=(地址p1-地址p2)/sizeof(T)</p><h4><span id="指针变量加减一个整数的结果是指针">指针变量加减一个整数的结果是指针</span></h4><p>n:整数类型的<strong>变量</strong>或常量</p><p>p+n：T*类型的指针，指向地址：</p><p>地址p+n * sizeof(T)</p><h4><span id="可自增可自减">可自增，可自减</span></h4><p>T*类型的指针p指向地址n</p><p>p++，++p：p指向n + sizeof(T)</p><h4><span id="指针可以用下标运算符运算">指针可以用下标运算符[]运算</span></h4><p>p[n]等价于*（p+n）</p><h2><span id="空指针">空指针</span></h2><blockquote><p> 地址0不能访问，指向地址0的指针就是空指针</p></blockquote><blockquote><p>可以用”NULL”关键字对任何类型的指针进行赋值，NULL实际上就是整数0，值为NULL的指针就是空指针</p></blockquote><blockquote><p>指针可以作为条件表达式使用。如果指针的值为NULL，则相当于为假，值不为NULL，就相当于为真</p></blockquote><h2><span id="指针和数组">指针和数组</span></h2><blockquote><p>数组是特殊类型的指针</p></blockquote><h3><span id="指针形式的数组运算">指针形式的数组运算：</span></h3><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">;</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">200</span><span class="token punctuation">]</span><span class="token punctuation">;</span>p<span class="token operator">=</span>a<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//p指向数组a的起始地址，即p指向a[0]</span><span class="token operator">*</span>p<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//a[0]=10</span><span class="token operator">*</span><span class="token punctuation">(</span>p<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//a[1]=20</span>p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">30</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//a[0]=30</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token operator">*</span><span class="token punctuation">(</span>p<span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token operator">=</span>i<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//对数字的前10个元素进行赋值</span><span class="token punctuation">}</span>p <span class="token operator">=</span> a <span class="token operator">+</span> <span class="token number">6</span><span class="token comment" spellcheck="true">//p指向a[6]</span></code></pre><h3><span id="颠倒一个数组">颠倒一个数组</span></h3><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">,</span><span class="token keyword">int</span> size<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>size<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> tmp <span class="token operator">=</span> p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>p<span class="token punctuation">[</span>size<span class="token number">-1</span><span class="token operator">-</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        p<span class="token punctuation">[</span>size<span class="token number">-1</span><span class="token operator">-</span>i<span class="token punctuation">]</span><span class="token operator">=</span>tmp<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2><span id="指针和二维数组">指针和二维数组</span></h2><p>二维数组的地址是连续存放的，所以二维本质上是一维。</p><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">,</span><span class="token keyword">int</span> size<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> ihttps<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>github<span class="token punctuation">.</span>com<span class="token operator">/</span>hexojs<span class="token operator">/</span>hexo<span class="token operator">/</span>files<span class="token operator">/</span><span class="token number">2246484</span><span class="token operator">/</span>log<span class="token punctuation">.</span>txt    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>size<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> tmp <span class="token operator">=</span> p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>p<span class="token punctuation">[</span>size<span class="token number">-1</span><span class="token operator">-</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        p<span class="token punctuation">[</span>size<span class="token number">-1</span><span class="token operator">-</span>i<span class="token punctuation">]</span><span class="token operator">=</span>tmp<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">reverse</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><p>颠倒后的数组为</p><pre class=" language-c"><code class="language-c"><span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></blockquote><h2><span id="指向指针的指针">指向指针的指针</span></h2><p>T **p</p><blockquote><p>p是指向指针的指针，p指向的地方存放着一个类型为T*的指针</p></blockquote><blockquote><p><em>p的类型是T\</em></p></blockquote><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">*</span>pp<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//是指向int*类型指针的指针</span><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">;</span><span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">1234</span><span class="token punctuation">;</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>n<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//n的类型是int*</span>pp<span class="token operator">=</span><span class="token operator">&amp;</span>p<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//*pp是p，所以*(*pp)是n</span></code></pre><h2><span id="指针和字符串">指针和字符串</span></h2><blockquote><p>char *p=”asadcd”</p></blockquote><pre class=" language-c"><code class="language-c"><span class="token keyword">char</span> name<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><p>name是char *类型的，name实际上就是地址</p></blockquote><p><a href="https://blog.csdn.net/qq_33757398/article/details/81212618" target="_blank" rel="noopener">C(string.h)字符串操作函数总结</a></p><h2><span id="void指针">void指针</span></h2><p>因sizeof(void)没有定义，所以*p无定义，++p等运算也无定义</p><h3><span id="void指针的用处">void指针的用处</span></h3><p>在头文件<em>cstring</em>中声明的内存操作库函数<em>memset</em>用到了void指针</p><pre><code>void *memset(void * dest,int ch,int n);</code></pre><blockquote><p>dest是void*，所以可以是任何类型的指针，ch是字符的ASCII码</p></blockquote><blockquote><p><strong>将从dest开始的n个<em>字节</em>都设置成ch</strong>，返回值是dest，ch每次只对一个字节起作用。</p></blockquote><pre class=" language-c"><code class="language-c"><span class="token keyword">char</span> a<span class="token punctuation">[</span><span class="token number">200</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">""</span><span class="token comment" spellcheck="true">//空串每一个位置都是"\0"</span><span class="token function">memset</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//将前10个字符设置为’a‘</span></code></pre><p>输出a数组得到aaaaaaaaaa</p><h4><span id="memset函数的用处">memset函数的用处</span></h4><p>清空(运用sizeof)，无穷大(0x3f)，初始化最大值(0x7f)，详解见<a href="https://www.cnblogs.com/handsomecui/p/4723949.html" target="_blank" rel="noopener">memset函数详解</a></p><h2><span id="函数指针">函数指针</span></h2><h3><span id="基本概念">基本概念</span></h3><p>程序运行期间，每个函数都会占用一段连续的内存空间。函数名就是该函数所占内存区域的起始地址（也称入口地址）我们可以将函数的入口地址赋给一个指针变量，然后通过指针变量就可以调用这个函数。这种指向函数的指针变量称为“函数指针”。</p><h3><span id="定义形式">定义形式</span></h3><p>类型名 (*指针变量名)(参数类型1,参数类型二….)</p><blockquote><p>类型名是函数的返回类型</p></blockquote><p>例如：</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span>pf<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><p>表示pf是一个函数指针，他所指向的函数的返回值为int，该函数有两个参数</p></blockquote><h3><span id="使用方法">使用方法</span></h3><p>先定义指针；</p><p>把函数名赋值给指针变量名；</p><p>指针变量名名(实参表)；</p><h4><span id="qsort库函数">qsort库函数</span></h4><p><a href="https://www.icourse163.org/learn/PKU-1001553023#/learn/content?type=detail&amp;id=1004496116&amp;sm=1" target="_blank" rel="noopener">mooc视频</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> c </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用github把本地图片显示到博客上的方法</title>
      <link href="2018/11/21/%E5%88%A9%E7%94%A8github%E6%8A%8A%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%E6%98%BE%E7%A4%BA%E5%88%B0%E5%8D%9A%E5%AE%A2%E4%B8%8A%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>2018/11/21/%E5%88%A9%E7%94%A8github%E6%8A%8A%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%E6%98%BE%E7%A4%BA%E5%88%B0%E5%8D%9A%E5%AE%A2%E4%B8%8A%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>上方展示的图片就是把本地图片传到github然后展示在博客上的结果</p><hr><blockquote><p>想法来源：与某位兄弟聊天时的灵光一闪+闲的慌+知乎+没钱买域名用图床</p></blockquote><h2><span id="准备工作">准备工作</span></h2><ol><li><p>注册了一个github的账号</p></li><li><p>git教程，推荐<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">雪峰老师的网站</a></p></li><li>有git bash</li></ol><hr><h2><span id="新手版">新手版</span></h2><p>第一步，初始化一个文件夹为仓库</p><pre><code>git init</code></pre><p>第二步，将本地仓库与远程仓库连接起来，这里将远程仓库命名为remote images（如何创建远程仓库并进行关联请看git教程）</p><pre><code>git remote add remoteimages github上自己的ssr</code></pre><p>第三步，将本地仓库里的图片添加到暂存区(可一次性add多个图片，只需在后面加上其他图片名)</p><pre><code>git add 图片名</code></pre><p>第四步，提交，注释会成为github上的备注，<strong>注意注释两边是单引号</strong></p><pre><code>git commit -m &#39;注释&#39;</code></pre><p>第五步，推送到远程库</p><pre><code>git push remoteimages master</code></pre><p>第一次推送成功后可简化为</p><pre><code>git push</code></pre><hr><h2><span id="进阶版推送分支">进阶版（推送分支）</span></h2><blockquote><p> 推送分支原因：可进行分类和<em>熟练分支操作（笑</em></p></blockquote><p><strong>在新手版第二步和第三步之前添加</strong></p><p>进阶版第一步：创建并切换分支,此时把新分支命名为people（更多关于分支的教程请看上方git教程）</p><pre><code>checkout -b people</code></pre><p>在分支里commit完图片之后</p><p>第四步：推送到远程仓库，注意原来的master已改成现在的分支名字</p><pre><code>git push remoteimages people</code></pre><p>若想进行简化命令，需要先进行分支关联</p><pre><code>git branch --set-upstream 远程仓库命 需要关联的分支名，比如此处是people</code></pre><p>关联后可进行简化</p><pre><code>git push</code></pre><hr><h2><span id="最后一步啦撒花">最后一步啦撒花！！</span></h2><p>从github的仓库里找到自己需要用到的图片，点击download，复制上方链接即可。</p><h2><span id="一些常用git命令补充">一些常用git命令补充</span></h2><p>查看当前分支</p><pre><code>git branch</code></pre><p>创建分支</p><pre><code>git branch 分支名</code></pre><p>切换分支</p><pre><code>git checkout 分支名</code></pre><p>强行删除分支(通常用于分支里的工作区和缓存区还有文件的情况下)</p><pre><code>git branch -D</code></pre><p>删除分支</p><pre><code>git branch -d</code></pre><p>合并分支：将分支都合并到当前分分支上</p><pre><code>git merge 当前文件名</code></pre><p>查看当前工作区和暂存区的情况</p><pre><code>git status</code></pre><p>删除远程文件</p><pre><code>git rm 需要删除的文件名</code></pre><pre><code>git commit -m 注释</code></pre><pre><code>git push</code></pre><p>不删除本地文件仅删除远程文件</p><pre><code>git rm --cache 文件名（路径）</code></pre><pre><code>git push</code></pre><hr><h2><span id="总结">总结</span></h2><p>这次达成目的的过程还是很顺利的，完美的解决了自己一个多星期以来的问题，github真是太棒了！！顺便还复习了下git23333，发现自己对分支那块还是理解的不透彻呢，等以后用到的时候再去理解吧（笑</p><h2><span id="注释">注释</span></h2><blockquote><p>如果对自己的github进行操作，照片地址会改变，需要更新地址，否则图片不能正常显示。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>静态博客和动态博客的区别，cookie，git里显示‘/’路径的原因</title>
      <link href="2018/11/20/%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%92%8C%E5%8A%A8%E6%80%81%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8Ccookie%EF%BC%8Cgit%E9%87%8C%E6%98%BE%E7%A4%BA%E2%80%98:%E2%80%99%E8%B7%AF%E5%BE%84%E7%9A%84%E5%8E%9F%E5%9B%A0/"/>
      <url>2018/11/20/%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%92%8C%E5%8A%A8%E6%80%81%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8Ccookie%EF%BC%8Cgit%E9%87%8C%E6%98%BE%E7%A4%BA%E2%80%98:%E2%80%99%E8%B7%AF%E5%BE%84%E7%9A%84%E5%8E%9F%E5%9B%A0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>主要内容为hexo静态博客和动态博客的区别，cookie和一个git里显示‘/’路径的小贴士</p></blockquote><h2><span id="hexo静态博客和动态博客的区别">hexo静态博客和动态博客的区别</span></h2><p>文章来源：<a href="https://m.baidu.com/from=1011440l/bd_page_type=1/ssid=0/uid=0/pu=usm%402%2Csz%40320_1001%2Cta%40iphone_2_8.1_24_62.0/baiduid=9624EEC468661DF6136DB86405641041/w=10_10_/t=iphone/l=3/tc?ref=www_iphone&amp;lid=10867688142781950688&amp;order=3&amp;fm=alop&amp;isAtom=1&amp;is_baidu=0&amp;tj=www_normal_3_10_10_title&amp;vit=osres&amp;m=8&amp;srd=1&amp;cltj=cloud_title&amp;asres=1&amp;title=%E6%90%AD%E5%BB%BAHexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E8%BF%87%E7%A8%8B-%E5%8A%A8%E6%80%81%E4%B8%8E%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%8C%BA%E5%88%AB%7C%E7%BF%94%E5%85%BD...&amp;dict=32&amp;wd=&amp;eqid=96d1c8c9503e2800100000025bf36a58&amp;w_qd=IlPT2AEptyoA_yk66uAd5gixIE-SiGooxjQYiBPVr4i&amp;tcplug=1&amp;sec=34321&amp;di=922240928aa871e7&amp;bdenc=1&amp;tch=124.388.279.506.0.0&amp;nsrc=IlPT2AEptyoA_yixCFOxXnANedT62v3IJBaOMmBHBi3mjo39hLWxBgQqE7eqAp8GS9Cb9jDLxBt8tUGh3m5mz_EvuBdlxldRzkuM8_m5rADrGQ2fhxYZChPnHGU_s_nQbLxPc12tEMEsVH9Ozq4Jos94u2_pbcYob2a2hWTGs3br2pTvZUb-mUqT_kk4ODqcOOfYaPqznHEuLZrd3dOhJISRnXRUQyhvcLrqbu-ZQ3WYpnJzHtm7Dc23WV7YIiw1ZhvrU2nvwRDJXiNYqJ15TnFR8XH-5t3ZIUa&amp;clk_type=1&amp;l=1&amp;baiduid=9624EEC468661DF6136DB86405641041&amp;w=10_10_%E4%BB%80%E4%B9%88%E5%8F%AB%E5%8A%A8%E6%80%81%E5%8D%9A%E5%AE%A2&amp;t=iphone&amp;from=1011440l&amp;ssid=0&amp;uid=0&amp;bd_page_type=1&amp;pu=usm%402%2Csz%40320_1001%2Cta%40iphone_2_8.1_24_62.0&amp;clk_info=%7B%22srcid%22%3A1599%2C%22tplname%22%3A%22www_normal%22%2C%22t%22%3A1542679132628%2C%22xpath%22%3A%22div-article-section-div-div-a-div-div-span%22%7D&amp;sfOpen=1" target="_blank" rel="noopener">静态博客和动态博客的区别</a></p><p>浏览网站的这一过程，本质上就是自己电脑上的浏览器程序解释通过Http协议从网站上下载下来的HTML文本的过程。而动态博客与静态博客的区别就在于这样一个HTML文本是通过什么方式生成的。</p><p>对于<strong>动态博客</strong>来说，每当你访问一个页面时（例如博文目录），就会根据对应页面的逻辑去数据库中查询相应信息（查询当前所有文章信息），根据当前博客站点的主题取一个模板文件按照HTML语法填入相应信息（填入文章名、文章日期、文章摘要等，还可以作分页，依据逻辑而定），组合成一个HTML文本，下发给访问者。</p><p>而对于<strong>静态博客</strong>来说，这整个将模板渲染为可被浏览器直接识别的HTML文本的任务是早在博文写好的那一刻完成的。事实上，我们说的静态的博客，也就可以看作是一个托管许多互相跳转的HTML文本文件服务器罢了。</p><p>也许有的人会问：既然对于访问者来说都生成了一个博客网页，那么动态博客与静态博客用起来又有什么区别呢？</p><p>事实上，动态博客在生成网页的时候还可以有更多“花招”。例如，你需要一个带有权限组的博客系统，某些内容只有拥有账号的访问者才能看到。博客“程序”可以维护一组cookie的状态，当一个新的访问者访问内容时，查询他对应的cookie状态是否为已登录，如果未登录，则下发一个“登录界面”给他，并处理登录逻辑。</p><p>总而言之，<strong>“动态”一词指的本来就是一个页面并不是固定的，而是依据状态、不同的访问者而改变的，动态博客也得益于此可以具有许多功能</strong>。</p><p>其实这里还有一个问题，那是不是意味着静态博客除了发布文章以外就不能实现别的功能了呢？毕竟它只是相当于托管了一组HTML文件而已，不能提供“动态”的效果。</p><p>非也非也，刚才说的只是服务端那边的花招，其实除此以外还有文章可作。</p><p>比如，使用ajax技术：由服务端下发到浏览器中的HTML文件中并不是只有文件内容而已，其实，它还可以承装脚本。而javascript在浏览器中被执行时拥有改变当前HTML内容的能力，因此，可以在此处写与之前动态博客渲染模板相仿的逻辑。</p><p>但是，如果在静态博客中使用这样的技术，静态博客就失去了与动态博客相比的高性能、高安全性了（因为javascript发挥作用显然也需要布置后端程序、数据库在服务器上），因此，静态博客中一般不部署产生动态内容的功能，或是仅在网页中植入一点第三方提供的如评论、分享等功能。</p><hr><h2><span id="cookie">COOKIE</span></h2><p>cookie是<strong>临时文件</strong>，Cookies是一种能够让网站服务器把少量数据储存到客户端的硬盘或内存，或是从客户端的硬盘读取数据的一种<strong>技术</strong>。Cookies是当你浏览某网站时，由Web服务器置于你硬盘上的一个非常小的文本文件，它可以记录你的用户ID、密码、浏览过的网页、停留的时间等信息。</p><p>当你再次来到该网站时，网站通过读取Cookies，得知你的相关信息，就可以做出相应的动作，如在页面显示欢迎你的标语，或者让你不用输入ID、密码就直接登录等等。从本质上讲，它可以看作是你的身份证。但Cookies不能作为代码执行，也不会传送病毒，且为你所专有，并<strong>只能由提供它的服务器来读取</strong>。保存的信息片断以”名/值”对(name-value pairs)的形式储存，一个”名/值”对仅仅是一条命名的数据。一个网站只能取得它放在你的电脑中的信息，它无法从其它的Cookies文件中取得信息，也无法得到你的电脑上的其它任何东西。 Cookies中的内容大多数经过了<em>加密处理</em>，因此一般用户看来只是一些毫无意义的字母数字组合，只有服务器的CGI处理程序才知道它们真正的含义。</p><p>由于Cookies是我们浏览的网站传输到用户计算机硬盘中的文本文件或内存中的数据，因此它在硬盘中存放的位置与使用的<a href="https://www.baidu.com/s?wd=%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">操作系统</a>和浏览器密切相关。在Windows 9X系统计算机中，Cookies文件的存放位置为C:/Windows/Cookies，在Windows NT/2000/XP的计算机中，Cookies文件的存放位置为C:/Documents and Settings/用户名/Cookies。</p><p>硬盘中的Cookies文件可以被<a href="https://www.baidu.com/s?wd=Web%E6%B5%8F%E8%A7%88%E5%99%A8&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">Web浏览器</a>读取，它的命令格式为：用户名@网站地址[数字].txt。如笔者计算机中的一个Cookies文件名为：ch@163[1].txt。要注意的是：硬盘中的Cookies属于文本文件，不是程序。  </p><hr><h2><span id="git里显示路径的原因">git里显示‘/’路径的原因</span></h2><p>一般git里面仓库操作不能到‘/’，所以如果显示‘/’，说明这是模拟路径，是虚拟出来的一个根目录，下面链接到盘符，实际在安装目录（/c/xxx）【未尝试过，不确定是在c盘还是在实际安装目录】</p>]]></content>
      
      
      <categories>
          
          <category> 概念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> 博客 </tag>
            
            <tag> cookie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2018/11/18/hello-world/"/>
      <url>2018/11/18/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2><span id="quick-start">Quick Start</span></h2><h3><span id="create-a-new-post">Create a new post</span></h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><h3><span id="run-server">Run server</span></h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3><span id="generate-static-files">Generate static files</span></h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3><span id="deploy-to-remote-sites">Deploy to remote sites</span></h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>archlinux基础安装步骤</title>
      <link href="2018/11/18/archlinux%E5%9F%BA%E7%A1%80%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4/"/>
      <url>2018/11/18/archlinux%E5%9F%BA%E7%A1%80%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4/</url>
      
        <content type="html"><![CDATA[<p>使用虚拟机安装archlinux的步骤简单介绍,一下都是legacy启动模式</p><hr><h2><span id="参考资料">参考资料</span></h2><ol><li><a href="https://wiki.archlinux.org/index.php/Installation_guide" target="_blank" rel="noopener">ArchWiki</a>，根据上面指令即可完成安装</li><li><a href="https://www.jianshu.com/p/98b8965b1d10" target="_blank" rel="noopener">在 VirtualBox 里安装 Arch Linux 操作系统</a></li><li><a href="https://www.cnblogs.com/zhaojiedi1992/p/zhaojiedi_linux_039_fdisk_gdisk_parted.html" target="_blank" rel="noopener">linux下（fdisk,gdisk,parted）三种分区工具比较</a></li><li><a href="http://blog.51cto.com/wushank/1244191" target="_blank" rel="noopener">linux分区之ext2,ext3,ext4,gpt</a></li><li><a href="https://blog.csdn.net/qq_39521554/article/details/79501714" target="_blank" rel="noopener">Linux学习笔记（二）：什么是挂载？mount的用处在哪?</a></li><li><a href="https://my.oschina.net/itlangz/blog/1936094" target="_blank" rel="noopener">Arch Linux 基本系统安装教程( UEFI+GPT ) </a></li></ol><hr><h2><span id="archlinux和linux的联系">ArchLinux和Linux的联系</span></h2><p>商家将Linux系统的内核与外围应用软件和文档包装起来, 并提供系统安装界面和系统设置管理工具, 这样就构成了一个发行版本, <strong>ArchLinux</strong>是其中一个发行版本。</p><h3><span id="archlinux-principles">Archlinux Principles</span></h3><blockquote><ul><li><p>Simplicity:  Arch Linux defines simplicity as <em>without unnecessary additions or modifications</em>.</p></li><li><p>Modernity:  a one-time installation with continuous upgrades</p></li><li><p>Pragmatism(实用): The large number of packages and build scripts in the various Arch Linux repositories offer free and open source software for those who prefer it, as well as proprietary software packages for those who embrace functionality over ideology.                  </p></li><li><p>翻译：Arch Linux 的仓库中包含大量的软件包和编译脚本。用户可以按照需要进行自由选择。仓库中既提供了开源、自由的软件，也提供了闭源软件。<strong>实用性大于意识形态</strong>.</p></li><li><p>User centrality: All users are encouraged to <a href="https://wiki.archlinux.org/index.php/Getting_involved" target="_blank" rel="noopener">participate</a> and contribute to the distribution.</p></li><li><p>Versality(通用): Arch Linux is a general-purpose distribution. Upon installation, only a command-line environment is provided: rather than tearing out unneeded and unwanted packages, the user is offered the ability to build a custom system by choosing among thousands of high-quality packages provided in the <a href="https://wiki.archlinux.org/index.php/Official_repositories" target="_blank" rel="noopener">official repositories</a> for the <a href="https://en.wikipedia.org/wiki/x86-64" target="_blank" rel="noopener">x86-64</a> architecture.</p><p>Arch is backed by <a href="https://wiki.archlinux.org/index.php/Pacman" target="_blank" rel="noopener">pacman</a>, a lightweight, simple and fast package manager that allows to upgrade the entire system with one command. Arch also provides the <a href="https://wiki.archlinux.org/index.php/Arch_Build_System" target="_blank" rel="noopener">Arch Build System</a>, a ports-like system to make it easy to build and install packages from source, which can also be synchronized with one command. In addition, the <em>Arch User Repository</em> contains many thousands more of community-contributed <a href="https://wiki.archlinux.org/index.php/PKGBUILD" target="_blank" rel="noopener">PKGBUILD</a> scripts for compiling installable packages from source using the <a href="https://wiki.archlinux.org/index.php/Makepkg" target="_blank" rel="noopener">makepkg</a> application. It is also possible for users to build and maintain their own custom repositories with ease. </p><p>翻译：Arch Linux 是通用发行版，初始安装仅提供命令行环境：用户不需要删除大量不需要的软件包，而是可以从<a href="https://wiki.archlinux.org/index.php/%E5%AE%98%E6%96%B9%E8%BD%AF%E4%BB%B6%E4%BB%93%E5%BA%93" target="_blank" rel="noopener">官方软件仓库</a>成千上万的高质量软件包中进行选择，搭建自己的系统。支持<a href="https://en.wikipedia.org/wiki/x86-64" target="_blank" rel="noopener">x86-64</a> 架构。</p><p>Arch有一个易用的<a href="https://en.wikipedia.org/wiki/Package_manager" target="_blank" rel="noopener">包管理系统</a><a href="https://wiki.archlinux.org/index.php/Pacman_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87" target="_blank" rel="noopener">Pacman</a>)，仅凭一条命令就升级整个系统。Arch还提供一个类似ports的包构建系统（<a href="https://wiki.archlinux.org/index.php/Arch_Build_System_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87" target="_blank" rel="noopener">Arch Build System</a>)），通过它可以轻松从源码构建和安装软件包，并用一个命令完成同步。你甚至可以用一个命令重新构建整个系统。Arch还提供<a href="https://wiki.archlinux.org/index.php/Arch_User_Repository_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87" target="_blank" rel="noopener">Arch User Repository</a>)，它包含了数千个由用户维护的<a href="https://wiki.archlinux.org/index.php/PKGBUILD_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87" target="_blank" rel="noopener">PKGBUILD</a>)脚本，配合<a href="https://wiki.archlinux.org/index.php/Makepkg_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87" target="_blank" rel="noopener">makepkg</a>)工具，从编译到打包一气呵成。用户还能轻松构建和维护属于自己的自定义软件源。                                                                                                                      </p></li></ul></blockquote><h3><span id="算了还是用中文吧">算了还是用中文吧</span></h3><h2><span id="准备工作">准备工作</span></h2><h3><span id="下载archlinux">下载archlinux</span></h3><p>推荐从<a href="https://mirrors.tuna.tsinghua.edu.cn/archlinux/iso/" target="_blank" rel="noopener">清华镜像站</a>任选一个版本下载</p><h4><span id="什么是开源镜像站">什么是开源镜像站</span></h4><p>因为源的主机在一个地方，其它一些稍微远的地方的机器从这个源上更新比较慢，所以就会在离自己近的地方将这个源同步复制过来，这样从镜像站的源更新就会比之前快很多了。所以这就是为什么会有很多大学镜像站，因为都是同步到了校园内的主机，对于校园内网来说速度会飞快。（然而hdu并没有嘤嘤嘤）</p><h4><span id="不同的iso版本有什么区别吗">不同的ISO版本有什么区别吗</span></h4><p>我也不知道，大概没有吧</p><h4><span id="x86-64">x86-64</span></h4><p>X86-64可在同一时间内处理64位的整数运算，并兼容X86-32架构。其中支持64位逻辑定址，同时提供转换为32位定址选项；但数据操作指令默认为32位和8位，提供转换成64位和16位的选项；支持常规用途<a href="https://baike.baidu.com/item/%E5%AF%84%E5%AD%98%E5%99%A8/187682" target="_blank" rel="noopener">寄存器</a>，如果是32<a href="https://baike.baidu.com/item/%E4%BD%8D%E8%BF%90%E7%AE%97" target="_blank" rel="noopener">位运算</a>操作，就要将结果扩展成完整的64位。这样，指令中有“直接执行”和“转换执行”的区别，其指令字段是8位或32位，可避免字段过长。x86处理器的32bit<a href="https://baike.baidu.com/item/%E5%AF%BB%E5%9D%80%E7%A9%BA%E9%97%B4/7848599" target="_blank" rel="noopener">寻址空间</a>限制在4GB内存，而IA-64的处理器又不能兼容x86。AMD考虑顾客需求，加强x86<a href="https://baike.baidu.com/item/%E6%8C%87%E4%BB%A4%E9%9B%86/238130" target="_blank" rel="noopener">指令集</a>的功能，使这套指令集可同时支持64位的运算模式，因此AMD把它们的结构称之为x86-64。<strong>总之最近几年的电脑都是64位处理器的cpu</strong></p><h3><span id="在虚拟机上导入archlinux的iso">在虚拟机上导入archlinux的iso</span></h3><p>选择x64，若未跳出此选项进入bios（一般是F2，F10和Del键）enable虚拟机选项</p><h4><span id="bios的两种形式">BIOS的两种形式</span></h4><p><strong>BIOS包含UEFI和legacy（传统）两种启动模式</strong>，<strong>UEFI</strong>全称“统一的可扩展固件接口”(Unified Extensible Firmware Interface)， 是一种详细描述类型接口的标准。这种接口用于操作系统自动从预启动的操作环境，加载到一种操作系统上。UEFI方式减少了BIOS的自检过程，因此能够缩短开机时间，UEFI只支持64为系统且磁盘分区必须为gpt模式。如果你的PC在UEFI启动模式下预装了Win10，你会发现有两个很小的隐藏分区。一个叫<strong>ESP</strong>(EFI系统分区)，另一个<strong>MSR</strong>(Microsoft保留分区，通常为128MB)，MSR是windows要求的。ESP对UEFI启动模式很重要，UEFI的引导程序是以后缀名为.efi的文件存放在ESP分区中的，ESP分区采用fat32文件系统。此外，可能还存在一个小分区叫<strong>WinRETools</strong>，这个是win10的恢复分区</p><h4><span id="csm">CSM</span></h4><p>CSM是一个兼容支持模块，可以让新的UEFI BIOS兼容老的legacy+MBR启动模式。</p><h4><span id="gpt">GPT</span></h4><p>GPT是一种<strong>新型磁盘模式</strong>，与我们常用的MBR磁盘相比更稳定，自纠错能力更强，一块磁盘上主分区数量不受限制，支持大于2T的总容量及大于2T的分区，并且几乎没有上限，最大支持到128个分区，分区大小支持到256TB。</p><blockquote><p>补充：GPT和MBR和都是引导硬盘或者u盘进去<a href="https://www.baidu.com/s?wd=%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">操作系统</a>的主<a href="https://www.baidu.com/s?wd=%E5%BC%95%E5%AF%BC%E6%96%87%E4%BB%B6&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">引导文件</a>，MBR识别最大2TB的分区，GPT可以识别最大256TB分区， 相比之下MBR更安全。</p></blockquote><hr><h2><span id="安装archlinux">安装archlinux</span></h2><p>不是UEFI模式，不需要验证启动模式。</p><hr><h3><span id="connect-to-the-lnternet">Connect to the lnternet</span></h3><p>The installation image enables the <a href="https://wiki.archlinux.org/index.php/Dhcpcd" target="_blank" rel="noopener">dhcpcd</a> daemon for <a href="https://git.archlinux.org/archiso.git/tree/configs/releng/airootfs/etc/udev/rules.d/81-dhcpcd.rules" target="_blank" rel="noopener">wired network devices</a> on boot. The connection may be verified with <a href="https://en.wikipedia.org/wiki/ping_(networking_utility" target="_blank" rel="noopener">ping</a>): </p><pre><code># ping archlinux.org</code></pre><p>If no connection is available, <a href="https://wiki.archlinux.org/index.php/Stop" target="_blank" rel="noopener">stop</a> the <em>dhcpcd</em> service with <code>systemctl stop dhcpcd@*interface*</code> where the  <em>interface</em> name can be <a href="https://en.wikipedia.org/wiki/Command-line_completion" target="_blank" rel="noopener">tab-completed</a>. Proceed to configure the network as described in <a href="https://wiki.archlinux.org/index.php/Network_configuration" target="_blank" rel="noopener">Network configuration</a>.</p><h4><span id="dhcped">dhcped</span></h4><p>The <a href="https://www.archlinux.org/packages/?name=dhcpcd" target="_blank" rel="noopener">dhcpcd</a> package is part of the <a href="https://www.archlinux.org/groups/x86_64/base/" target="_blank" rel="noopener">base</a> group, so it is likely already installed on your system.</p><p>DHCP（Dynamic Host Configuration Protocol，动态主机配置协议）是一个<strong>局域网的网络协议</strong>，使用UDP协议工作， 主要有两个用途：</p><blockquote><ul><li>给内部网络或网络服务供应商自动分配IP地址，</li></ul></blockquote><blockquote><ul><li>给用户或者内部网络管理员作为对所有计算机作中央管理的手段，</li></ul></blockquote><p><strong>DHCP具有以下功能</strong></p><ol><li><p>保证任何IP地址在同一时刻只能由一台DHCP客户机所使用。</p></li><li><p>DHCP应当可以给用户分配永久固定的IP地址。</p></li><li><p>DHCP应当可以同用其他方法获得IP地址的主机共存（如手工配置IP地址的主机）。</p></li><li><p>DHCP服务器应当向现有的BOOTP客户端提供服务。</p></li></ol><hr><h3><span id="分区">分区</span></h3><h4><span id="分区方式">分区方式</span></h4><h5><span id="选择-gpt-还是-mbr">选择 GPT 还是 MBR</span></h5><p><a href="https://wiki.archlinux.org/index.php/GUID_Partition_Table" target="_blank" rel="noopener">GUID Partition Table</a> （GPT）是一种更灵活的分区方式。它正在逐步取代<a href="https://wiki.archlinux.org/index.php/Master_Boot_Record" target="_blank" rel="noopener">Master Boot Record</a> （MBR）系统。GPT相对于诞生于MS-DOS时代的MBR而言，有许多优点。新版的<em>fdisk</em>（MBR）和<em>gdisk</em>（GPT）使得使用GPT或者MBR在可靠性和性能最大化上都非常容易。</p><p>在做出选择前，需要考虑如下内容：</p><ul><li>如果使用 GRUB legacy 作为bootloader，必须使用MBR。</li><li><strong>如果使用传统的BIOS（legacy)，并且双启动中包含 Windows （无论是32位版还是64位版），必须使用MBR</strong></li><li>如果使用 <a href="https://wiki.archlinux.org/index.php/UEFI" target="_blank" rel="noopener">UEFI</a> 而不是BIOS，并且双启动中包含 Windows 64位版，必须使用GPT。</li><li>非常老的机器需要使用 MBR，因为 BIOS 可能不支持 GPT.</li><li>如果不属于上述任何一种情况，可以随意选择使用 GPT 还是 MBR。由于 GPT 更先进，建议选择 GPT。</li><li>建议在使用 <a href="https://wiki.archlinux.org/index.php/Unified_Extensible_Firmware_Interface" target="_blank" rel="noopener">UEFI</a> 的情况下选择 GPT，因为有些 UEFI firmware 不支持从 MBR 启动。</li></ul><blockquote><p>补充：MBR（Master Boot Record）,即主引导记录，位于整个硬盘的0磁道0柱面1扇区。不过，在总共512字节的主引导扇区中，MBR只占用了其中的446个字节（偏移0–偏移1BDH），另外的64个字节（偏移1BEH–偏移1FDH）交给了DPT(Disk<br>PartitionTable硬盘分区表),最后两个字节”55，AA”（偏移1FEH-偏移1FFH）是分区的结束标志。这个整体构成了硬盘的主引导扇区。</p></blockquote><h4><span id="分区表">分区表</span></h4><p>目前有三种分区类型：</p><ul><li>主分区（Primary）</li><li>扩展分区（Extended）<ul><li>逻辑分区（Logical）</li></ul></li></ul><p><strong>主分区</strong>每个磁盘或者RAID卷上只能有4个，可设置为可启动状态。如果分区方案要求使用4个以上的分区，就需将至少一个分区设置为<strong>扩展分区</strong>,并在上面建立<strong>逻辑分区</strong>。<strong>扩展分区</strong>可以被看作是容纳逻辑分区的容器。硬盘上<em>最多只能有1个</em>扩展分区。如果磁盘上有1个扩展分区，<em>它也被看作是1个主分区</em>。因此只能另外再建立3个主分区（例如3个主分区加1个扩展分区）。扩展分区内所包含的逻辑分区数量没有限制。如果在双重启动中有Windows，Windows需要占据一个主分区。</p><blockquote><p>通常习惯是创建主分区<em>sda1</em>到<em>sda3</em>，然后建立一个扩展分区<em>sda4</em>。<em>sda4</em>中包含<em>sda5</em>，<em>sda6</em>等逻辑分区。</p></blockquote><blockquote><p>命名为sda_的原因：SCSI接口设备是用sd命名的，其中a表示硬盘编号可能是a、b、c等等,sda是未分区、未格式化的原始硬盘空间。</p></blockquote><blockquote><p>只能分配4个主分区的原因：MBR（Master Boot Record）只有存放4个分区信息的空间（64字节）</p></blockquote><h4><span id="分区工具">分区工具</span></h4><p>Linux has at least 3 disk tools FDISK;CFDISK;SFDISK. <em>这里使用有交互界面的 <strong>cfdisk</strong> 工具</em></p><blockquote><p> cfdisk和fdisk没有联系但功能一样</p></blockquote><h4><span id="开始分区">开始分区</span></h4><p>When recognized by the live system, disks are assigned to a <a href="https://en.wikipedia.org/wiki/Device_file#Naming_conventions" target="_blank" rel="noopener">block device</a> such as <code>/dev/sda</code> or <code>/dev/nvme0n1</code>. To identify these devices, use <a href="https://wiki.archlinux.org/index.php/Lsblk" target="_blank" rel="noopener">lsblk</a> or <em>fdisk</em>.</p><pre><code># fdisk -l</code></pre><pre><code># lsblk</code></pre><blockquote><p> 区别：fdisk列出所有block device，lsblk则更简洁，只列出loop0，sr0和硬盘，<strong>推荐用lsblk查看分区情况</strong></p></blockquote><p>使用cfdisk工具进行新建分区等操作</p><pre><code># cfdisk</code></pre><h6><span id="简单英文解释">简单英文解释</span></h6><ol><li>bootable：可引导的（<em>待补充</em>）</li><li>resize：重新指定分区大小，当硬盘空间为8g，已有分区为8g，则需resize使已有分区&lt;8g才能够新建分区。</li><li>type：the type of partition,比如（Linux,Linux extended,CP/M)</li><li>write: 只有在进行此操作后此前进行过的修改才会保存</li><li>dump：</li><li>quit:<strong>不保存</strong>在write之前的修改并退出</li></ol><hr><blockquote><p>补充：root是用户名，前面数字是上一个命令的exit status，出现1root，127root等是某种东西报错，使用exit回到root。</p></blockquote><hr><h4><span id="对分区进行格式化">对分区进行格式化</span></h4><pre><code># mkfs.ext4 /dev/sda1</code></pre><blockquote><p>添加分区之前要将磁盘格式化为某个具体的文件格式，这样才能正常存储和读取。</p><p>使用mkfs -t 格式类型 磁盘路径 或 mkfs.格式类型 磁盘路径</p></blockquote><h5><span id="ext4">ext4</span></h5><p>EXT4（第四扩展文件系统）：文件系统是Linux系统下的日志文件系统，是ext3文件系统的后继版本，但是Ext4是Linux文件系统的一次改进。在很多方面，Ext4相对于Ext3的进步要远超过Ext3相对于Ext2的进步。Ext3相对于 Ext2的改进主要在于日志方面，但是Ext4相对于Ext3的的改进是更深层次的，是文件系统数据结构方面的优化，是一个高效的、优秀的、可靠的和极具特点的文件系统，并且EXT3可以转为EXT4的。</p><hr><h3><span id="挂载文件系统">挂载文件系统</span></h3><p><a href="https://wiki.archlinux.org/index.php/Mount" target="_blank" rel="noopener">Mount</a> the file system on the root partition to <code>/mnt</code>, for example:</p><p>使/dev/sda1上的文件系统挂载到/mnt上</p><pre><code>#mount /dev/sda1 /mnt</code></pre><p>为任何剩余的分区创建安装点并相应地安装它们：</p><pre><code>#mkdir /mnt/boot #mount /dev/sda2/ mnt/boot</code></pre><p>取消挂载</p><pre><code>#umount /dev/sda2</code></pre><p>或者q取消全部挂载</p><pre><code>#umount /mnt</code></pre><p>列出已安装的文件系统</p><pre><code>#findmnt</code></pre><p><em>findmnt</em>采用各种参数，可以过滤输出并显示其他信息。例如，它可以将设备或挂载点作为参数来仅显示有关指定内容的信息：</p><pre><code># findmnt /dev/sda1</code></pre><h5><span id="mount">mount</span></h5><p>This attaches the filesystem on <code>/dev/sda1</code> at the directory <code>/mnt</code>, making the contents of the filesystem <strong>visible</strong>. Any data that existed at <code>/mnt</code> before this action is made <strong>invisible</strong> until the device is <strong>unmounted</strong>.</p><h5><span id="源于linux学习笔记二什么是挂载mount的用处在哪">源于</span></h5><p>linux操作系统将所有的设备都看作文件，它将整个计算机的资源都整合成一个大的文件目录。我们要访问存储设备中的文件，必须将文件所在的分区挂载到一个已存在的目录上，然后通过访问这个目录来访问存储设备。挂载就是把设备放在一个目录下，让系统知道怎么管理这个设备里的文件，了解这个存储设备的可读写特性之类的过程。</p><p>/dev/sda1不是它的目录。虽然/dev是个目录，但/dev/sda1不是目录。可以发现ls/dev/sda1无法执行。/dev/sda1，是一个类似指针的东西，指向这个分区的原始数据块。mount前，系统并不知道这个数据块哪部分数据代表文件，如何对它们操作。</p><blockquote><ul><li>补充：一般情况下关机自动取消挂载</li><li>可配置文件是他永久挂载</li></ul></blockquote><hr><h2><span id="installation">Installation</span></h2><h3><span id="select-the-mirrors">Select the mirrors</span></h3><p>Packages to be installed must be downloaded from <a href="https://wiki.archlinux.org/index.php/Mirrors" target="_blank" rel="noopener">mirror servers</a>, which are defined in <strong><code>/etc/pacman.d/mirrorlist</code>.</strong> On the live system, all mirrors are enabled, and sorted by their synchronization status and speed at the time the installation image was created.</p><p>The higher a mirror is placed in the list, the more priority it is given when downloading a package. You may want to edit the file accordingly, and <strong>move the geographically closest mirrors to the top of the list</strong>, although other criteria should be taken into account.</p><p>This file will later be copied to the new system by <em>pacstrap</em>, so it is worth getting right.</p><h4><span id="更改镜像源">更改镜像源</span></h4><p>更改镜像源的原因与从开源镜像站下载iso的原因相同，都是为了下载更快更稳定。</p><p>打开镜像源文件</p><pre><code>vim /etc/pacman.d/mirrorlist</code></pre><p>在开头模仿已有镜像源的样子(在后面加上…）加入各镜像站，推荐<a href="https://mirrors.tuna.tsinghua.edu.cn/" target="_blank" rel="noopener">清华镜像站</a>,<a href="https://mirrors.163.com/" target="_blank" rel="noopener">网易镜像站</a>,可参考<a href="https://www.cnbeta.com/articles/soft/194758.htm" target="_blank" rel="noopener">大陆各镜像站汇总</a>和<a href="https://www.archlinux.org/mirrors/status/" target="_blank" rel="noopener">镜像汇总</a>，用w保存编辑，q退出，<strong>!q</strong>是不保存编辑并退出 </p><h3><span id="install-the-base-packages">Install the base packages</span></h3><p>Use the <a href="https://projects.archlinux.org/arch-install-scripts.git/tree/pacstrap.in" target="_blank" rel="noopener">pacstrap</a> script to install the <a href="https://www.archlinux.org/groups/x86_64/base/" target="_blank" rel="noopener">base</a> package group:</p><pre><code># pacstrap /mnt base</code></pre><p>This group does not include all tools from the live installation, such as <a href="https://www.archlinux.org/packages/?name=btrfs-progs" target="_blank" rel="noopener">btrfs-progs</a> or specific wireless firmware; see <a href="https://projects.archlinux.org/archiso.git/tree/configs/releng/packages.x86_64" target="_blank" rel="noopener">packages.x86_64</a> for comparison.</p><p>To <a href="https://wiki.archlinux.org/index.php/Install" target="_blank" rel="noopener">install</a> packages and other groups such as <a href="https://www.archlinux.org/groups/x86_64/base-devel/" target="_blank" rel="noopener">base-devel</a>, append the names to <em>pacstrap</em> (space separated) or to individual <a href="https://wiki.archlinux.org/index.php/Pacman" target="_blank" rel="noopener">pacman</a> commands after the <a href="https://wiki.archlinux.org/index.php/Installation_guide#Chroot" target="_blank" rel="noopener">#Chroot</a> step.</p><blockquote><ul><li>pacstrap：按字面理解，pac就是package（软件包），strap的意思是用带子捆扎，pacstrap意思就是打好包的软件，在arch系统这是一个脚本文件的名称，它的作用就是安装arch基本系统。</li><li>base package group：<em>基本</em>的软件包<em>包括</em>了系统运行所必需的所有软件包。比如有GNU BASH shell、文件压缩工具、文件<em>系统</em>管理工具、C 语言库、压缩工具等</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个随机生成身份证码的网页</title>
      <link href="2018/11/17/%E5%88%A9%E7%94%A8flask%E6%A1%86%E6%9E%B6%E5%81%9A%E4%B8%80%E4%B8%AA%E9%9A%8F%E6%9C%BA%E7%94%9F%E6%88%90%E8%BA%AB%E4%BB%BD%E8%AF%81%E7%A0%81%E7%9A%84%E7%BD%91%E9%A1%B5/"/>
      <url>2018/11/17/%E5%88%A9%E7%94%A8flask%E6%A1%86%E6%9E%B6%E5%81%9A%E4%B8%80%E4%B8%AA%E9%9A%8F%E6%9C%BA%E7%94%9F%E6%88%90%E8%BA%AB%E4%BB%BD%E8%AF%81%E7%A0%81%E7%9A%84%E7%BD%91%E9%A1%B5/</url>
      
        <content type="html"><![CDATA[<h2><span id="任务">任务</span></h2><p>做出一个随机生成身份证码的网页</p><hr><h2><span id="前期准备">前期准备</span></h2><ol><li><a href="https://www.bilibili.com/video/av19817183/?p=14" title="黑马程序员的入门视频" target="_blank" rel="noopener">黑马程序员入门视频</a>（表单之前即可完成任务）</li><li><a href="https://dormousehole.readthedocs.io/en/latest/" title="flask官方中文手册" target="_blank" rel="noopener">flask官方中文手册</a></li><li><a href="http://flask.pocoo.org/" title="flask官方英文手册" target="_blank" rel="noopener">flask官方英文手册</a></li><li>pycharm3专业版</li><li>在终端上生成身份证的代码</li></ol><h3><span id="安装flask">安装flask</span></h3><pre><code>pip install Flask</code></pre><p>在命令行上输完这条命令就可以开心地开始用py啦~（话说我不知道如果不输这条命令会有什么样的结果诶）</p><h3><span id="各文件夹里的内容">各文件夹里的内容</span></h3><blockquote><p><strong>template_folder</strong>：模板所在文件夹的名字</p><p>此任务只需用到这个文件夹即可，在templates文件夹里创建html类型，html上的内容会显示在页面上</p><p>而py类型的文件是单独存放的</p></blockquote><p><strong>root_path</strong>：可以不用填，会自动找到，当前执行文件，所在目录地址</p><p>在return render_template时会将上面两个进行拼接，找到对应的模板地址</p><p><strong>static_folder</strong>：静态文件所在文件的名字，默认是static，可以不用填</p><p><strong>static_url_path</strong>：静态文件的地址前缀，写成什么，访问静态文件时，就要在前面加上这个</p><pre><code>app = Flask(__name__,template_folder=&#39;templates&#39;,static_url_path=&#39;/xxxxxx&#39;)</code></pre><p> 如：在根目录下创建目录，templates和static，则return render_template时，可以找到里面的模板页面；如在static文件夹里存放11.png，在引用该图片时，静态文件地址为：/xxxxxx/11.png</p><hr><h2><span id="基本操作">基本操作</span></h2><p>放在每个函数最前面，/是指路径，get是获得网页内容，post是向网页进行推送，方法可按需选择</p><pre class=" language-python"><code class="language-python">@app<span class="token punctuation">.</span>route<span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">,</span> methods<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'GET'</span><span class="token punctuation">,</span> <span class="token string">'POST'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#py文件里面的内容</span></code></pre><p>需要导入的文件</p><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> flask <span class="token keyword">import</span> Flask<span class="token punctuation">,</span> render_template<span class="token punctuation">,</span> flash<span class="token punctuation">,</span> request</code></pre><p>获取用户输入的参数：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">if</span> request<span class="token punctuation">.</span>method <span class="token operator">==</span> <span class="token string">'POST'</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true">#py文件里面的内容</span>    <span class="token comment" spellcheck="true"># 获取参数 year month day</span>    year <span class="token operator">=</span> request<span class="token punctuation">.</span>form<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'year'</span><span class="token punctuation">)</span>    month <span class="token operator">=</span> request<span class="token punctuation">.</span>form<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'month'</span><span class="token punctuation">)</span>    date <span class="token operator">=</span> request<span class="token punctuation">.</span>form<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'date'</span><span class="token punctuation">)</span></code></pre><p>此时html里相关部分的内容：</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">method</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>post<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span><span class="token punctuation">></span></span>出生年份：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">></span></span>&lt;input type="text"name="year"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span><span class="token punctuation">></span></span>出生月份：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">></span></span>&lt;input type="text"name="month"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span><span class="token punctuation">></span></span>出生日期：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">></span></span>&lt;input type="text"name="date"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">></span></span>    &lt;input type="submit"value="提交"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span></code></pre><blockquote><p><strong>py里面get的变量名必须和html的name相同</strong></p></blockquote><hr><h4><span id="上述内容的简单解释">上述内容的简单解释</span></h4><h5><span id="form">form</span></h5><p>form是显示出来的表格</p><p> html的/form是指form结束的意思</p><h5><span id="注释">注释</span></h5><p>py的注释为#</p><p>html的注释为</p><h5><span id="变量后面会有相关的代码和更详细的解释现在看不懂也没关系">变量（后面会有相关的代码和更详细的解释，现在看不懂也没关系）</span></h5><p>html中的</p><pre><code>{{}}</code></pre><p>是变量模块，可在p y里面用return（）将python里的变量输入到html中的变量然后显示出来，html中得到的变量可通过在py中用requet. form.get（）传给python</p><h5><span id="关于导入的文件">关于导入的文件</span></h5><blockquote><p>render_template: 有了这个文件才能在python和html中传输变量</p><p>flash：后面会用到的，作用大概是将py里面想要传送到页面上的语句通过html文件里的</p><p>get_flashed_messages()捕捉到，然后在页面上显示出来 ，此操作需设置app.secret_key= 进行加密</p><p>request：python通过request请求得到用户在网页上输入的类型</p></blockquote><h5><span id="html里面的基本格式说明">html里面的基本格式说明</span></h5><blockquote><ul><li>&lt; br &gt; 换行</li></ul></blockquote><blockquote><ul><li>label里面是在页面山会显示出来的内容</li></ul></blockquote><blockquote><ul><li><p>type属性如下表</p><p>属性值</p><p>| 值       | 描述                                                         |<br>| ——– | ———————————————————— |<br>| button   | 定义可点击按钮（多数情况下，用于通过 JavaScript 启动脚本）。 |<br>| checkbox | 定义复选框。                                                 |<br>| file     | 定义输入字段和 “浏览”按钮，供文件上传。                      |<br>| hidden   | 定义隐藏的输入字段。                                         |<br>| image    | 定义图像形式的提交按钮。                                     |<br>| password | 定义密码字段。该字段中的字符被掩码。                         |<br>| radio    | 定义单选按钮。                                               |<br>| reset    | 定义重置按钮。重置按钮会清除表单中的所有数据。               |<br>| submit   | 定义提交按钮。提交按钮会把表单数据发送到服务器。             |<br>| text     | 定义单行的输入字段，用户可在其中输入文本。默认宽度为 20 个字符。 |</p></li></ul></blockquote><hr><p>省略python里随机生成身份证部分的代码</p><p>下面是判断参数的代码：</p><pre class=" language-python"><code class="language-python"> <span class="token comment" spellcheck="true"># 判断请求方式</span>    <span class="token keyword">if</span> request<span class="token punctuation">.</span>method <span class="token operator">==</span> <span class="token string">'POST'</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 获取参数 year month day</span>        year <span class="token operator">=</span> request<span class="token punctuation">.</span>form<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'year'</span><span class="token punctuation">)</span>        month <span class="token operator">=</span> request<span class="token punctuation">.</span>form<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'month'</span><span class="token punctuation">)</span>        date <span class="token operator">=</span> request<span class="token punctuation">.</span>form<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'date'</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 判断参数是否完整</span>        <span class="token keyword">if</span> <span class="token operator">not</span> all<span class="token punctuation">(</span><span class="token punctuation">[</span>year<span class="token punctuation">,</span> month<span class="token punctuation">,</span> date<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            flash<span class="token punctuation">(</span>u<span class="token string">'请将您的资料填写完整'</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 判断输入是否符合要求</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true">#将str转换成int，text类型里面得到的是字符</span>            year <span class="token operator">=</span> int<span class="token punctuation">(</span>year<span class="token punctuation">)</span>            month <span class="token operator">=</span> int<span class="token punctuation">(</span>month<span class="token punctuation">)</span>            date <span class="token operator">=</span> int<span class="token punctuation">(</span>date<span class="token punctuation">)</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>year <span class="token operator">&lt;</span> <span class="token number">999</span> <span class="token operator">or</span> year <span class="token operator">></span> <span class="token number">2018</span> <span class="token punctuation">)</span><span class="token operator">or</span><span class="token punctuation">(</span>date <span class="token operator">&lt;</span> <span class="token number">0</span>  <span class="token operator">or</span> date <span class="token operator">></span> <span class="token number">31</span> <span class="token punctuation">)</span><span class="token operator">or</span><span class="token punctuation">(</span>month <span class="token operator">&lt;</span><span class="token number">1</span> <span class="token operator">or</span> month <span class="token operator">></span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                flash<span class="token punctuation">(</span>u<span class="token string">'资料错误'</span><span class="token punctuation">)</span></code></pre><p>html：</p><pre class=" language-html"><code class="language-html">{% for message in get_flashed_messages() %}    {{message}}{% endfor %}</code></pre><h4><span id="上述内容的简单解释">上述内容的简单解释</span></h4><pre><code>{% %}</code></pre><p>是html中的控制模块，由于message是变量，则需要</p><pre class=" language-{{}}"><code class="language-{{}}">{{}}</code></pre><p>变量模块;<strong>get_flashed_messages()是个函数，必须要加（），否则会报错</strong></p><h5><span id="py里面的u">py里面的u’ ‘</span></h5><p>对里面的字符进行转码以使他正确输出，否则有可能会编码错乱导致报错</p><hr><p><strong>最后一部分的讲解：return</strong></p><pre class=" language-python"><code class="language-python"><span class="token keyword">return</span> render_template<span class="token punctuation">(</span><span class="token string">'success.html'</span><span class="token punctuation">,</span> listID<span class="token operator">=</span>listID<span class="token punctuation">)</span></code></pre><p>返回success.html文件，并将list ID传给success.html（list ID可以是list数组，也可以是 int变量等任何变量，<strong>但是必须和文件里变量名相同，前一个list ID是success.html文件里的变量名，后一个是py里的变量名</strong>。</p><hr><h2><span id="基础知识的讲解就到此完毕啦撒花">基础知识的讲解就到此完毕啦！！！撒花！</span></h2><h2><span id="总结">总结</span></h2><p>如果看了这篇文章之后还云里雾里的话，强烈推荐先去看黑马程序员里面的视频再回来看这篇文章哟，并且可以在这个程序里面加入表单等操作来更装逼一点~~对了，如果页面不能正确显示报错的话心态不要爆炸，请回到py里面看error（error get下面的部分）出现在哪里以进行修改哦<strong>注意缩进，（），大小写等错误</strong></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> flask </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些关于c的小技巧和基础知识</title>
      <link href="2018/11/14/%E4%B8%80%E4%BA%9B%E5%85%B3%E4%BA%8Ec%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7%E5%92%8C%E5%9F%BA%E7%A1%80/"/>
      <url>2018/11/14/%E4%B8%80%E4%BA%9B%E5%85%B3%E4%BA%8Ec%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7%E5%92%8C%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>c的小技巧和基础知识</p><hr><h2><span id="基础知识">基础知识</span></h2><h3><span id="1-十进制的ascii码">1. 十进制的ASCII码</span></h3><blockquote><ul><li>0~9数字对应十进制48-57</li></ul></blockquote><blockquote><ul><li>a~z字母对应的十进制 十六进制61-7A</li></ul></blockquote><blockquote><ul><li>A~Z字母对应的十进制65-90 十六进制41-5A</li></ul></blockquote><blockquote><ul><li>汉语的ASCII码与英文数字不同，占两个字节，且为了便于区分每一个字节的第一个符号位为1，转化成10进制则是<strong>负数</strong></li></ul></blockquote><hr><h3><span id="2-c语言里合法的标识符">2. c语言里合法的标识符</span></h3><p>C语言规定,标识符以<strong>字母或下划线开头</strong>,<strong>后跟若干字母,下划线或数字</strong>,大小写字母组成的标识符是不同的,标识符的长度没有限制.例如,以下标识符是合法的:a,x,x3,BOOK_1,sum5.</p><hr><h3><span id="3-输入与输出格式">3. 输入与输出格式</span></h3><hr><h4><span id="整数与浮点数">整数与浮点数</span></h4><p>对比代码如下</p><blockquote><pre class=" language-c"><code class="language-c">    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token keyword">float</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> c <span class="token operator">=</span> a<span class="token operator">/</span>b<span class="token punctuation">;</span>     <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>结果为<strong>1</strong></p></blockquote><hr><blockquote><pre class=" language-c"><code class="language-c">    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token keyword">float</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">float</span> c <span class="token operator">=</span> a<span class="token operator">/</span>b<span class="token punctuation">;</span>     <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>​       结果为<strong>0</strong></p><ul><li>double在接受输入时必须是lf，否则值为0，输出可以是f。</li></ul></blockquote><hr><blockquote><pre class=" language-c"><code class="language-c">    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token keyword">float</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">float</span> c <span class="token operator">=</span> a<span class="token operator">/</span>b<span class="token punctuation">;</span>     <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%f"</span><span class="token punctuation">,</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>结果为 <strong>1.500000</strong></p></blockquote><hr><ul><li><strong>综上 输入和输出格式最好一致</strong></li></ul><hr><h4><span id="输出格式">输出格式</span></h4><p>%xd，右对齐，一共占x数字位，原数字所占位数大于x位按原来的数字位算，小于x位按x位算</p><p>%-xd，左对齐</p><p>%0xd，大于x位同上，小于x位多余位数用0补齐（可用于“三位数反转”）。</p><hr><h4><span id="换行tips">换行(tips)</span></h4><blockquote><ul><li>每五个数一行，if count %5==0</li></ul></blockquote><hr><h4><span id="tips">+（tips）</span></h4><blockquote><ul><li><p>使x=x+x</p><pre class=" language-c"><code class="language-c"><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d=%d"</span><span class="token punctuation">,</span>i<span class="token punctuation">,</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span>n<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>n<span class="token operator">&lt;=</span>k<span class="token punctuation">;</span>n<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"+%d"</span><span class="token punctuation">,</span>a<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ul></blockquote><h3><span id="4-boolean">4. boolean</span></h3><p>单个整数值可以表示真假，0为假，其他数值为真。</p><hr><h3><span id="5-运算符">5. 运算符</span></h3><p>运算符包含算术运算符，关系运算符（&lt;&gt;高于==和！=），逻辑运算符，条件运算符，赋值运算符，优先值递减。</p><blockquote><ul><li>c的逻辑运算符采用短路策略。</li><li>条件运算符（?:）是C语言中唯一具的<a href="https://www.baidu.com/s?wd=%E4%B8%89%E7%9B%AE%E8%BF%90%E7%AE%97%E7%AC%A6&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">三目运算符</a>，就是说它有三个运算对象。</li><li>例如：(a&gt;b)?a+b:a-b<br>其中，如果a=2，b=1，那么a&gt;b成立，执行a+b这个表达式，运算结果为3；但如果a=2，b=3，那么a&gt;b不成立，那么执行a-b这个表达式，运算结果为-1.</li></ul></blockquote><hr><h3><span id="6-switch">6. switch</span></h3><pre class=" language-c"><code class="language-c"> <span class="token keyword">switch</span>（x）<span class="token punctuation">{</span>   <span class="token keyword">case</span> x1：；<span class="token keyword">break</span>；<span class="token comment" spellcheck="true">//当x是x1的时候则执行</span>   <span class="token keyword">case</span> x2：；<span class="token keyword">break</span>；   <span class="token keyword">default</span>：；</code></pre><hr><h3><span id="7-goto">7. goto</span></h3><pre class=" language-c"><code class="language-c"><span class="token keyword">goto</span> x；x：</code></pre><hr><h3><span id="8-swap">8. swap</span></h3><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>a<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>b<span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">int</span> temp <span class="token punctuation">;</span>      temp <span class="token operator">=</span> <span class="token operator">*</span>a<span class="token punctuation">;</span>      <span class="token operator">*</span>a <span class="token operator">=</span> <span class="token operator">*</span>b<span class="token punctuation">;</span>      <span class="token operator">*</span>b <span class="token operator">=</span> temp<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  </code></pre><hr><h3><span id="9-调用头文件">9. 调用头文件</span></h3><p>#include “test.h”  （自己的项目内）</p><p>#include &lt;stdio.h&gt;</p><hr><h3><span id="10-宏定义">10. 宏定义</span></h3><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span> exchange(a,b) { int t;t=a;a=b;b=t;}</span><span class="token comment" spellcheck="true">//注意放在一行里//定义函数</span><span class="token macro property">#<span class="token directive keyword">define</span> FALSE 0</span><span class="token macro property">#<span class="token directive keyword">define</span> SQ(x) (x)*(x)</span><span class="token macro property">#<span class="token directive keyword">define</span> LAG ></span>综合运用：<span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">define</span> MAX</span><span class="token macro property">#<span class="token directive keyword">define</span> MAXIMUM(x,y) (x>y)?x:y</span><span class="token macro property">#<span class="token directive keyword">define</span> MINIMUM(x,y) (x>y)?y:x</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">,</span>b<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">ifdef</span> MAX </span><span class="token comment" spellcheck="true">//如果max被define则执行下面一句，否则执行else后面的一句</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"更大的数字是 %d\n"</span><span class="token punctuation">,</span><span class="token function">MAXIMUM</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">else</span></span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"更小的数字是 %d\n"</span><span class="token punctuation">,</span><span class="token function">MINIMUM</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span class="token comment" spellcheck="true">//每次必加</span><span class="token macro property">#<span class="token directive keyword">ifndef</span> MIN</span><span class="token comment" spellcheck="true">//如果min没被define则执行下面一句，</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"更小的数字是 %d\n"</span><span class="token punctuation">,</span><span class="token function">MINIMUM</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">else</span></span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"更大的数字是 %d\n"</span><span class="token punctuation">,</span><span class="token function">MAXIMUM</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span class="token macro property">#<span class="token directive keyword">undef</span> MAX</span><span class="token comment" spellcheck="true">//取消max的define</span><span class="token macro property">#<span class="token directive keyword">ifdef</span> MAX</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"更大的数字是 %d\n"</span><span class="token punctuation">,</span><span class="token function">MAXIMUM</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">else</span></span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"更小的数字是 %d\n"</span><span class="token punctuation">,</span><span class="token function">MINIMUM</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span class="token macro property">#<span class="token directive keyword">define</span> MIN</span><span class="token comment" spellcheck="true">//define min</span><span class="token macro property">#<span class="token directive keyword">ifndef</span> MIN</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"更小的数字是 %d\n"</span><span class="token punctuation">,</span><span class="token function">MINIMUM</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">else</span></span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"更大的数字是 %d\n"</span><span class="token punctuation">,</span><span class="token function">MAXIMUM</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">endif</span></span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>以上实例输出结果为：</p><p>更大的数字是 20<br>更小的数字是 10<br>更小的数字是 10<br>更大的数字是 20</p></blockquote><hr><h3><span id="11-静态变量">11. 静态变量</span></h3><hr><p><strong>修饰变量，变量又分为局部和全局变量，但他们都存在内存的静态区</strong></p><p><strong>静态区。所以即使这个函数运行结束，这个静态变量的值不会被销毁，函数下次使用时仍能使用。</strong></p><hr><h4><span id="静态全局变量">静态全局变量</span></h4><p>作用于仅限于变量被定义的文件。其他文件即使用extern声明也没法使用，准确说就是作用域是从定义处开始，到文件结束， 在定义处之前的那些代码不能使用它。</p><hr><h4><span id="静态局部变量">静态局部变量</span></h4><p>static局部变量中文名叫<strong>静态局部变量</strong>。</p><p>它与普通的局部变量比起来有如下几个区别:</p><blockquote><ul><li>位置：静态局部变量被编译器放在全局存储区.data，所以它虽然是局部的，但是在程序的整个生命周期中存在。</li><li>访问权限：静态局部变量只能被其作用域内的变量或函数访问。                                                                     也就是说虽然它会在程序的整个生命周期中存在，由于它是static的，它不能被其他的函数和源文件访问。</li><li>静态局部变量如果没有被用户初始化，则会被编译器自动赋值为0，以后每次调用静态局部变量的时候都用上次调用后的值。<br>这个比较好理解，每次函数调用静态局部变量的时候都修改它然后离开，下次读的时候从全局存储区读出的静态局部变量就是上次修改后的值。</li></ul></blockquote><hr><h4><span id="代码">代码</span></h4><p>第一种：</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">3</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">int</span> static_i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"i=%d\n"</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"static_i=%d\n"</span><span class="token punctuation">,</span>static_i<span class="token punctuation">)</span><span class="token punctuation">;</span>    i<span class="token operator">++</span><span class="token punctuation">;</span>    static_i<span class="token operator">++</span><span class="token punctuation">;</span>以上实例输出结果为：i<span class="token operator">=</span><span class="token number">0</span>（不变）static_i<span class="token operator">=</span><span class="token number">0</span>（静态可以变）i<span class="token operator">=</span><span class="token number">0</span>static_i<span class="token operator">=</span><span class="token number">1</span>i<span class="token operator">=</span><span class="token number">0</span>static_i<span class="token operator">=</span><span class="token number">2</span>注：但局部静态不能使main里的变量改变</code></pre><p>第二种：</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span>num<span class="token punctuation">;</span>    num<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">3</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"num 变量为 %d \n"</span><span class="token punctuation">,</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>        num<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">{</span>            <span class="token keyword">static</span> <span class="token keyword">int</span> num<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//只进行一次初始化</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"内置模块 num 变量为 %d\n"</span><span class="token punctuation">,</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>            num<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span>以上实例输出结果为：num 变量为 <span class="token number">2</span> 内置模块 num 变量为 <span class="token number">1</span>num 变量为 <span class="token number">3</span> 内置模块 num 变量为 <span class="token number">2</span>num 变量为 <span class="token number">4</span> 内置模块 num 变量为 <span class="token number">3</span>此外：全局变量只初始化一次 不管是<span class="token keyword">static</span> 还是<span class="token keyword">extern</span>全局变量加<span class="token keyword">static</span> 是为了限制其作用域（ 仅在本文件中有效 在其他文件中不可见） </code></pre><h4><span id="补充">补充</span></h4><p>（auto int）实际上是int（auto 可省略）<br>在C语言中使用<strong>auto</strong>关键字声明一个变量为自动变量，是C语言中应用最广泛的一种类型，<br>在函数内定义变量时，如果没有被声明为其他类型的变量都是自动变量，也就是说，省去类型说明符auto的都是自动变量。<br>这里的其他类型指的是变量的存储类型即：静态类型变量（static ）、寄存器类型变量（register）和外部类型变量（extern）。</p><h3><span id="12-学会按位与amp按位或按位异或">12. 学会按位与（&amp;）按位或（|）按位异或（^)</span></h3><h4><span id="按位与">按位与</span></h4><h5><span id="原理">原理</span></h5><p>0&amp;0=0; 0&amp;1=0; 1&amp;0=0; 1&amp;1=1 </p><h5><span id="代码">代码</span></h5><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a<span class="token punctuation">,</span>b<span class="token punctuation">;</span>    a<span class="token operator">=</span><span class="token number">077</span><span class="token punctuation">;</span>    b<span class="token operator">=</span>a<span class="token operator">&amp;</span><span class="token number">3</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"a &amp; b(decimal) 为 %d \n"</span><span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>    b<span class="token operator">&amp;</span><span class="token operator">=</span><span class="token number">7</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"a &amp; b(decimal) 为 %d \n"</span><span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span>以上实例输出结果为：a <span class="token operator">&amp;</span> <span class="token function">b</span><span class="token punctuation">(</span>decimal<span class="token punctuation">)</span> 为 <span class="token number">3</span> a <span class="token operator">&amp;</span> <span class="token function">b</span><span class="token punctuation">(</span>decimal<span class="token punctuation">)</span> 为 <span class="token number">3</span></code></pre><h5><span id="代码解释">代码解释</span></h5><p>0开头是8进制数， 077 = 8*7+7=63， 其2进制是 111111<br>3的2进制 编码是 011<br>2者作“按位与”运算后，结果是 011,所以是3；<br>而77的二进制是 1001101, 和3(011)作“按位与”运算后, 是 001, 所以是1</p><hr><h3><span id="按位或">按位或（|）</span></h3><p>0|0=0; 0|1=1; 1|0=1; 1|1=1 </p><hr><h4><span id="按位异或">按位异或（^)</span></h4><p>0^0=0; 0^1=1; 1^0=1; 1^1=0 </p><hr><h4><span id="左移运算ltlt">左移运算&lt;&lt;</span></h4><p>比如0的二进制为00……0000000<br>那么~0就为11……1111111<br>而~0&lt;&lt;4就是将~0的二进制码向左移动4位，右边补0，<br>即得11……1110000</p><hr><h4><span id="~按位取反">~按位取反</span></h4><p>直接计算公式<strong>~a=-(a+1)</strong>;（适用于正数和负数）</p><h5><span id="原理">原理:</span></h5><p>转化成二进制，每位取反，0变1，1变0<br>~0 = ~(0000 0000)2 = (1111 1111)2=255<br>但是javascript默认是有符号的(-127到+126)，所以要求补码(反码+1)再转为负数<br>(1111 1111)的补码是(0000 0001)符号位取反=(1000 0001)=-1<br>转到最后其实就是原码+1再转为负数，跟上面的公式是一样的~a=-(a+1);</p><hr><h4><span id="补码机器里储存的码">补码（机器里储存的码）</span></h4><h5><span id="正数">正数</span></h5><p>正整数的补码是其二进制表示，与原码相同 。</p><h5><span id="负数">负数</span></h5><p>求负整数的补码，将其对应正数二进制表示所有位取反（包括符号位，0变1，1变0）后加1<br>【不算正负号，加起来等于十进制】<br>负数首位为1，正数首位为0.<br>正数：先取反，首位不变再取反后再加1【即加1后变为负数】【取反后（负数）的补码】<br>~1 = ~(0000 0001)= (1111 1110) = (1000 0010) = -2<br>负数：           首位不变取反加1再取反【补码取反】<br>~-1=-1是这样表示的：-1的绝对值是1，二进制0000 0001，取反为1111 1110，加1等于1111 1111，所以-1为1111 1111，这个取反当然是0000 0000<br>不管正负，都是+1后变为符号相反的数。</p><hr><h4><span id="综合运用">综合运用</span></h4><p>题目：取一个整数a从右端开始的4～7位。<br>程序分析：可以这样考虑：<br>(1)先使a右移4位。<br>(2)设置一个低4位全为1,其余全为0的数。可用~(~0&lt;&lt;4)(就是将上一步得到的二进制码（11……1110000）取反，<br>得00……0001111 )<br>(3)将上面二者进行&amp;运算。<br><strong>程序源代码：</strong></p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">unsigned</span> a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">,</span>d<span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"请输入整数：\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%o"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    b<span class="token operator">=</span>a<span class="token operator">>></span><span class="token number">4</span><span class="token punctuation">;</span>    c<span class="token operator">=</span><span class="token operator">~</span><span class="token punctuation">(</span><span class="token operator">~</span><span class="token number">0</span><span class="token operator">&lt;&lt;</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//小套路</span>    d<span class="token operator">=</span>b<span class="token operator">&amp;</span>c<span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%o\n%o\n"</span><span class="token punctuation">,</span>a<span class="token punctuation">,</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span>以上实例输出结果为：请输入整数：<span class="token number">36</span>  <span class="token function">36</span><span class="token punctuation">(</span>八进制<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">11110</span><span class="token punctuation">(</span>二进制<span class="token punctuation">)</span><span class="token number">36</span><span class="token number">1</span></code></pre><h2><span id="小技巧">小技巧</span></h2><h3><span id="1-acm">1. ACM</span></h3><p><strong>可参考<a href="https://www.cnblogs.com/Leo_wl/archive/2013/05/12/3074829.html" target="_blank" rel="noopener">ACM在线测评系统评测程序设计与实现</a></strong></p><blockquote><ul><li>只允许进行算法相关的操作，不允许进行访问网络，画图等操作。</li><li>以回车结尾，行首不应有空格，输出的每两个数或字符串之间应以单个空格隔开。</li><li>由于程序不能直接读取键盘和屏幕，不允许使用getch（），getche（），gotoxy（），clrscr（），conio.h</li><li>输出格式很严格，不允许多字符或少字符，不需要界面友好分。（出现presentation error可能离成功只有一步之遥）</li><li>用double代替float，可能会出现谜之wrong</li><li>如果出现超时和超内存将会分别返回<code>Time Limit Exceeded</code>和<code>Memory Limit Exceeded</code>错误信息，如果程序执行时出现错误，比如非法指针，数组越界等，将会返回<code>Runtime Error</code>信息。如果你的程序没有出现上面的信息，说明程序顺利执行结束了。接下来，就是对你的程序的输出也就是运行结果进行检查，如果你的执行结果和我们的标准答案完全一样，则返回<code>Accepted</code>，也就说明你这个题目做对了。如果除去空格，换行，tab外完全相同，则说明你的代码格式错误，将返回<code>Presentation Error</code>，如果你输出的内容有一部分和标准答案完全一样，但是还输出了一些其他内容，则说明你多输出了，这时候将返回<code>Output Limit Exceeded</code>错误信息，出现其他情况，就说明你的输出结果和标准答案不一样，就是<code>Wrong Answer</code>了</li><li><img src="https://images0.cnblogs.com/blog/353475/201305/12152323-c115069fc92d4edeb8cdc9d3a60dc6d8.jpg&quot;流程图&quot;" alt></li></ul></blockquote><hr><h3><span id="2-声明">2. 声明</span></h3><blockquote><ul><li>尽量用const xx声明常数。</li></ul></blockquote><h3><span id="3-菜鸟c示例4的改进">3. 菜鸟c示例4的改进：</span></h3><hr><h4><span id="题目">题目</span></h4><p>输入某年某月某日，判断这一天是这一年的第几天？</p><hr><h4><span id="代码">代码</span></h4><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> day<span class="token punctuation">,</span>month<span class="token punctuation">,</span>year<span class="token punctuation">,</span>sum<span class="token punctuation">,</span>leap<span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n请输入年、月、日，格式为：年,月,日（2015,12,10）\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d,%d,%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>year<span class="token punctuation">,</span><span class="token operator">&amp;</span>month<span class="token punctuation">,</span><span class="token operator">&amp;</span>day<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 格式为：2015,12,10</span>    <span class="token keyword">switch</span><span class="token punctuation">(</span>month<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 先计算某月以前月份的总天数</span>    <span class="token punctuation">{</span>        <span class="token keyword">case</span> <span class="token number">1</span><span class="token punctuation">:</span>sum<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token number">2</span><span class="token punctuation">:</span>sum<span class="token operator">=</span><span class="token number">31</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token number">3</span><span class="token punctuation">:</span>sum<span class="token operator">=</span><span class="token number">59</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token number">4</span><span class="token punctuation">:</span>sum<span class="token operator">=</span><span class="token number">90</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token number">5</span><span class="token punctuation">:</span>sum<span class="token operator">=</span><span class="token number">120</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token number">6</span><span class="token punctuation">:</span>sum<span class="token operator">=</span><span class="token number">151</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token number">7</span><span class="token punctuation">:</span>sum<span class="token operator">=</span><span class="token number">181</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token number">8</span><span class="token punctuation">:</span>sum<span class="token operator">=</span><span class="token number">212</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token number">9</span><span class="token punctuation">:</span>sum<span class="token operator">=</span><span class="token number">243</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token number">10</span><span class="token punctuation">:</span>sum<span class="token operator">=</span><span class="token number">273</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token number">11</span><span class="token punctuation">:</span>sum<span class="token operator">=</span><span class="token number">304</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token number">12</span><span class="token punctuation">:</span>sum<span class="token operator">=</span><span class="token number">334</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">default</span><span class="token punctuation">:</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"data error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    sum<span class="token operator">=</span>sum<span class="token operator">+</span>day<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 再加上某天的天数</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>year<span class="token operator">%</span><span class="token number">400</span><span class="token operator">==</span><span class="token number">0</span><span class="token operator">||</span><span class="token punctuation">(</span>year<span class="token operator">%</span><span class="token number">4</span><span class="token operator">==</span><span class="token number">0</span><span class="token operator">&amp;&amp;</span>year<span class="token operator">%</span><span class="token number">100</span><span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">// 判断是不是闰年</span>        leap<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>       leap<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>leap<span class="token operator">==</span><span class="token number">1</span><span class="token operator">&amp;&amp;</span>month<span class="token operator">></span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// *如果是闰年且月份大于2,总天数应该加一天</span>        sum<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"这是这一年的第 %d 天。"</span><span class="token punctuation">,</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><hr><h4><span id="注意点">注意点</span></h4><blockquote><ul><li>year%400==0||(year%100!=0&amp;&amp;year%4==0)[只需一个else if 不需要goto]</li><li>如果是闰年的处理方法：闰年只是总日期加1天，则if（flag ==1&amp;&amp;month&gt;2)sum++;</li><li>总天数不需要用到for循环，只需要在switch时就进行sum</li><li>month的天数可用数组记录</li></ul></blockquote><hr><h3><span id="4-continue的用法">4. continue的用法</span></h3><blockquote><ul><li>排除法</li></ul></blockquote><hr><h3><span id="5-三目运算符的用途">5. 三目运算符的用途</span></h3><blockquote><ul><li>max = a&gt;b ? a : b ;的功能是取a和b中的大值，并把这个值赋给变量max。</li><li>max=a&gt;b ? a&gt;c ? a : c : b&gt;c ? b : c ;相当于 a&gt;b ? (a&gt;c ? a : c) : (b&gt;c ? b : c)</li></ul></blockquote><h3><span id="6-求最大公因数和最小公倍数">6. 求最大公因数和最小公倍数</span></h3><hr><h4><span id="用处">用处</span></h4><blockquote><p>减小时间复杂度</p></blockquote><hr><h4><span id="示例">示例</span></h4><blockquote><p>被除数 / 除数 = 商 …… 余数<br>6497 / 3869 = 1 …… 2628<br>3869 / 2628 = 1 …… 1241<br>2628 / 1241 = 2 …… 146<br>1241 / 146 = 8 …… 73<br>146 / 73 = 2 …… 0<br>因此最大公约数为:73<br>最小公倍数=两数之积/最大公约数=6497*3869/73=25136893 </p><hr></blockquote><h4><span id="方法">方法</span></h4><h5><span id="辗转相除法">辗转相除法</span></h5><pre class=" language-c"><code class="language-c">   <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token operator">&lt;</span>b<span class="token punctuation">)</span><span class="token punctuation">{</span>                t<span class="token operator">=</span>b<span class="token punctuation">;</span>b<span class="token operator">=</span>a<span class="token punctuation">;</span>a<span class="token operator">=</span>t<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//调整除数和被除数的位置</span>   <span class="token punctuation">}</span>    r<span class="token operator">=</span>a<span class="token operator">%</span>b<span class="token punctuation">;</span>    <span class="token keyword">int</span> n<span class="token operator">=</span>a<span class="token operator">*</span>b<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>r<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        a<span class="token operator">=</span>b<span class="token punctuation">;</span>        b<span class="token operator">=</span>r<span class="token punctuation">;</span>        r<span class="token operator">=</span>a<span class="token operator">%</span>b<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><p>补充：辗转相除法就是用来求最大公因数的，不能直接用来求最小公倍数。但是利用二者的关系，可以很方便的求出最小公倍数。</p></blockquote><hr><h3><span id="7-素数">7. 素数</span></h3><p>判断素数时不需要用flag标记是否为素数，若提前退出，j必小于i，所以if以j = i为条件，成立则为素数。</p><hr><h3><span id="8-后面两个数是前三个数之和">8. 后面两个数是前三个数之和</span></h3><hr><p><strong>不用数组的方法</strong></p><h6><span id="方法一">方法一</span></h6><pre class=" language-c"><code class="language-c">f1<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>f2<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span>f1<span class="token punctuation">)</span><span class="token punctuation">;</span>f1<span class="token operator">=</span>f1<span class="token operator">+</span>f2<span class="token punctuation">;</span>f2<span class="token operator">=</span>f1<span class="token operator">+</span>f2<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h6><span id="方法二">方法二</span></h6><pre class=" language-c"><code class="language-c">f1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>f2 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>sum <span class="token operator">=</span>f1<span class="token operator">+</span>f2<span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span>f1 <span class="token operator">=</span> f2<span class="token punctuation">;</span>f2 <span class="token operator">=</span> sum<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3><span id="9-代替三重循环">9. 代替三重循环</span></h3><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> s<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>a<span class="token punctuation">,</span>n<span class="token punctuation">,</span>t<span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"请输入 a 和 n：\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>a<span class="token punctuation">,</span><span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    t<span class="token operator">=</span>a<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        s<span class="token operator">+</span><span class="token operator">=</span>t<span class="token punctuation">;</span>        a<span class="token operator">=</span>a<span class="token operator">*</span><span class="token number">10</span><span class="token punctuation">;</span>        t<span class="token operator">+</span><span class="token operator">=</span>a<span class="token punctuation">;</span>        n<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"a+aa+...=%d\n"</span><span class="token punctuation">,</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3><span id="10-判断回文字符">10. 判断回文字符</span></h3><blockquote><p>判断是否是回文数,先将此数字按逆序重排,再与原先数值比较:</p></blockquote><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> x<span class="token punctuation">;</span>    <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"请输入一个整数:\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> x<span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">/</span><span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">)</span>        sum <span class="token operator">=</span> sum <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">+</span> i <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//亮点</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>sum <span class="token operator">==</span> x<span class="token punctuation">)</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d 是回文数\n"</span><span class="token punctuation">,</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d 不是回文数\n"</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3><span id="11-调用函数进行阶乘的两种方法">11.  调用函数进行阶乘的两种方法</span></h3><hr><p>第一种：</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> step<span class="token punctuation">;</span>    <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> step<span class="token punctuation">)</span><span class="token punctuation">{</span>        sum <span class="token operator">*</span><span class="token operator">=</span> step<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>step<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>step <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><hr><p>第二种:</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">fact</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//函数声明</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">6</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d!=%d\n"</span><span class="token punctuation">,</span>i<span class="token punctuation">,</span><span class="token function">fact</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">fact</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> sum<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        sum<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        sum<span class="token operator">=</span>j<span class="token operator">*</span><span class="token function">fact</span><span class="token punctuation">(</span>j<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> sum<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><hr><h3><span id="12-快速排序">12. 快速排序</span></h3><blockquote><ul><li>快速排序要先从右向左检索</li></ul></blockquote><hr><h3><span id="13-判断一个数是否为质数">13. 判断一个数是否为质数</span></h3><hr><h4><span id="思路">思路</span></h4><blockquote><ul><li>质数的定义：只有1和它本身两个因数的自然数，叫质数（或称素数）。<br>（如：由2÷1=2，2÷2=1，可知2的因数只有1和它本身2这两个约数，所以2就是质数。<br>与之相对立的是合数（除了1和它本身两个因数外，还有其它因数的数，叫合数。）</li><li>根据质数的定义，在判断一个数n是否是质数时，只要用1至n-1去除n，看看能否整除即可。</li><li><strong>还有更好的办法</strong>：先找一个数m，使m的平方大于n，再用小于等于m的质数去除n（n为被除数），如果都不能整除，则n必然是质数。                                                                                                                    <ul><li>如我们要判断1993是不是质数，50*50&gt;1993，那么只要用1993除以&lt;50的质数看是否能整除，若不能即为质数。在100内共有25个质数。</li></ul></li></ul></blockquote><hr><hr><h3><span id="14-将一个数组变为逆序">14. 将一个数组变为逆序</span></h3><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">define</span> N 10</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span>t<span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"原始数组是:\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>N<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>N<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        t<span class="token operator">=</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">//亮点</span>        a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>a<span class="token punctuation">[</span>N<span class="token number">-1</span><span class="token operator">-</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        a<span class="token punctuation">[</span>N<span class="token number">-1</span><span class="token operator">-</span>i<span class="token punctuation">]</span><span class="token operator">=</span>t<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n排序后的数组:\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>N<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><hr><h3><span id="15-将一个数按要求插入数组">15. 将一个数按要求插入数组</span></h3><hr><p>方法一(逆序)</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> opo<span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">13</span><span class="token punctuation">,</span><span class="token number">16</span><span class="token punctuation">,</span><span class="token number">19</span><span class="token punctuation">,</span><span class="token number">28</span><span class="token punctuation">,</span><span class="token number">40</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//原始的数组，题目给的</span>    <span class="token keyword">int</span> a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">,</span>e<span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"这是原始的数组"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>a<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>a<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>a<span class="token operator">++</span><span class="token punctuation">)</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span>opo<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n输入一个数,插入原数组"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>c<span class="token operator">=</span><span class="token number">9</span><span class="token punctuation">;</span>c<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span>c<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//使用逆序的话，可以省掉很多过程，而且清晰</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>b<span class="token operator">&lt;</span>opo<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            opo<span class="token punctuation">[</span>c<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>opo<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            opo<span class="token punctuation">[</span>c<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>b<span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>c<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> opo<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span>b<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//因为是逆序，如果b比第一个小的话写不进去，要特意弄个if</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//哇，逆序超简洁，惊了</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>e<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>e<span class="token operator">&lt;=</span><span class="token number">10</span><span class="token punctuation">;</span>e<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span>opo<span class="token punctuation">[</span>e<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>方法二</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">13</span><span class="token punctuation">,</span><span class="token number">16</span><span class="token punctuation">,</span><span class="token number">19</span><span class="token punctuation">,</span><span class="token number">28</span><span class="token punctuation">,</span><span class="token number">40</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> temp1<span class="token punctuation">,</span>temp2<span class="token punctuation">,</span>number<span class="token punctuation">,</span>end<span class="token punctuation">,</span>i<span class="token punctuation">,</span>j<span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"原始数组是:\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%4d"</span><span class="token punctuation">,</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n插入一个新的数字: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>number<span class="token punctuation">)</span><span class="token punctuation">;</span>    end<span class="token operator">=</span>a<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>number<span class="token operator">></span>end<span class="token punctuation">)</span>        a<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token operator">=</span>number<span class="token punctuation">;</span>    <span class="token keyword">else</span>    <span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span>number<span class="token punctuation">)</span>            <span class="token punctuation">{</span>                temp1<span class="token operator">=</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>number<span class="token punctuation">;</span>                <span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span><span class="token number">11</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>                <span class="token punctuation">{</span>                    temp2<span class="token operator">=</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                    a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>temp1<span class="token punctuation">;</span>                    temp1<span class="token operator">=</span>temp2<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">11</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%4d"</span><span class="token punctuation">,</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span></code></pre><hr><h3><span id="16-求字符串长度">16. 求字符串长度</span></h3><hr><h4><span id="代码">代码</span></h4><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">length</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>s<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//传入指针（数组）</span><span class="token punctuation">{</span>      <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">*</span>s<span class="token operator">!=</span><span class="token string">'\0'</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>          i<span class="token operator">++</span><span class="token punctuation">;</span>           s<span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//当前位置加上*s类型的长度</span>    <span class="token punctuation">}</span>      <span class="token keyword">return</span> i<span class="token punctuation">;</span>  <span class="token punctuation">}</span></code></pre><hr><h3><span id="17-滚动数组">17. 滚动数组</span></h3><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">move</span><span class="token punctuation">(</span><span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">,</span><span class="token keyword">int</span> offset<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">,</span><span class="token operator">*</span>arr_end<span class="token punctuation">;</span>    arr_end<span class="token operator">=</span>array<span class="token operator">+</span>n<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//数组最后一个元素的下一个位置</span>    <span class="token keyword">int</span> last<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//滚动直到偏移量为0</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>offset<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        last<span class="token operator">=</span><span class="token operator">*</span><span class="token punctuation">(</span>arr_end<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>p<span class="token operator">=</span>arr_end<span class="token number">-1</span><span class="token punctuation">;</span>p<span class="token operator">!=</span>array<span class="token punctuation">;</span><span class="token operator">--</span>p<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">//向右滚动一位</span>            <span class="token operator">*</span>p<span class="token operator">=</span><span class="token operator">*</span><span class="token punctuation">(</span>p<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">*</span>array<span class="token operator">=</span>last<span class="token punctuation">;</span>        <span class="token operator">--</span>offset<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> c </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ACM题解-母牛的故事</title>
      <link href="2018/11/13/%E6%AF%8D%E7%89%9B%E7%9A%84%E6%95%85%E4%BA%8B/"/>
      <url>2018/11/13/%E6%AF%8D%E7%89%9B%E7%9A%84%E6%95%85%E4%BA%8B/</url>
      
        <content type="html"><![CDATA[<h2><span id="题目">题目</span></h2><blockquote><p>Problem Description</p><p>有一头母牛，它每年年初生一头小母牛。每头小母牛从第四个年头开始，每年年初也生一头小母牛。请编程实现在第n年的时候，共有多少头母牛？</p><p>Input</p><p>输入数据由多个测试实例组成，每个测试实例占一行，包括一个整数n(0&lt;n&lt;55)，n的含义如题目中描述。<br>n=0表示输入数据的结束，不做处理。</p><p>Output</p><p>对于每个测试实例，输出在第n年的时候母牛的数量。<br>每个输出占一行。</p><p>Sample Input</p><pre><code>2450</code></pre><p>Sample Output</p><pre><code>246</code></pre></blockquote><h2><span id="题目分析">题目分析</span></h2><p>类似于斐波纳契数列，可得<strong>递推函数</strong></p><blockquote><p>f(n)=n        n&lt;=4</p><p>f(n)=f(n-1) + f(n-3) n&gt;4</p></blockquote><h2><span id="可用方法">可用方法</span></h2><ul><li style="list-style: none"><input type="checkbox"> 递推</li><li style="list-style: none"><input type="checkbox"> 递归</li><li style="list-style: none"><input type="checkbox"> 数组</li></ul><h2><span id="代码">代码</span></h2><h3><span id="递推需要理解">递推（需要理解）</span></h3><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> n<span class="token punctuation">,</span>i<span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> num<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token operator">/</span><span class="token number">3.0</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//注意浮点数3.0,并且由于在第4年成熟所以3年一循环</span><span class="token punctuation">{</span>num<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token operator">=</span>num<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//第4年</span>num<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token operator">=</span>num<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//第5年</span>num<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token operator">=</span>num<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//第6年</span><span class="token punctuation">}</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span>num<span class="token punctuation">[</span><span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//注意是n-1</span><span class="token punctuation">}</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><hr><h3><span id="递归思路很清晰的一种解法">递归(思路很清晰的一种解法)</span></h3><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token comment" spellcheck="true">// 递推式 f(n) = n n&lt;=4，f(n) = f(n-1) + f(n-3) n>4</span><span class="token keyword">int</span> <span class="token function">cow</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">4</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> n<span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token keyword">return</span> <span class="token function">cow</span><span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">cow</span><span class="token punctuation">(</span>n<span class="token number">-3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> n<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">EOF</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 判定结束条件</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 计算并输出结果</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token function">cow</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span> 作者：海岛Blog 来源：CSDN 原文：https<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>blog<span class="token punctuation">.</span>csdn<span class="token punctuation">.</span>net<span class="token operator">/</span>tigerisland45<span class="token operator">/</span>article<span class="token operator">/</span>details<span class="token operator">/</span><span class="token number">51772927</span> 版权声明：本文为博主原创文章，转载请附上博文链接！</code></pre><hr><h3><span id="数组运用数学思想">数组(运用数学思想）</span></h3><p><strong>当年母牛生下的小牛与几年前的母牛数（也就是当年的成熟牛）是相等的</strong></p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> n<span class="token punctuation">,</span>count<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>n<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">56</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">56</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span><span class="token number">4</span><span class="token punctuation">)</span>                a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>i<span class="token punctuation">;</span>            <span class="token keyword">else</span>                a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>a<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">+</span>a<span class="token punctuation">[</span>i<span class="token number">-3</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//第一年生的小牛在第四年成熟了</span>        <span class="token punctuation">}</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span>a<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><hr><h2><span id="总结">总结</span></h2><p><strong>注意找出项与项之间的关系，可在草稿纸上进行推演</strong></p><hr>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
